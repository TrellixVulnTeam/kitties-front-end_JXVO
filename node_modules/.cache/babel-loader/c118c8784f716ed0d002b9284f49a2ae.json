{"ast":null,"code":"import _regeneratorRuntime from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _slicedToArray from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _asyncToGenerator from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/api authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { firstValueFrom, map, of, switchMap } from 'rxjs';\nimport { Metadata, TypeRegistry } from '@polkadot/types';\nimport { getSpecAlias, getSpecExtensions, getSpecHasher, getSpecRpc, getSpecTypes, getUpgradeVersion } from '@polkadot/types-known';\nimport { assert, BN_ZERO, logger, stringify, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\nimport { detectedCapabilities } from \"./capabilities.js\";\nimport { Decorate } from \"./Decorate.js\";\nvar KEEPALIVE_INTERVAL = 10000;\nvar l = logger('api/init');\n\nvar _healthTimer = /*#__PURE__*/_classPrivateFieldLooseKey(\"healthTimer\");\n\nvar _registries = /*#__PURE__*/_classPrivateFieldLooseKey(\"registries\");\n\nvar _updateSub = /*#__PURE__*/_classPrivateFieldLooseKey(\"updateSub\");\n\nvar _onProviderConnect = /*#__PURE__*/_classPrivateFieldLooseKey(\"onProviderConnect\");\n\nvar _onProviderDisconnect = /*#__PURE__*/_classPrivateFieldLooseKey(\"onProviderDisconnect\");\n\nvar _onProviderError = /*#__PURE__*/_classPrivateFieldLooseKey(\"onProviderError\");\n\nexport var Init = /*#__PURE__*/function (_Decorate) {\n  _inherits(Init, _Decorate);\n\n  var _super = _createSuper(Init);\n\n  function Init(options, type, decorateMethod) {\n    var _this;\n\n    _classCallCheck(this, Init);\n\n    _this = _super.call(this, options, type, decorateMethod); // all injected types added to the registry for overrides\n\n    Object.defineProperty(_assertThisInitialized(_this), _healthTimer, {\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(_assertThisInitialized(_this), _registries, {\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(_assertThisInitialized(_this), _updateSub, {\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(_assertThisInitialized(_this), _onProviderConnect, {\n      writable: true,\n      value: function () {\n        var _value = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n          var _yield$Promise$all, _yield$Promise$all2, hasMeta, cryptoReady, error;\n\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _this._isConnected.next(true);\n\n                  _this.emit('connected');\n\n                  _context.prev = 2;\n                  _context.next = 5;\n                  return Promise.all([_this._loadMeta(), _this._options.initWasm === false ? Promise.resolve(true) : cryptoWaitReady()]);\n\n                case 5:\n                  _yield$Promise$all = _context.sent;\n                  _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n                  hasMeta = _yield$Promise$all2[0];\n                  cryptoReady = _yield$Promise$all2[1];\n\n                  _this._subscribeHealth();\n\n                  if (hasMeta && !_this._isReady && cryptoReady) {\n                    _this._isReady = true;\n\n                    _this.emit('ready', _assertThisInitialized(_this));\n                  }\n\n                  _context.next = 18;\n                  break;\n\n                case 13:\n                  _context.prev = 13;\n                  _context.t0 = _context[\"catch\"](2);\n                  error = new Error(\"FATAL: Unable to initialize the API: \".concat(_context.t0.message));\n                  l.error(error);\n\n                  _this.emit('error', error);\n\n                case 18:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, null, [[2, 13]]);\n        }));\n\n        function value() {\n          return _value.apply(this, arguments);\n        }\n\n        return value;\n      }()\n    });\n    Object.defineProperty(_assertThisInitialized(_this), _onProviderDisconnect, {\n      writable: true,\n      value: function value() {\n        _this._isConnected.next(false);\n\n        _this._unsubscribeHealth();\n\n        _this.emit('disconnected');\n      }\n    });\n    Object.defineProperty(_assertThisInitialized(_this), _onProviderError, {\n      writable: true,\n      value: function value(error) {\n        _this.emit('error', error);\n      }\n    });\n\n    _this.registry.setKnownTypes(options); // We only register the types (global) if this is not a cloned instance.\n    // Do right up-front, so we get in the user types before we are actually\n    // doing anything on-chain, this ensures we have the overrides in-place\n\n\n    if (!options.source) {\n      _this.registerTypes(options.types);\n    } else {\n      _classPrivateFieldLooseBase(_assertThisInitialized(_this), _registries)[_registries] = _classPrivateFieldLooseBase(options.source, _registries)[_registries];\n    }\n\n    _this._rpc = _this._decorateRpc(_this._rpcCore, _this._decorateMethod);\n    _this._rx.rpc = _this._decorateRpc(_this._rpcCore, _this._rxDecorateMethod);\n\n    if (_this.supportMulti) {\n      _this._queryMulti = _this._decorateMulti(_this._decorateMethod);\n      _this._rx.queryMulti = _this._decorateMulti(_this._rxDecorateMethod);\n    }\n\n    _this._rx.signer = options.signer;\n\n    _this._rpcCore.setRegistrySwap(function (blockHash) {\n      return _this.getBlockRegistry(blockHash);\n    });\n\n    if (_this.hasSubscriptions) {\n      _this._rpcCore.provider.on('disconnected', _classPrivateFieldLooseBase(_assertThisInitialized(_this), _onProviderDisconnect)[_onProviderDisconnect]);\n\n      _this._rpcCore.provider.on('error', _classPrivateFieldLooseBase(_assertThisInitialized(_this), _onProviderError)[_onProviderError]);\n\n      _this._rpcCore.provider.on('connected', _classPrivateFieldLooseBase(_assertThisInitialized(_this), _onProviderConnect)[_onProviderConnect]);\n    } else {\n      l.warn('Api will be available in a limited mode since the provider does not support subscriptions');\n    } // If the provider was instantiated earlier, and has already emitted a\n    // 'connected' event, then the `on('connected')` won't fire anymore. To\n    // cater for this case, we call manually `this._onProviderConnect`.\n\n\n    if (_this._rpcCore.provider.isConnected) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      _classPrivateFieldLooseBase(_assertThisInitialized(_this), _onProviderConnect)[_onProviderConnect]();\n    }\n\n    return _this;\n  }\n  /**\n   * @description Decorates a registry based on the runtime version\n   */\n\n\n  _createClass(Init, [{\n    key: \"_initRegistry\",\n    value: function _initRegistry(registry, chain, version, metadata, chainProps) {\n      registry.setChainProperties(chainProps || this.registry.getChainProperties());\n      registry.setKnownTypes(this._options);\n      registry.register(getSpecTypes(registry, chain, version.specName, version.specVersion));\n      registry.setHasher(getSpecHasher(registry, chain, version.specName)); // for bundled types, pull through the aliases defined\n\n      if (registry.knownTypes.typesBundle) {\n        registry.knownTypes.typesAlias = getSpecAlias(registry, chain, version.specName);\n      }\n\n      registry.setMetadata(metadata, undefined, _objectSpread(_objectSpread({}, getSpecExtensions(registry, chain, version.specName)), this._options.signedExtensions || {}));\n    }\n    /**\n     * @description Returns the default versioned registry\n     */\n\n  }, {\n    key: \"_getDefaultRegistry\",\n    value: function _getDefaultRegistry() {\n      // get the default registry version\n      var thisRegistry = _classPrivateFieldLooseBase(this, _registries)[_registries].find(function (_ref) {\n        var isDefault = _ref.isDefault;\n        return isDefault;\n      });\n\n      assert(thisRegistry, 'Initialization error, cannot find the default registry');\n      return thisRegistry;\n    }\n    /**\n     * @description Returns a decorated API instance at a specific point in time\n     */\n\n  }, {\n    key: \"at\",\n    value: function () {\n      var _at = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(blockHash) {\n        var u8aHash, registry;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                u8aHash = u8aToU8a(blockHash);\n                _context2.next = 3;\n                return this.getBlockRegistry(u8aHash);\n\n              case 3:\n                registry = _context2.sent;\n                return _context2.abrupt(\"return\", this._createDecorated(registry, true, u8aHash).decoratedApi);\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function at(_x) {\n        return _at.apply(this, arguments);\n      }\n\n      return at;\n    }()\n    /**\n     * @description Sets up a registry based on the block hash defined\n     */\n\n  }, {\n    key: \"getBlockRegistry\",\n    value: function () {\n      var _getBlockRegistry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(blockHash) {\n        var existingViaHash, header, _getUpgradeVersion, _getUpgradeVersion2, firstVersion, lastVersion, version, existingViaVersion, registry, metadata, result;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                existingViaHash = _classPrivateFieldLooseBase(this, _registries)[_registries].find(function (_ref2) {\n                  var lastBlockHash = _ref2.lastBlockHash;\n                  return lastBlockHash && u8aEq(lastBlockHash, blockHash);\n                });\n\n                if (!existingViaHash) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", existingViaHash);\n\n              case 3:\n                // ensure we have everything required\n                assert(this._genesisHash && this._runtimeVersion, 'Cannot retrieve data on an uninitialized chain'); // We have to assume that on the RPC layer the calls used here does not call back into\n                // the registry swap, so getHeader & getRuntimeVersion should not be historic\n\n                _context3.t0 = this.registry;\n\n                if (!this._genesisHash.eq(blockHash)) {\n                  _context3.next = 9;\n                  break;\n                }\n\n                _context3.t1 = {\n                  number: BN_ZERO,\n                  parentHash: this._genesisHash\n                };\n                _context3.next = 12;\n                break;\n\n              case 9:\n                _context3.next = 11;\n                return firstValueFrom(this._rpcCore.chain.getHeader.json(blockHash));\n\n              case 11:\n                _context3.t1 = _context3.sent;\n\n              case 12:\n                _context3.t2 = _context3.t1;\n                header = _context3.t0.createType.call(_context3.t0, 'HeaderPartial', _context3.t2);\n                assert(!header.parentHash.isEmpty, 'Unable to retrieve header and parent from supplied hash'); // get the runtime version, either on-chain or via an known upgrade history\n\n                _getUpgradeVersion = getUpgradeVersion(this._genesisHash, header.number), _getUpgradeVersion2 = _slicedToArray(_getUpgradeVersion, 2), firstVersion = _getUpgradeVersion2[0], lastVersion = _getUpgradeVersion2[1];\n                _context3.t3 = this.registry;\n\n                if (!(firstVersion && (lastVersion || firstVersion.specVersion.eq(this._runtimeVersion.specVersion)))) {\n                  _context3.next = 21;\n                  break;\n                }\n\n                _context3.t4 = {\n                  specName: this._runtimeVersion.specName,\n                  specVersion: firstVersion.specVersion\n                };\n                _context3.next = 24;\n                break;\n\n              case 21:\n                _context3.next = 23;\n                return firstValueFrom(this._rpcCore.state.getRuntimeVersion.json(header.parentHash));\n\n              case 23:\n                _context3.t4 = _context3.sent;\n\n              case 24:\n                _context3.t5 = _context3.t4;\n                version = _context3.t3.createType.call(_context3.t3, 'RuntimeVersionPartial', _context3.t5);\n                // check for pre-existing registries. We also check specName, e.g. it\n                // could be changed like in Westmint with upgrade from  shell -> westmint\n                existingViaVersion = _classPrivateFieldLooseBase(this, _registries)[_registries].find(function (_ref3) {\n                  var specName = _ref3.specName,\n                      specVersion = _ref3.specVersion;\n                  return specName.eq(version.specName) && specVersion.eq(version.specVersion);\n                });\n\n                if (!existingViaVersion) {\n                  _context3.next = 30;\n                  break;\n                }\n\n                existingViaVersion.lastBlockHash = blockHash;\n                return _context3.abrupt(\"return\", existingViaVersion);\n\n              case 30:\n                // nothing has been found, construct new\n                registry = new TypeRegistry(blockHash);\n                _context3.t6 = Metadata;\n                _context3.t7 = registry;\n                _context3.next = 35;\n                return firstValueFrom(this._rpcCore.state.getMetadata.raw(header.parentHash));\n\n              case 35:\n                _context3.t8 = _context3.sent;\n                metadata = new _context3.t6(_context3.t7, _context3.t8);\n\n                this._initRegistry(registry, this._runtimeChain, version, metadata); // add our new registry\n\n\n                result = {\n                  lastBlockHash: blockHash,\n                  metadata: metadata,\n                  registry: registry,\n                  specName: version.specName,\n                  specVersion: version.specVersion\n                };\n\n                _classPrivateFieldLooseBase(this, _registries)[_registries].push(result); // TODO This could be useful for historic, disabled due to cross-looping, i.e. .at queries\n                // this._detectCapabilities(registry, blockHash);\n\n\n                return _context3.abrupt(\"return\", result);\n\n              case 41:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getBlockRegistry(_x2) {\n        return _getBlockRegistry.apply(this, arguments);\n      }\n\n      return getBlockRegistry;\n    }()\n  }, {\n    key: \"_loadMeta\",\n    value: function () {\n      var _loadMeta2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var _this$_options$source, _ref4, _ref5;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!this._isReady) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", true);\n\n              case 2:\n                this._unsubscribeUpdates(); // only load from on-chain if we are not a clone (default path), alternatively\n                // just use the values from the source instance provided\n\n\n                if (!((_this$_options$source = this._options.source) !== null && _this$_options$source !== void 0 && _this$_options$source._isReady)) {\n                  _context4.next = 9;\n                  break;\n                }\n\n                _context4.next = 6;\n                return this._metaFromSource(this._options.source);\n\n              case 6:\n                _context4.t0 = _context4.sent;\n                _context4.next = 12;\n                break;\n\n              case 9:\n                _context4.next = 11;\n                return this._metaFromChain(this._options.metadata);\n\n              case 11:\n                _context4.t0 = _context4.sent;\n\n              case 12:\n                _ref4 = _context4.t0;\n                _ref5 = _slicedToArray(_ref4, 2);\n                this._genesisHash = _ref5[0];\n                this._runtimeMetadata = _ref5[1];\n                return _context4.abrupt(\"return\", this._initFromMeta(this._runtimeMetadata));\n\n              case 17:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function _loadMeta() {\n        return _loadMeta2.apply(this, arguments);\n      }\n\n      return _loadMeta;\n    }() // eslint-disable-next-line @typescript-eslint/require-await\n\n  }, {\n    key: \"_metaFromSource\",\n    value: function () {\n      var _metaFromSource2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(source) {\n        var methods;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                this._extrinsicType = source.extrinsicVersion;\n                this._runtimeChain = source.runtimeChain;\n                this._runtimeVersion = source.runtimeVersion;\n                methods = []; // manually build a list of all available methods in this RPC, we are\n                // going to filter on it to align the cloned RPC without making a call\n\n                Object.keys(source.rpc).forEach(function (section) {\n                  Object.keys(source.rpc[section]).forEach(function (method) {\n                    methods.push(\"\".concat(section, \"_\").concat(method));\n                  });\n                });\n\n                this._filterRpc(methods, getSpecRpc(this.registry, source.runtimeChain, source.runtimeVersion.specName));\n\n                return _context5.abrupt(\"return\", [source.genesisHash, source.runtimeMetadata]);\n\n              case 7:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function _metaFromSource(_x3) {\n        return _metaFromSource2.apply(this, arguments);\n      }\n\n      return _metaFromSource;\n    }()\n  }, {\n    key: \"_detectCapabilities\",\n    value: function _detectCapabilities(registry, blockHash) {\n      firstValueFrom(detectedCapabilities(this._rx, blockHash)).then(function (types) {\n        if (Object.keys(types).length) {\n          registry.register(types);\n          l.debug(function () {\n            return \"Capabilities detected\".concat(blockHash ? \" (\".concat(u8aToHex(u8aToU8a(blockHash)), \")\") : '', \": \").concat(stringify(types));\n          });\n        }\n      }).catch(undefined);\n      return true;\n    } // subscribe to metadata updates, inject the types on changes\n\n  }, {\n    key: \"_subscribeUpdates\",\n    value: function _subscribeUpdates() {\n      var _this2 = this;\n\n      if (_classPrivateFieldLooseBase(this, _updateSub)[_updateSub] || !this.hasSubscriptions) {\n        return;\n      }\n\n      _classPrivateFieldLooseBase(this, _updateSub)[_updateSub] = this._rpcCore.state.subscribeRuntimeVersion().pipe(switchMap(function (version) {\n        var _this$_runtimeVersion;\n\n        return (// only retrieve the metadata when the on-chain version has been changed\n          (_this$_runtimeVersion = _this2._runtimeVersion) !== null && _this$_runtimeVersion !== void 0 && _this$_runtimeVersion.specVersion.eq(version.specVersion) ? of(false) : _this2._rpcCore.state.getMetadata().pipe(map(function (metadata) {\n            l.log(\"Runtime version updated to spec=\".concat(version.specVersion.toString(), \", tx=\").concat(version.transactionVersion.toString()));\n            _this2._runtimeMetadata = metadata;\n            _this2._runtimeVersion = version;\n            _this2._rx.runtimeVersion = version; // update the default registry version\n\n            var thisRegistry = _this2._getDefaultRegistry(); // setup the data as per the current versions\n\n\n            thisRegistry.metadata = metadata;\n            thisRegistry.specVersion = version.specVersion; // clear the registry types to ensure that we override correctly\n\n            _this2._initRegistry(thisRegistry.registry.init(), _this2._runtimeChain, version, metadata);\n\n            _this2._injectMetadata(thisRegistry, false);\n\n            return _this2._detectCapabilities(thisRegistry.registry);\n          }))\n        );\n      })).subscribe();\n    }\n  }, {\n    key: \"_metaFromChain\",\n    value: function () {\n      var _metaFromChain2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(optMetadata) {\n        var _yield$Promise$all3, _yield$Promise$all4, genesisHash, runtimeVersion, chain, chainProps, rpcMethods, chainMetadata, metadataKey, metadata;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return Promise.all([firstValueFrom(this._rpcCore.chain.getBlockHash(0)), firstValueFrom(this._rpcCore.state.getRuntimeVersion()), firstValueFrom(this._rpcCore.system.chain()), firstValueFrom(this._rpcCore.system.properties()), firstValueFrom(this._rpcCore.rpc.methods()), optMetadata ? Promise.resolve(null) : firstValueFrom(this._rpcCore.state.getMetadata())]);\n\n              case 2:\n                _yield$Promise$all3 = _context6.sent;\n                _yield$Promise$all4 = _slicedToArray(_yield$Promise$all3, 6);\n                genesisHash = _yield$Promise$all4[0];\n                runtimeVersion = _yield$Promise$all4[1];\n                chain = _yield$Promise$all4[2];\n                chainProps = _yield$Promise$all4[3];\n                rpcMethods = _yield$Promise$all4[4];\n                chainMetadata = _yield$Promise$all4[5];\n                // set our chain version & genesisHash as returned\n                this._runtimeChain = chain;\n                this._runtimeVersion = runtimeVersion;\n                this._rx.runtimeVersion = runtimeVersion; // retrieve metadata, either from chain  or as pass-in via options\n\n                metadataKey = \"\".concat(genesisHash.toHex() || '0x', \"-\").concat(runtimeVersion.specVersion.toString());\n                _context6.t0 = chainMetadata;\n\n                if (_context6.t0) {\n                  _context6.next = 24;\n                  break;\n                }\n\n                if (!(optMetadata && optMetadata[metadataKey])) {\n                  _context6.next = 20;\n                  break;\n                }\n\n                _context6.t1 = new Metadata(this.registry, optMetadata[metadataKey]);\n                _context6.next = 23;\n                break;\n\n              case 20:\n                _context6.next = 22;\n                return firstValueFrom(this._rpcCore.state.getMetadata());\n\n              case 22:\n                _context6.t1 = _context6.sent;\n\n              case 23:\n                _context6.t0 = _context6.t1;\n\n              case 24:\n                metadata = _context6.t0;\n\n                // initializes the registry & RPC\n                this._initRegistry(this.registry, chain, runtimeVersion, metadata, chainProps);\n\n                this._filterRpc(rpcMethods.methods.map(function (t) {\n                  return t.toString();\n                }), getSpecRpc(this.registry, chain, runtimeVersion.specName));\n\n                this._subscribeUpdates(); // setup the initial registry, when we have none\n\n\n                if (!_classPrivateFieldLooseBase(this, _registries)[_registries].length) {\n                  _classPrivateFieldLooseBase(this, _registries)[_registries].push({\n                    isDefault: true,\n                    metadata: metadata,\n                    registry: this.registry,\n                    specName: runtimeVersion.specName,\n                    specVersion: runtimeVersion.specVersion\n                  });\n                } // get unique types & validate\n\n\n                metadata.getUniqTypes(this._options.throwOnUnknown || false);\n                return _context6.abrupt(\"return\", [genesisHash, metadata]);\n\n              case 31:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function _metaFromChain(_x4) {\n        return _metaFromChain2.apply(this, arguments);\n      }\n\n      return _metaFromChain;\n    }()\n  }, {\n    key: \"_initFromMeta\",\n    value: function _initFromMeta(metadata) {\n      this._extrinsicType = metadata.asLatest.extrinsic.version.toNumber();\n      this._rx.extrinsicType = this._extrinsicType;\n      this._rx.genesisHash = this._genesisHash;\n      this._rx.runtimeVersion = this._runtimeVersion; // must be set here\n      // inject metadata and adjust the types as detected\n\n      this._injectMetadata(this._getDefaultRegistry(), true); // derive is last, since it uses the decorated rx\n\n\n      this._rx.derive = this._decorateDeriveRx(this._rxDecorateMethod);\n      this._derive = this._decorateDerive(this._decorateMethod); // detect the on-chain capabilities\n\n      this._detectCapabilities(this.registry);\n\n      return true;\n    }\n  }, {\n    key: \"_subscribeHealth\",\n    value: function _subscribeHealth() {\n      var _this3 = this;\n\n      // Only enable the health keepalive on WS, not needed on HTTP\n      _classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer] = this.hasSubscriptions ? setInterval(function () {\n        firstValueFrom(_this3._rpcCore.system.health()).catch(function () {\n          return undefined;\n        });\n      }, KEEPALIVE_INTERVAL) : null;\n    }\n  }, {\n    key: \"_unsubscribeHealth\",\n    value: function _unsubscribeHealth() {\n      if (_classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer]) {\n        clearInterval(_classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer]);\n        _classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer] = null;\n      }\n    }\n  }, {\n    key: \"_unsubscribeUpdates\",\n    value: function _unsubscribeUpdates() {\n      if (_classPrivateFieldLooseBase(this, _updateSub)[_updateSub]) {\n        _classPrivateFieldLooseBase(this, _updateSub)[_updateSub].unsubscribe();\n\n        _classPrivateFieldLooseBase(this, _updateSub)[_updateSub] = null;\n      }\n    }\n  }, {\n    key: \"_unsubscribe\",\n    value: function _unsubscribe() {\n      this._unsubscribeHealth();\n\n      this._unsubscribeUpdates();\n    }\n  }]);\n\n  return Init;\n}(Decorate);","map":{"version":3,"sources":["/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/@polkadot/api/base/Init.js"],"names":["_defineProperty","_classPrivateFieldLooseBase","_classPrivateFieldLooseKey","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","firstValueFrom","map","of","switchMap","Metadata","TypeRegistry","getSpecAlias","getSpecExtensions","getSpecHasher","getSpecRpc","getSpecTypes","getUpgradeVersion","assert","BN_ZERO","logger","stringify","u8aEq","u8aToHex","u8aToU8a","cryptoWaitReady","detectedCapabilities","Decorate","KEEPALIVE_INTERVAL","l","_healthTimer","_registries","_updateSub","_onProviderConnect","_onProviderDisconnect","_onProviderError","Init","options","type","decorateMethod","writable","value","_isConnected","next","emit","Promise","all","_loadMeta","_options","initWasm","resolve","hasMeta","cryptoReady","_subscribeHealth","_isReady","error","Error","message","_unsubscribeHealth","registry","setKnownTypes","registerTypes","types","_rpc","_decorateRpc","_rpcCore","_decorateMethod","_rx","rpc","_rxDecorateMethod","supportMulti","_queryMulti","_decorateMulti","queryMulti","signer","setRegistrySwap","blockHash","getBlockRegistry","hasSubscriptions","provider","on","warn","isConnected","chain","version","metadata","chainProps","setChainProperties","getChainProperties","register","specName","specVersion","setHasher","knownTypes","typesBundle","typesAlias","setMetadata","undefined","signedExtensions","thisRegistry","find","isDefault","u8aHash","_createDecorated","decoratedApi","existingViaHash","lastBlockHash","_genesisHash","_runtimeVersion","eq","number","parentHash","getHeader","json","header","createType","isEmpty","firstVersion","lastVersion","state","getRuntimeVersion","existingViaVersion","getMetadata","raw","_initRegistry","_runtimeChain","result","_unsubscribeUpdates","_this$_options$source","_metaFromSource","_metaFromChain","_runtimeMetadata","_initFromMeta","_extrinsicType","extrinsicVersion","runtimeChain","runtimeVersion","methods","section","method","_filterRpc","genesisHash","runtimeMetadata","then","debug","catch","subscribeRuntimeVersion","pipe","_this$_runtimeVersion","log","toString","transactionVersion","_getDefaultRegistry","init","_injectMetadata","_detectCapabilities","subscribe","optMetadata","getBlockHash","system","properties","rpcMethods","chainMetadata","metadataKey","toHex","t","_subscribeUpdates","getUniqTypes","throwOnUnknown","asLatest","extrinsic","toNumber","extrinsicType","derive","_decorateDeriveRx","_derive","_decorateDerive","setInterval","health","clearInterval","unsubscribe"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/api authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { firstValueFrom, map, of, switchMap } from 'rxjs';\nimport { Metadata, TypeRegistry } from '@polkadot/types';\nimport { getSpecAlias, getSpecExtensions, getSpecHasher, getSpecRpc, getSpecTypes, getUpgradeVersion } from '@polkadot/types-known';\nimport { assert, BN_ZERO, logger, stringify, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\nimport { detectedCapabilities } from \"./capabilities.js\";\nimport { Decorate } from \"./Decorate.js\";\nconst KEEPALIVE_INTERVAL = 10000;\nconst l = logger('api/init');\n\nvar _healthTimer = /*#__PURE__*/_classPrivateFieldLooseKey(\"healthTimer\");\n\nvar _registries = /*#__PURE__*/_classPrivateFieldLooseKey(\"registries\");\n\nvar _updateSub = /*#__PURE__*/_classPrivateFieldLooseKey(\"updateSub\");\n\nvar _onProviderConnect = /*#__PURE__*/_classPrivateFieldLooseKey(\"onProviderConnect\");\n\nvar _onProviderDisconnect = /*#__PURE__*/_classPrivateFieldLooseKey(\"onProviderDisconnect\");\n\nvar _onProviderError = /*#__PURE__*/_classPrivateFieldLooseKey(\"onProviderError\");\n\nexport class Init extends Decorate {\n  constructor(options, type, decorateMethod) {\n    super(options, type, decorateMethod); // all injected types added to the registry for overrides\n\n    Object.defineProperty(this, _healthTimer, {\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, _registries, {\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, _updateSub, {\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, _onProviderConnect, {\n      writable: true,\n      value: async () => {\n        this._isConnected.next(true);\n\n        this.emit('connected');\n\n        try {\n          const [hasMeta, cryptoReady] = await Promise.all([this._loadMeta(), this._options.initWasm === false ? Promise.resolve(true) : cryptoWaitReady()]);\n\n          this._subscribeHealth();\n\n          if (hasMeta && !this._isReady && cryptoReady) {\n            this._isReady = true;\n            this.emit('ready', this);\n          }\n        } catch (_error) {\n          const error = new Error(`FATAL: Unable to initialize the API: ${_error.message}`);\n          l.error(error);\n          this.emit('error', error);\n        }\n      }\n    });\n    Object.defineProperty(this, _onProviderDisconnect, {\n      writable: true,\n      value: () => {\n        this._isConnected.next(false);\n\n        this._unsubscribeHealth();\n\n        this.emit('disconnected');\n      }\n    });\n    Object.defineProperty(this, _onProviderError, {\n      writable: true,\n      value: error => {\n        this.emit('error', error);\n      }\n    });\n    this.registry.setKnownTypes(options); // We only register the types (global) if this is not a cloned instance.\n    // Do right up-front, so we get in the user types before we are actually\n    // doing anything on-chain, this ensures we have the overrides in-place\n\n    if (!options.source) {\n      this.registerTypes(options.types);\n    } else {\n      _classPrivateFieldLooseBase(this, _registries)[_registries] = _classPrivateFieldLooseBase(options.source, _registries)[_registries];\n    }\n\n    this._rpc = this._decorateRpc(this._rpcCore, this._decorateMethod);\n    this._rx.rpc = this._decorateRpc(this._rpcCore, this._rxDecorateMethod);\n\n    if (this.supportMulti) {\n      this._queryMulti = this._decorateMulti(this._decorateMethod);\n      this._rx.queryMulti = this._decorateMulti(this._rxDecorateMethod);\n    }\n\n    this._rx.signer = options.signer;\n\n    this._rpcCore.setRegistrySwap(blockHash => this.getBlockRegistry(blockHash));\n\n    if (this.hasSubscriptions) {\n      this._rpcCore.provider.on('disconnected', _classPrivateFieldLooseBase(this, _onProviderDisconnect)[_onProviderDisconnect]);\n\n      this._rpcCore.provider.on('error', _classPrivateFieldLooseBase(this, _onProviderError)[_onProviderError]);\n\n      this._rpcCore.provider.on('connected', _classPrivateFieldLooseBase(this, _onProviderConnect)[_onProviderConnect]);\n    } else {\n      l.warn('Api will be available in a limited mode since the provider does not support subscriptions');\n    } // If the provider was instantiated earlier, and has already emitted a\n    // 'connected' event, then the `on('connected')` won't fire anymore. To\n    // cater for this case, we call manually `this._onProviderConnect`.\n\n\n    if (this._rpcCore.provider.isConnected) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      _classPrivateFieldLooseBase(this, _onProviderConnect)[_onProviderConnect]();\n    }\n  }\n  /**\n   * @description Decorates a registry based on the runtime version\n   */\n\n\n  _initRegistry(registry, chain, version, metadata, chainProps) {\n    registry.setChainProperties(chainProps || this.registry.getChainProperties());\n    registry.setKnownTypes(this._options);\n    registry.register(getSpecTypes(registry, chain, version.specName, version.specVersion));\n    registry.setHasher(getSpecHasher(registry, chain, version.specName)); // for bundled types, pull through the aliases defined\n\n    if (registry.knownTypes.typesBundle) {\n      registry.knownTypes.typesAlias = getSpecAlias(registry, chain, version.specName);\n    }\n\n    registry.setMetadata(metadata, undefined, _objectSpread(_objectSpread({}, getSpecExtensions(registry, chain, version.specName)), this._options.signedExtensions || {}));\n  }\n  /**\n   * @description Returns the default versioned registry\n   */\n\n\n  _getDefaultRegistry() {\n    // get the default registry version\n    const thisRegistry = _classPrivateFieldLooseBase(this, _registries)[_registries].find(({\n      isDefault\n    }) => isDefault);\n\n    assert(thisRegistry, 'Initialization error, cannot find the default registry');\n    return thisRegistry;\n  }\n  /**\n   * @description Returns a decorated API instance at a specific point in time\n   */\n\n\n  async at(blockHash) {\n    const u8aHash = u8aToU8a(blockHash);\n    const registry = await this.getBlockRegistry(u8aHash); // always create a new decoration for this specific hash\n\n    return this._createDecorated(registry, true, u8aHash).decoratedApi;\n  }\n  /**\n   * @description Sets up a registry based on the block hash defined\n   */\n\n\n  async getBlockRegistry(blockHash) {\n    const existingViaHash = _classPrivateFieldLooseBase(this, _registries)[_registries].find(({\n      lastBlockHash\n    }) => lastBlockHash && u8aEq(lastBlockHash, blockHash));\n\n    if (existingViaHash) {\n      return existingViaHash;\n    } // ensure we have everything required\n\n\n    assert(this._genesisHash && this._runtimeVersion, 'Cannot retrieve data on an uninitialized chain'); // We have to assume that on the RPC layer the calls used here does not call back into\n    // the registry swap, so getHeader & getRuntimeVersion should not be historic\n\n    const header = this.registry.createType('HeaderPartial', this._genesisHash.eq(blockHash) ? {\n      number: BN_ZERO,\n      parentHash: this._genesisHash\n    } : await firstValueFrom(this._rpcCore.chain.getHeader.json(blockHash)));\n    assert(!header.parentHash.isEmpty, 'Unable to retrieve header and parent from supplied hash'); // get the runtime version, either on-chain or via an known upgrade history\n\n    const [firstVersion, lastVersion] = getUpgradeVersion(this._genesisHash, header.number);\n    const version = this.registry.createType('RuntimeVersionPartial', firstVersion && (lastVersion || firstVersion.specVersion.eq(this._runtimeVersion.specVersion)) ? {\n      specName: this._runtimeVersion.specName,\n      specVersion: firstVersion.specVersion\n    } : await firstValueFrom(this._rpcCore.state.getRuntimeVersion.json(header.parentHash))); // check for pre-existing registries. We also check specName, e.g. it\n    // could be changed like in Westmint with upgrade from  shell -> westmint\n\n    const existingViaVersion = _classPrivateFieldLooseBase(this, _registries)[_registries].find(({\n      specName,\n      specVersion\n    }) => specName.eq(version.specName) && specVersion.eq(version.specVersion));\n\n    if (existingViaVersion) {\n      existingViaVersion.lastBlockHash = blockHash;\n      return existingViaVersion;\n    } // nothing has been found, construct new\n\n\n    const registry = new TypeRegistry(blockHash);\n    const metadata = new Metadata(registry, await firstValueFrom(this._rpcCore.state.getMetadata.raw(header.parentHash)));\n\n    this._initRegistry(registry, this._runtimeChain, version, metadata); // add our new registry\n\n\n    const result = {\n      lastBlockHash: blockHash,\n      metadata,\n      registry,\n      specName: version.specName,\n      specVersion: version.specVersion\n    };\n\n    _classPrivateFieldLooseBase(this, _registries)[_registries].push(result); // TODO This could be useful for historic, disabled due to cross-looping, i.e. .at queries\n    // this._detectCapabilities(registry, blockHash);\n\n\n    return result;\n  }\n\n  async _loadMeta() {\n    var _this$_options$source;\n\n    // on re-connection to the same chain, we don't want to re-do everything from chain again\n    if (this._isReady) {\n      return true;\n    }\n\n    this._unsubscribeUpdates(); // only load from on-chain if we are not a clone (default path), alternatively\n    // just use the values from the source instance provided\n\n\n    [this._genesisHash, this._runtimeMetadata] = (_this$_options$source = this._options.source) !== null && _this$_options$source !== void 0 && _this$_options$source._isReady ? await this._metaFromSource(this._options.source) : await this._metaFromChain(this._options.metadata);\n    return this._initFromMeta(this._runtimeMetadata);\n  } // eslint-disable-next-line @typescript-eslint/require-await\n\n\n  async _metaFromSource(source) {\n    this._extrinsicType = source.extrinsicVersion;\n    this._runtimeChain = source.runtimeChain;\n    this._runtimeVersion = source.runtimeVersion;\n    const methods = []; // manually build a list of all available methods in this RPC, we are\n    // going to filter on it to align the cloned RPC without making a call\n\n    Object.keys(source.rpc).forEach(section => {\n      Object.keys(source.rpc[section]).forEach(method => {\n        methods.push(`${section}_${method}`);\n      });\n    });\n\n    this._filterRpc(methods, getSpecRpc(this.registry, source.runtimeChain, source.runtimeVersion.specName));\n\n    return [source.genesisHash, source.runtimeMetadata];\n  }\n\n  _detectCapabilities(registry, blockHash) {\n    firstValueFrom(detectedCapabilities(this._rx, blockHash)).then(types => {\n      if (Object.keys(types).length) {\n        registry.register(types);\n        l.debug(() => `Capabilities detected${blockHash ? ` (${u8aToHex(u8aToU8a(blockHash))})` : ''}: ${stringify(types)}`);\n      }\n    }).catch(undefined);\n    return true;\n  } // subscribe to metadata updates, inject the types on changes\n\n\n  _subscribeUpdates() {\n    if (_classPrivateFieldLooseBase(this, _updateSub)[_updateSub] || !this.hasSubscriptions) {\n      return;\n    }\n\n    _classPrivateFieldLooseBase(this, _updateSub)[_updateSub] = this._rpcCore.state.subscribeRuntimeVersion().pipe(switchMap(version => {\n      var _this$_runtimeVersion;\n\n      return (// only retrieve the metadata when the on-chain version has been changed\n        (_this$_runtimeVersion = this._runtimeVersion) !== null && _this$_runtimeVersion !== void 0 && _this$_runtimeVersion.specVersion.eq(version.specVersion) ? of(false) : this._rpcCore.state.getMetadata().pipe(map(metadata => {\n          l.log(`Runtime version updated to spec=${version.specVersion.toString()}, tx=${version.transactionVersion.toString()}`);\n          this._runtimeMetadata = metadata;\n          this._runtimeVersion = version;\n          this._rx.runtimeVersion = version; // update the default registry version\n\n          const thisRegistry = this._getDefaultRegistry(); // setup the data as per the current versions\n\n\n          thisRegistry.metadata = metadata;\n          thisRegistry.specVersion = version.specVersion; // clear the registry types to ensure that we override correctly\n\n          this._initRegistry(thisRegistry.registry.init(), this._runtimeChain, version, metadata);\n\n          this._injectMetadata(thisRegistry, false);\n\n          return this._detectCapabilities(thisRegistry.registry);\n        }))\n      );\n    })).subscribe();\n  }\n\n  async _metaFromChain(optMetadata) {\n    const [genesisHash, runtimeVersion, chain, chainProps, rpcMethods, chainMetadata] = await Promise.all([firstValueFrom(this._rpcCore.chain.getBlockHash(0)), firstValueFrom(this._rpcCore.state.getRuntimeVersion()), firstValueFrom(this._rpcCore.system.chain()), firstValueFrom(this._rpcCore.system.properties()), firstValueFrom(this._rpcCore.rpc.methods()), optMetadata ? Promise.resolve(null) : firstValueFrom(this._rpcCore.state.getMetadata())]); // set our chain version & genesisHash as returned\n\n    this._runtimeChain = chain;\n    this._runtimeVersion = runtimeVersion;\n    this._rx.runtimeVersion = runtimeVersion; // retrieve metadata, either from chain  or as pass-in via options\n\n    const metadataKey = `${genesisHash.toHex() || '0x'}-${runtimeVersion.specVersion.toString()}`;\n    const metadata = chainMetadata || (optMetadata && optMetadata[metadataKey] ? new Metadata(this.registry, optMetadata[metadataKey]) : await firstValueFrom(this._rpcCore.state.getMetadata())); // initializes the registry & RPC\n\n    this._initRegistry(this.registry, chain, runtimeVersion, metadata, chainProps);\n\n    this._filterRpc(rpcMethods.methods.map(t => t.toString()), getSpecRpc(this.registry, chain, runtimeVersion.specName));\n\n    this._subscribeUpdates(); // setup the initial registry, when we have none\n\n\n    if (!_classPrivateFieldLooseBase(this, _registries)[_registries].length) {\n      _classPrivateFieldLooseBase(this, _registries)[_registries].push({\n        isDefault: true,\n        metadata,\n        registry: this.registry,\n        specName: runtimeVersion.specName,\n        specVersion: runtimeVersion.specVersion\n      });\n    } // get unique types & validate\n\n\n    metadata.getUniqTypes(this._options.throwOnUnknown || false);\n    return [genesisHash, metadata];\n  }\n\n  _initFromMeta(metadata) {\n    this._extrinsicType = metadata.asLatest.extrinsic.version.toNumber();\n    this._rx.extrinsicType = this._extrinsicType;\n    this._rx.genesisHash = this._genesisHash;\n    this._rx.runtimeVersion = this._runtimeVersion; // must be set here\n    // inject metadata and adjust the types as detected\n\n    this._injectMetadata(this._getDefaultRegistry(), true); // derive is last, since it uses the decorated rx\n\n\n    this._rx.derive = this._decorateDeriveRx(this._rxDecorateMethod);\n    this._derive = this._decorateDerive(this._decorateMethod); // detect the on-chain capabilities\n\n    this._detectCapabilities(this.registry);\n\n    return true;\n  }\n\n  _subscribeHealth() {\n    // Only enable the health keepalive on WS, not needed on HTTP\n    _classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer] = this.hasSubscriptions ? setInterval(() => {\n      firstValueFrom(this._rpcCore.system.health()).catch(() => undefined);\n    }, KEEPALIVE_INTERVAL) : null;\n  }\n\n  _unsubscribeHealth() {\n    if (_classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer]) {\n      clearInterval(_classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer]);\n      _classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer] = null;\n    }\n  }\n\n  _unsubscribeUpdates() {\n    if (_classPrivateFieldLooseBase(this, _updateSub)[_updateSub]) {\n      _classPrivateFieldLooseBase(this, _updateSub)[_updateSub].unsubscribe();\n\n      _classPrivateFieldLooseBase(this, _updateSub)[_updateSub] = null;\n    }\n  }\n\n  _unsubscribe() {\n    this._unsubscribeHealth();\n\n    this._unsubscribeUpdates();\n  }\n\n}"]},"metadata":{},"sourceType":"module"}