{"ast":null,"code":"import _regeneratorRuntime from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n// Copyright 2019-2021 @polkadot/wasm-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { assert, stringToU8a, u8aToString } from '@polkadot/util';\nvar wasm = null;\nvar cachegetInt32 = null;\nvar cachegetUint8 = null;\nexport function initWasm(_x, _x2, _x3) {\n  return _initWasm.apply(this, arguments);\n} // FIXME We really would love to clean this up and have a sign like (wasm, ...params) => T\n// Alas, TypeScript foo is not that great today, so we sadly have an extra closure here\n\nfunction _initWasm() {\n  _initWasm = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(wasmBytes, asmFn, wbg) {\n    var source;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            assert(typeof WebAssembly !== 'undefined' && wasmBytes && wasmBytes.length, 'WebAssembly is not available in your environment');\n            _context.next = 4;\n            return WebAssembly.instantiate(wasmBytes, {\n              wbg: wbg\n            });\n\n          case 4:\n            source = _context.sent;\n            wasm = source.instance.exports;\n            _context.next = 11;\n            break;\n\n          case 8:\n            _context.prev = 8;\n            _context.t0 = _context[\"catch\"](0);\n\n            // if we have a valid supplied asm.js, return that\n            if (asmFn) {\n              wasm = asmFn(wbg);\n            } else {\n              console.error('FATAL: Unable to initialize @polkadot/wasm-crypto');\n              console.error(_context.t0);\n              wasm = null;\n            }\n\n          case 11:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[0, 8]]);\n  }));\n  return _initWasm.apply(this, arguments);\n}\n\nexport function withWasm(fn) {\n  return function () {\n    assert(wasm, 'The WASM interface has not been initialized. Ensure that you wait for the initialization Promise with waitReady() from @polkadot/wasm-crypto (or cryptoWaitReady() from @polkadot/util-crypto) before attempting to use WASM-only interfaces.');\n    return fn(wasm).apply(void 0, arguments);\n  };\n}\nexport function getWasm() {\n  return wasm;\n}\nexport function getInt32() {\n  if (cachegetInt32 === null || cachegetInt32.buffer !== wasm.memory.buffer) {\n    cachegetInt32 = new Int32Array(wasm.memory.buffer);\n  }\n\n  return cachegetInt32;\n}\nexport function getUint8() {\n  if (cachegetUint8 === null || cachegetUint8.buffer !== wasm.memory.buffer) {\n    cachegetUint8 = new Uint8Array(wasm.memory.buffer);\n  }\n\n  return cachegetUint8;\n}\nexport function getU8a(ptr, len) {\n  return getUint8().subarray(ptr / 1, ptr / 1 + len);\n}\nexport function getString(ptr, len) {\n  return u8aToString(getU8a(ptr, len));\n}\nexport function allocU8a(arg) {\n  var ptr = wasm.__wbindgen_malloc(arg.length * 1);\n\n  getUint8().set(arg, ptr / 1);\n  return [ptr, arg.length];\n}\nexport function allocString(arg) {\n  return allocU8a(stringToU8a(arg));\n}\nexport function resultU8a() {\n  var r0 = getInt32()[8 / 4 + 0];\n  var r1 = getInt32()[8 / 4 + 1];\n  var ret = getU8a(r0, r1).slice();\n\n  wasm.__wbindgen_free(r0, r1 * 1);\n\n  return ret;\n}\nexport function resultString() {\n  return u8aToString(resultU8a());\n}","map":{"version":3,"sources":["/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/@polkadot/wasm-crypto/bridge.js"],"names":["assert","stringToU8a","u8aToString","wasm","cachegetInt32","cachegetUint8","initWasm","wasmBytes","asmFn","wbg","WebAssembly","length","instantiate","source","instance","exports","console","error","withWasm","fn","getWasm","getInt32","buffer","memory","Int32Array","getUint8","Uint8Array","getU8a","ptr","len","subarray","getString","allocU8a","arg","__wbindgen_malloc","set","allocString","resultU8a","r0","r1","ret","slice","__wbindgen_free","resultString"],"mappings":";;AAAA;AACA;;AAEA;AACA,SAASA,MAAT,EAAiBC,WAAjB,EAA8BC,WAA9B,QAAiD,gBAAjD;AACA,IAAIC,IAAI,GAAG,IAAX;AACA,IAAIC,aAAa,GAAG,IAApB;AACA,IAAIC,aAAa,GAAG,IAApB;AACA,gBAAsBC,QAAtB;AAAA;AAAA,C,CAiBE;AACF;;;uEAlBO,iBAAwBC,SAAxB,EAAmCC,KAAnC,EAA0CC,GAA1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEHT,YAAAA,MAAM,CAAC,OAAOU,WAAP,KAAuB,WAAvB,IAAsCH,SAAtC,IAAmDA,SAAS,CAACI,MAA9D,EAAsE,kDAAtE,CAAN;AAFG;AAAA,mBAGkBD,WAAW,CAACE,WAAZ,CAAwBL,SAAxB,EAAmC;AACtDE,cAAAA,GAAG,EAAHA;AADsD,aAAnC,CAHlB;;AAAA;AAGGI,YAAAA,MAHH;AAMHV,YAAAA,IAAI,GAAGU,MAAM,CAACC,QAAP,CAAgBC,OAAvB;AANG;AAAA;;AAAA;AAAA;AAAA;;AAQH;AACA,gBAAIP,KAAJ,EAAW;AACTL,cAAAA,IAAI,GAAGK,KAAK,CAACC,GAAD,CAAZ;AACD,aAFD,MAEO;AACLO,cAAAA,OAAO,CAACC,KAAR,CAAc,mDAAd;AACAD,cAAAA,OAAO,CAACC,KAAR;AACAd,cAAAA,IAAI,GAAG,IAAP;AACD;;AAfE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAoBP,OAAO,SAASe,QAAT,CAAkBC,EAAlB,EAAsB;AAC3B,SAAO,YAAe;AACpBnB,IAAAA,MAAM,CAACG,IAAD,EAAO,+OAAP,CAAN;AACA,WAAOgB,EAAE,CAAChB,IAAD,CAAF,yBAAP;AACD,GAHD;AAID;AACD,OAAO,SAASiB,OAAT,GAAmB;AACxB,SAAOjB,IAAP;AACD;AACD,OAAO,SAASkB,QAAT,GAAoB;AACzB,MAAIjB,aAAa,KAAK,IAAlB,IAA0BA,aAAa,CAACkB,MAAd,KAAyBnB,IAAI,CAACoB,MAAL,CAAYD,MAAnE,EAA2E;AACzElB,IAAAA,aAAa,GAAG,IAAIoB,UAAJ,CAAerB,IAAI,CAACoB,MAAL,CAAYD,MAA3B,CAAhB;AACD;;AAED,SAAOlB,aAAP;AACD;AACD,OAAO,SAASqB,QAAT,GAAoB;AACzB,MAAIpB,aAAa,KAAK,IAAlB,IAA0BA,aAAa,CAACiB,MAAd,KAAyBnB,IAAI,CAACoB,MAAL,CAAYD,MAAnE,EAA2E;AACzEjB,IAAAA,aAAa,GAAG,IAAIqB,UAAJ,CAAevB,IAAI,CAACoB,MAAL,CAAYD,MAA3B,CAAhB;AACD;;AAED,SAAOjB,aAAP;AACD;AACD,OAAO,SAASsB,MAAT,CAAgBC,GAAhB,EAAqBC,GAArB,EAA0B;AAC/B,SAAOJ,QAAQ,GAAGK,QAAX,CAAoBF,GAAG,GAAG,CAA1B,EAA6BA,GAAG,GAAG,CAAN,GAAUC,GAAvC,CAAP;AACD;AACD,OAAO,SAASE,SAAT,CAAmBH,GAAnB,EAAwBC,GAAxB,EAA6B;AAClC,SAAO3B,WAAW,CAACyB,MAAM,CAACC,GAAD,EAAMC,GAAN,CAAP,CAAlB;AACD;AACD,OAAO,SAASG,QAAT,CAAkBC,GAAlB,EAAuB;AAC5B,MAAML,GAAG,GAAGzB,IAAI,CAAC+B,iBAAL,CAAuBD,GAAG,CAACtB,MAAJ,GAAa,CAApC,CAAZ;;AAEAc,EAAAA,QAAQ,GAAGU,GAAX,CAAeF,GAAf,EAAoBL,GAAG,GAAG,CAA1B;AACA,SAAO,CAACA,GAAD,EAAMK,GAAG,CAACtB,MAAV,CAAP;AACD;AACD,OAAO,SAASyB,WAAT,CAAqBH,GAArB,EAA0B;AAC/B,SAAOD,QAAQ,CAAC/B,WAAW,CAACgC,GAAD,CAAZ,CAAf;AACD;AACD,OAAO,SAASI,SAAT,GAAqB;AAC1B,MAAMC,EAAE,GAAGjB,QAAQ,GAAG,IAAI,CAAJ,GAAQ,CAAX,CAAnB;AACA,MAAMkB,EAAE,GAAGlB,QAAQ,GAAG,IAAI,CAAJ,GAAQ,CAAX,CAAnB;AACA,MAAMmB,GAAG,GAAGb,MAAM,CAACW,EAAD,EAAKC,EAAL,CAAN,CAAeE,KAAf,EAAZ;;AAEAtC,EAAAA,IAAI,CAACuC,eAAL,CAAqBJ,EAArB,EAAyBC,EAAE,GAAG,CAA9B;;AAEA,SAAOC,GAAP;AACD;AACD,OAAO,SAASG,YAAT,GAAwB;AAC7B,SAAOzC,WAAW,CAACmC,SAAS,EAAV,CAAlB;AACD","sourcesContent":["// Copyright 2019-2021 @polkadot/wasm-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { assert, stringToU8a, u8aToString } from '@polkadot/util';\nlet wasm = null;\nlet cachegetInt32 = null;\nlet cachegetUint8 = null;\nexport async function initWasm(wasmBytes, asmFn, wbg) {\n  try {\n    assert(typeof WebAssembly !== 'undefined' && wasmBytes && wasmBytes.length, 'WebAssembly is not available in your environment');\n    const source = await WebAssembly.instantiate(wasmBytes, {\n      wbg\n    });\n    wasm = source.instance.exports;\n  } catch (error) {\n    // if we have a valid supplied asm.js, return that\n    if (asmFn) {\n      wasm = asmFn(wbg);\n    } else {\n      console.error('FATAL: Unable to initialize @polkadot/wasm-crypto');\n      console.error(error);\n      wasm = null;\n    }\n  }\n} // FIXME We really would love to clean this up and have a sign like (wasm, ...params) => T\n// Alas, TypeScript foo is not that great today, so we sadly have an extra closure here\n\nexport function withWasm(fn) {\n  return (...params) => {\n    assert(wasm, 'The WASM interface has not been initialized. Ensure that you wait for the initialization Promise with waitReady() from @polkadot/wasm-crypto (or cryptoWaitReady() from @polkadot/util-crypto) before attempting to use WASM-only interfaces.');\n    return fn(wasm)(...params);\n  };\n}\nexport function getWasm() {\n  return wasm;\n}\nexport function getInt32() {\n  if (cachegetInt32 === null || cachegetInt32.buffer !== wasm.memory.buffer) {\n    cachegetInt32 = new Int32Array(wasm.memory.buffer);\n  }\n\n  return cachegetInt32;\n}\nexport function getUint8() {\n  if (cachegetUint8 === null || cachegetUint8.buffer !== wasm.memory.buffer) {\n    cachegetUint8 = new Uint8Array(wasm.memory.buffer);\n  }\n\n  return cachegetUint8;\n}\nexport function getU8a(ptr, len) {\n  return getUint8().subarray(ptr / 1, ptr / 1 + len);\n}\nexport function getString(ptr, len) {\n  return u8aToString(getU8a(ptr, len));\n}\nexport function allocU8a(arg) {\n  const ptr = wasm.__wbindgen_malloc(arg.length * 1);\n\n  getUint8().set(arg, ptr / 1);\n  return [ptr, arg.length];\n}\nexport function allocString(arg) {\n  return allocU8a(stringToU8a(arg));\n}\nexport function resultU8a() {\n  const r0 = getInt32()[8 / 4 + 0];\n  const r1 = getInt32()[8 / 4 + 1];\n  const ret = getU8a(r0, r1).slice();\n\n  wasm.__wbindgen_free(r0, r1 * 1);\n\n  return ret;\n}\nexport function resultString() {\n  return u8aToString(resultU8a());\n}"]},"metadata":{},"sourceType":"module"}