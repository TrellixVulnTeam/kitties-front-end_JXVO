{"ast":null,"code":"import _slicedToArray from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _defineProperty2 from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nvar _encoders;\n\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { assert, isNumber, isUndefined, stringify } from '@polkadot/util';\nimport { TypeDefInfo } from \"./types.js\";\n\nvar stringIdentity = function stringIdentity(value) {\n  return value.toString();\n};\n\nvar INFO_WRAP = ['BTreeMap', 'BTreeSet', 'Compact', 'HashMap', 'Option', 'Result', 'Vec'];\nexport function paramsNotation(outer, inner) {\n  var transform = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stringIdentity;\n  return \"\".concat(outer).concat(inner ? \"<\".concat((Array.isArray(inner) ? inner : [inner]).map(transform).join(', '), \">\") : '');\n}\n\nfunction encodeWithParams(registry, typeDef, outer) {\n  var info = typeDef.info,\n      sub = typeDef.sub;\n\n  switch (info) {\n    case TypeDefInfo.BTreeMap:\n    case TypeDefInfo.BTreeSet:\n    case TypeDefInfo.Compact:\n    case TypeDefInfo.HashMap:\n    case TypeDefInfo.Linkage:\n    case TypeDefInfo.Option:\n    case TypeDefInfo.Result:\n    case TypeDefInfo.Vec:\n      return paramsNotation(outer, sub, function (param) {\n        return encodeTypeDef(registry, param);\n      });\n  }\n\n  throw new Error(\"Unable to encode \".concat(stringify(typeDef), \" with params\"));\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction encodeDoNotConstruct(registry, _ref) {\n  var displayName = _ref.displayName;\n  return \"DoNotConstruct<\".concat(displayName || 'Unknown', \">\");\n}\n\nfunction encodeSubTypes(registry, sub, asEnum, extra) {\n  var names = sub.map(function (_ref2) {\n    var name = _ref2.name;\n    return name;\n  });\n  assert(names.every(function (n) {\n    return !!n;\n  }), function () {\n    return \"Subtypes does not have consistent names, \".concat(names.join(', '));\n  });\n  var inner = sub.reduce(function (result, type) {\n    return _objectSpread(_objectSpread({}, result), {}, _defineProperty2({}, type.name, encodeTypeDef(registry, type)));\n  }, _objectSpread({}, extra));\n  return stringify(asEnum ? {\n    _enum: inner\n  } : inner);\n}\n\nfunction encodeEnum(registry, typeDef) {\n  assert(typeDef.sub && Array.isArray(typeDef.sub), 'Unable to encode Enum type');\n  var sub = typeDef.sub; // c-like enums have all Null entries\n  // TODO We need to take the disciminant into account and auto-add empty entries\n\n  return sub.every(function (_ref3) {\n    var type = _ref3.type;\n    return type === 'Null';\n  }) ? stringify({\n    _enum: sub.map(function (_ref4, index) {\n      var name = _ref4.name;\n      return \"\".concat(name || \"Empty\".concat(index));\n    })\n  }) : encodeSubTypes(registry, sub, true);\n}\n\nfunction encodeStruct(registry, typeDef) {\n  assert(typeDef.sub && Array.isArray(typeDef.sub), 'Unable to encode Struct type');\n  return encodeSubTypes(registry, typeDef.sub, false, _objectSpread({}, typeDef.alias ? {\n    _alias: _toConsumableArray(typeDef.alias.entries()).reduce(function (all, _ref5) {\n      var _ref6 = _slicedToArray(_ref5, 2),\n          k = _ref6[0],\n          v = _ref6[1];\n\n      return _objectSpread(_objectSpread({}, all), {}, _defineProperty2({}, k, v));\n    }, {})\n  } : {}));\n}\n\nfunction encodeTuple(registry, typeDef) {\n  assert(typeDef.sub && Array.isArray(typeDef.sub), 'Unable to encode Tuple type');\n  return \"(\".concat(typeDef.sub.map(function (type) {\n    return encodeTypeDef(registry, type);\n  }).join(','), \")\");\n}\n\nfunction encodeUInt(registry, _ref7, type) {\n  var length = _ref7.length;\n  assert(isNumber(length), 'Unable to encode VecFixed type');\n  return \"\".concat(type, \"<\").concat(length, \">\");\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction encodeVecFixed(registry, _ref8) {\n  var length = _ref8.length,\n      sub = _ref8.sub;\n  assert(isNumber(length) && !isUndefined(sub) && !Array.isArray(sub), 'Unable to encode VecFixed type');\n  return \"[\".concat(sub.type, \";\").concat(length, \"]\");\n} // We setup a record here to ensure we have comprehensive coverage (any item not covered will result\n// in a compile-time error with the missing index)\n\n\nvar encoders = (_encoders = {}, _defineProperty2(_encoders, TypeDefInfo.BTreeMap, function (registry, typeDef) {\n  return encodeWithParams(registry, typeDef, 'BTreeMap');\n}), _defineProperty2(_encoders, TypeDefInfo.BTreeSet, function (registry, typeDef) {\n  return encodeWithParams(registry, typeDef, 'BTreeSet');\n}), _defineProperty2(_encoders, TypeDefInfo.Compact, function (registry, typeDef) {\n  return encodeWithParams(registry, typeDef, 'Compact');\n}), _defineProperty2(_encoders, TypeDefInfo.DoNotConstruct, function (registry, typeDef) {\n  return encodeDoNotConstruct(registry, typeDef);\n}), _defineProperty2(_encoders, TypeDefInfo.Enum, function (registry, typeDef) {\n  return encodeEnum(registry, typeDef);\n}), _defineProperty2(_encoders, TypeDefInfo.HashMap, function (registry, typeDef) {\n  return encodeWithParams(registry, typeDef, 'HashMap');\n}), _defineProperty2(_encoders, TypeDefInfo.Int, function (registry, typeDef) {\n  return encodeUInt(registry, typeDef, 'Int');\n}), _defineProperty2(_encoders, TypeDefInfo.Linkage, function (registry, typeDef) {\n  return encodeWithParams(registry, typeDef, 'Linkage');\n}), _defineProperty2(_encoders, TypeDefInfo.Null, function (registry, typeDef) {\n  return 'Null';\n}), _defineProperty2(_encoders, TypeDefInfo.Option, function (registry, typeDef) {\n  return encodeWithParams(registry, typeDef, 'Option');\n}), _defineProperty2(_encoders, TypeDefInfo.Plain, function (registry, typeDef) {\n  return typeDef.displayName || typeDef.type;\n}), _defineProperty2(_encoders, TypeDefInfo.Range, function (registry, typeDef) {\n  return encodeWithParams(registry, typeDef, typeDef.type.includes('RangeInclusive') ? 'RangeInclusive' : 'Range');\n}), _defineProperty2(_encoders, TypeDefInfo.Result, function (registry, typeDef) {\n  return encodeWithParams(registry, typeDef, 'Result');\n}), _defineProperty2(_encoders, TypeDefInfo.Set, function (registry, typeDef) {\n  return typeDef.type;\n}), _defineProperty2(_encoders, TypeDefInfo.Si, function (registry, typeDef) {\n  return typeDef.lookupName || typeDef.type;\n}), _defineProperty2(_encoders, TypeDefInfo.Struct, function (registry, typeDef) {\n  return encodeStruct(registry, typeDef);\n}), _defineProperty2(_encoders, TypeDefInfo.Tuple, function (registry, typeDef) {\n  return encodeTuple(registry, typeDef);\n}), _defineProperty2(_encoders, TypeDefInfo.UInt, function (registry, typeDef) {\n  return encodeUInt(registry, typeDef, 'UInt');\n}), _defineProperty2(_encoders, TypeDefInfo.Vec, function (registry, typeDef) {\n  return encodeWithParams(registry, typeDef, 'Vec');\n}), _defineProperty2(_encoders, TypeDefInfo.VecFixed, function (registry, typeDef) {\n  return encodeVecFixed(registry, typeDef);\n}), _encoders);\n\nfunction encodeType(registry, typeDef) {\n  var withLookup = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var encoder = encoders[typeDef.info];\n  assert(encoder, function () {\n    return \"Cannot encode type \".concat(stringify(typeDef));\n  });\n  return withLookup && typeDef.lookupName ? typeDef.lookupName : encoder(registry, typeDef);\n}\n\nexport function encodeTypeDef(registry, typeDef) {\n  assert(!isUndefined(typeDef.info), function () {\n    return \"Invalid type definition with no instance info, typeDef=\".concat(stringify(typeDef));\n  }); // In the case of contracts we do have the unfortunate situation where the displayName would\n  // refer to \"Option\" when it is an option. For these, string it out, only using when actually\n  // not a top-level element to be used\n\n  if (typeDef.displayName && !INFO_WRAP.some(function (i) {\n    return typeDef.displayName === i;\n  })) {\n    return typeDef.displayName;\n  }\n\n  return encodeType(registry, typeDef);\n}\nexport function withTypeString(registry, typeDef) {\n  return _objectSpread(_objectSpread({}, typeDef), {}, {\n    type: encodeType(registry, typeDef, false)\n  });\n}","map":{"version":3,"sources":["/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/@polkadot/types/create/encodeTypes.js"],"names":["_defineProperty","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","assert","isNumber","isUndefined","stringify","TypeDefInfo","stringIdentity","value","toString","INFO_WRAP","paramsNotation","outer","inner","transform","Array","isArray","map","join","encodeWithParams","registry","typeDef","info","sub","BTreeMap","BTreeSet","Compact","HashMap","Linkage","Option","Result","Vec","param","encodeTypeDef","Error","encodeDoNotConstruct","displayName","encodeSubTypes","asEnum","extra","names","name","every","n","reduce","result","type","_enum","encodeEnum","index","encodeStruct","alias","_alias","entries","all","k","v","encodeTuple","encodeUInt","encodeVecFixed","encoders","DoNotConstruct","Enum","Int","Null","Plain","Range","includes","Set","Si","lookupName","Struct","Tuple","UInt","VecFixed","encodeType","withLookup","encoder","some","withTypeString"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, isNumber, isUndefined, stringify } from '@polkadot/util';\nimport { TypeDefInfo } from \"./types.js\";\n\nconst stringIdentity = value => value.toString();\n\nconst INFO_WRAP = ['BTreeMap', 'BTreeSet', 'Compact', 'HashMap', 'Option', 'Result', 'Vec'];\nexport function paramsNotation(outer, inner, transform = stringIdentity) {\n  return `${outer}${inner ? `<${(Array.isArray(inner) ? inner : [inner]).map(transform).join(', ')}>` : ''}`;\n}\n\nfunction encodeWithParams(registry, typeDef, outer) {\n  const {\n    info,\n    sub\n  } = typeDef;\n\n  switch (info) {\n    case TypeDefInfo.BTreeMap:\n    case TypeDefInfo.BTreeSet:\n    case TypeDefInfo.Compact:\n    case TypeDefInfo.HashMap:\n    case TypeDefInfo.Linkage:\n    case TypeDefInfo.Option:\n    case TypeDefInfo.Result:\n    case TypeDefInfo.Vec:\n      return paramsNotation(outer, sub, param => encodeTypeDef(registry, param));\n  }\n\n  throw new Error(`Unable to encode ${stringify(typeDef)} with params`);\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction encodeDoNotConstruct(registry, {\n  displayName\n}) {\n  return `DoNotConstruct<${displayName || 'Unknown'}>`;\n}\n\nfunction encodeSubTypes(registry, sub, asEnum, extra) {\n  const names = sub.map(({\n    name\n  }) => name);\n  assert(names.every(n => !!n), () => `Subtypes does not have consistent names, ${names.join(', ')}`);\n  const inner = sub.reduce((result, type) => _objectSpread(_objectSpread({}, result), {}, {\n    [type.name]: encodeTypeDef(registry, type)\n  }), _objectSpread({}, extra));\n  return stringify(asEnum ? {\n    _enum: inner\n  } : inner);\n}\n\nfunction encodeEnum(registry, typeDef) {\n  assert(typeDef.sub && Array.isArray(typeDef.sub), 'Unable to encode Enum type');\n  const sub = typeDef.sub; // c-like enums have all Null entries\n  // TODO We need to take the disciminant into account and auto-add empty entries\n\n  return sub.every(({\n    type\n  }) => type === 'Null') ? stringify({\n    _enum: sub.map(({\n      name\n    }, index) => `${name || `Empty${index}`}`)\n  }) : encodeSubTypes(registry, sub, true);\n}\n\nfunction encodeStruct(registry, typeDef) {\n  assert(typeDef.sub && Array.isArray(typeDef.sub), 'Unable to encode Struct type');\n  return encodeSubTypes(registry, typeDef.sub, false, _objectSpread({}, typeDef.alias ? {\n    _alias: [...typeDef.alias.entries()].reduce((all, [k, v]) => _objectSpread(_objectSpread({}, all), {}, {\n      [k]: v\n    }), {})\n  } : {}));\n}\n\nfunction encodeTuple(registry, typeDef) {\n  assert(typeDef.sub && Array.isArray(typeDef.sub), 'Unable to encode Tuple type');\n  return `(${typeDef.sub.map(type => encodeTypeDef(registry, type)).join(',')})`;\n}\n\nfunction encodeUInt(registry, {\n  length\n}, type) {\n  assert(isNumber(length), 'Unable to encode VecFixed type');\n  return `${type}<${length}>`;\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction encodeVecFixed(registry, {\n  length,\n  sub\n}) {\n  assert(isNumber(length) && !isUndefined(sub) && !Array.isArray(sub), 'Unable to encode VecFixed type');\n  return `[${sub.type};${length}]`;\n} // We setup a record here to ensure we have comprehensive coverage (any item not covered will result\n// in a compile-time error with the missing index)\n\n\nconst encoders = {\n  [TypeDefInfo.BTreeMap]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'BTreeMap'),\n  [TypeDefInfo.BTreeSet]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'BTreeSet'),\n  [TypeDefInfo.Compact]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'Compact'),\n  [TypeDefInfo.DoNotConstruct]: (registry, typeDef) => encodeDoNotConstruct(registry, typeDef),\n  [TypeDefInfo.Enum]: (registry, typeDef) => encodeEnum(registry, typeDef),\n  [TypeDefInfo.HashMap]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'HashMap'),\n  [TypeDefInfo.Int]: (registry, typeDef) => encodeUInt(registry, typeDef, 'Int'),\n  [TypeDefInfo.Linkage]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'Linkage'),\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  [TypeDefInfo.Null]: (registry, typeDef) => 'Null',\n  [TypeDefInfo.Option]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'Option'),\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  [TypeDefInfo.Plain]: (registry, typeDef) => typeDef.displayName || typeDef.type,\n  [TypeDefInfo.Range]: (registry, typeDef) => encodeWithParams(registry, typeDef, typeDef.type.includes('RangeInclusive') ? 'RangeInclusive' : 'Range'),\n  [TypeDefInfo.Result]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'Result'),\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  [TypeDefInfo.Set]: (registry, typeDef) => typeDef.type,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  [TypeDefInfo.Si]: (registry, typeDef) => typeDef.lookupName || typeDef.type,\n  [TypeDefInfo.Struct]: (registry, typeDef) => encodeStruct(registry, typeDef),\n  [TypeDefInfo.Tuple]: (registry, typeDef) => encodeTuple(registry, typeDef),\n  [TypeDefInfo.UInt]: (registry, typeDef) => encodeUInt(registry, typeDef, 'UInt'),\n  [TypeDefInfo.Vec]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'Vec'),\n  [TypeDefInfo.VecFixed]: (registry, typeDef) => encodeVecFixed(registry, typeDef)\n};\n\nfunction encodeType(registry, typeDef, withLookup = true) {\n  const encoder = encoders[typeDef.info];\n  assert(encoder, () => `Cannot encode type ${stringify(typeDef)}`);\n  return withLookup && typeDef.lookupName ? typeDef.lookupName : encoder(registry, typeDef);\n}\n\nexport function encodeTypeDef(registry, typeDef) {\n  assert(!isUndefined(typeDef.info), () => `Invalid type definition with no instance info, typeDef=${stringify(typeDef)}`); // In the case of contracts we do have the unfortunate situation where the displayName would\n  // refer to \"Option\" when it is an option. For these, string it out, only using when actually\n  // not a top-level element to be used\n\n  if (typeDef.displayName && !INFO_WRAP.some(i => typeDef.displayName === i)) {\n    return typeDef.displayName;\n  }\n\n  return encodeType(registry, typeDef);\n}\nexport function withTypeString(registry, typeDef) {\n  return _objectSpread(_objectSpread({}, typeDef), {}, {\n    type: encodeType(registry, typeDef, false)\n  });\n}"]},"metadata":{},"sourceType":"module"}