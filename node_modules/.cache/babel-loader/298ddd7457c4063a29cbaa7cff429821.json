{"ast":null,"code":"import _assertThisInitialized from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _defineProperty from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _slicedToArray from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\"; // Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\nimport { assert, hexToU8a, isHex, isNumber, isObject, isString, isU8a, isUndefined, stringCamelCase, stringify, stringUpperFirst, u8aConcat, u8aToHex } from '@polkadot/util';\nimport { Null } from \"../primitive/Null.js\";\nimport { Struct } from \"./Struct.js\";\nimport { mapToTypeMap } from \"./utils/index.js\"; // export interface, this is used in Enum.with, so required as public by TS\n\nfunction isRustEnum(def) {\n  var defValues = Object.values(def);\n\n  if (defValues.some(function (v) {\n    return isNumber(v);\n  })) {\n    assert(defValues.every(function (v) {\n      return isNumber(v) && v >= 0 && v <= 255;\n    }), 'Invalid number-indexed enum definition');\n    return false;\n  }\n\n  return true;\n}\n\nfunction extractDef(registry, _def) {\n  if (Array.isArray(_def)) {\n    return {\n      def: _def.reduce(function (def, key, index) {\n        def[key] = {\n          Type: Null,\n          index: index\n        };\n        return def;\n      }, {}),\n      isBasic: true,\n      isIndexed: false\n    };\n  }\n\n  var isBasic;\n  var isIndexed;\n  var def;\n\n  if (isRustEnum(_def)) {\n    def = Object.entries(mapToTypeMap(registry, _def)).reduce(function (def, _ref, index) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          key = _ref2[0],\n          Type = _ref2[1];\n\n      def[key] = {\n        Type: Type,\n        index: index\n      };\n      return def;\n    }, {});\n    isBasic = !Object.values(def).some(function (_ref3) {\n      var Type = _ref3.Type;\n      return Type !== Null;\n    });\n    isIndexed = false;\n  } else {\n    def = Object.entries(_def).reduce(function (def, _ref4) {\n      var _ref5 = _slicedToArray(_ref4, 2),\n          key = _ref5[0],\n          index = _ref5[1];\n\n      def[key] = {\n        Type: Null,\n        index: index\n      };\n      return def;\n    }, {});\n    isBasic = true;\n    isIndexed = true;\n  }\n\n  return {\n    def: def,\n    isBasic: isBasic,\n    isIndexed: isIndexed\n  };\n}\n\nfunction createFromValue(registry, def) {\n  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var value = arguments.length > 3 ? arguments[3] : undefined;\n  var entry = Object.values(def).find(function (e) {\n    return e.index === index;\n  });\n  assert(!isUndefined(entry), function () {\n    return \"Unable to create Enum via index \".concat(index, \", in \").concat(Object.keys(def).join(', '));\n  });\n  return {\n    index: index,\n    value: value instanceof entry.Type ? value : new entry.Type(registry, value)\n  };\n}\n\nfunction decodeFromJSON(registry, def, key, value) {\n  // JSON comes in the form of { \"<type (camelCase)>\": \"<value for type>\" }, here we\n  // additionally force to lower to ensure forward compat\n  var keys = Object.keys(def).map(function (k) {\n    return k.toLowerCase();\n  });\n  var keyLower = key.toLowerCase();\n  var index = keys.indexOf(keyLower);\n  assert(index !== -1, function () {\n    return \"Cannot map Enum JSON, unable to find '\".concat(key, \"' in \").concat(keys.join(', '));\n  });\n\n  try {\n    return createFromValue(registry, def, Object.values(def)[index].index, value);\n  } catch (error) {\n    throw new Error(\"Enum(\".concat(key, \"):: \").concat(error.message));\n  }\n}\n\nfunction decodeFromString(registry, def, value) {\n  return isHex(value) // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  ? decodeFromValue(registry, def, hexToU8a(value)) : decodeFromJSON(registry, def, value);\n}\n\nfunction decodeFromValue(registry, def, value) {\n  if (isU8a(value)) {\n    // nested, we don't want to match isObject below\n    if (value.length) {\n      return createFromValue(registry, def, value[0], value.subarray(1));\n    }\n  } else if (isNumber(value)) {\n    return createFromValue(registry, def, value);\n  } else if (isString(value)) {\n    return decodeFromString(registry, def, value.toString());\n  } else if (isObject(value)) {\n    var key = Object.keys(value)[0];\n    return decodeFromJSON(registry, def, key, value[key]);\n  } // Worst-case scenario, return the first with default\n\n\n  return createFromValue(registry, def, Object.values(def)[0].index);\n}\n\nfunction decodeEnum(registry, def, value, index) {\n  // NOTE We check the index path first, before looking at values - this allows treating\n  // the optional indexes before anything else, more-specific > less-specific\n  if (isNumber(index)) {\n    return createFromValue(registry, def, index, value); // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  } else if (value instanceof Enum) {\n    return createFromValue(registry, def, value.index, value.value);\n  }\n\n  return decodeFromValue(registry, def, value);\n}\n/**\n * @name Enum\n * @description\n * This implements an enum, that based on the value wraps a different type. It is effectively\n * an extension to enum where the value type is determined by the actual index.\n */\n\n\nvar _def2 = /*#__PURE__*/_classPrivateFieldLooseKey(\"def\");\n\nvar _entryIndex = /*#__PURE__*/_classPrivateFieldLooseKey(\"entryIndex\");\n\nvar _indexes = /*#__PURE__*/_classPrivateFieldLooseKey(\"indexes\");\n\nvar _isBasic = /*#__PURE__*/_classPrivateFieldLooseKey(\"isBasic\");\n\nvar _isIndexed = /*#__PURE__*/_classPrivateFieldLooseKey(\"isIndexed\");\n\nvar _raw = /*#__PURE__*/_classPrivateFieldLooseKey(\"raw\");\n\nexport var Enum = /*#__PURE__*/function () {\n  function Enum(registry, def, value, index) {\n    _classCallCheck(this, Enum);\n\n    this.registry = void 0;\n    this.createdAtHash = void 0;\n    Object.defineProperty(this, _def2, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _entryIndex, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _indexes, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _isBasic, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _isIndexed, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _raw, {\n      writable: true,\n      value: void 0\n    });\n    var defInfo = extractDef(registry, def);\n    var decoded = decodeEnum(registry, defInfo.def, value, index);\n    this.registry = registry;\n    _classPrivateFieldLooseBase(this, _def2)[_def2] = defInfo.def;\n    _classPrivateFieldLooseBase(this, _isBasic)[_isBasic] = defInfo.isBasic;\n    _classPrivateFieldLooseBase(this, _isIndexed)[_isIndexed] = defInfo.isIndexed;\n    _classPrivateFieldLooseBase(this, _indexes)[_indexes] = Object.values(defInfo.def).map(function (_ref6) {\n      var index = _ref6.index;\n      return index;\n    });\n    _classPrivateFieldLooseBase(this, _entryIndex)[_entryIndex] = _classPrivateFieldLooseBase(this, _indexes)[_indexes].indexOf(decoded.index) || 0;\n    _classPrivateFieldLooseBase(this, _raw)[_raw] = decoded.value;\n  }\n\n  _createClass(Enum, [{\n    key: \"encodedLength\",\n    get:\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    function get() {\n      return 1 + _classPrivateFieldLooseBase(this, _raw)[_raw].encodedLength;\n    }\n    /**\n     * @description returns a hash of the contents\n     */\n\n  }, {\n    key: \"hash\",\n    get: function get() {\n      return this.registry.hash(this.toU8a());\n    }\n    /**\n     * @description The index of the enum value\n     */\n\n  }, {\n    key: \"index\",\n    get: function get() {\n      return _classPrivateFieldLooseBase(this, _indexes)[_indexes][_classPrivateFieldLooseBase(this, _entryIndex)[_entryIndex]];\n    }\n    /**\n     * @description true if this is a basic enum (no values)\n     */\n\n  }, {\n    key: \"isBasic\",\n    get: function get() {\n      return _classPrivateFieldLooseBase(this, _isBasic)[_isBasic];\n    }\n    /**\n     * @description Checks if the value is an empty value\n     */\n\n  }, {\n    key: \"isEmpty\",\n    get: function get() {\n      return _classPrivateFieldLooseBase(this, _raw)[_raw].isEmpty;\n    }\n    /**\n     * @description Checks if the Enum points to a [[Null]] type\n     */\n\n  }, {\n    key: \"isNone\",\n    get: function get() {\n      return this.isNull;\n    }\n    /**\n     * @description Checks if the Enum points to a [[Null]] type (deprecated, use isNone)\n     */\n\n  }, {\n    key: \"isNull\",\n    get: function get() {\n      return _classPrivateFieldLooseBase(this, _raw)[_raw] instanceof Null;\n    }\n    /**\n     * @description The available keys for this enum\n     */\n\n  }, {\n    key: \"defIndexes\",\n    get: function get() {\n      return _classPrivateFieldLooseBase(this, _indexes)[_indexes];\n    }\n    /**\n     * @description The available keys for this enum\n     */\n\n  }, {\n    key: \"defKeys\",\n    get: function get() {\n      return Object.keys(_classPrivateFieldLooseBase(this, _def2)[_def2]);\n    }\n    /**\n     * @description The name of the type this enum value represents\n     */\n\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this.defKeys[_classPrivateFieldLooseBase(this, _entryIndex)[_entryIndex]];\n    }\n    /**\n     * @description The value of the enum\n     */\n\n  }, {\n    key: \"value\",\n    get: function get() {\n      return _classPrivateFieldLooseBase(this, _raw)[_raw];\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      // cater for the case where we only pass the enum index\n      if (isNumber(other)) {\n        return this.toNumber() === other;\n      } else if (_classPrivateFieldLooseBase(this, _isBasic)[_isBasic] && isString(other)) {\n        return this.type === other;\n      } else if (isU8a(other)) {\n        return !this.toU8a().some(function (entry, index) {\n          return entry !== other[index];\n        });\n      } else if (isHex(other)) {\n        return this.toHex() === other;\n      } else if (other instanceof Enum) {\n        return this.index === other.index && this.value.eq(other.value);\n      } else if (isObject(other)) {\n        return this.value.eq(other[this.type]);\n      } // compare the actual wrapper value\n\n\n      return this.value.eq(other);\n    }\n    /**\n     * @description Returns a hex string representation of the value\n     */\n\n  }, {\n    key: \"toHex\",\n    value: function toHex() {\n      return u8aToHex(this.toU8a());\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n\n  }, {\n    key: \"toHuman\",\n    value: function toHuman(isExtended) {\n      return _classPrivateFieldLooseBase(this, _isBasic)[_isBasic] ? this.type : _defineProperty({}, this.type, _classPrivateFieldLooseBase(this, _raw)[_raw].toHuman(isExtended));\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return _classPrivateFieldLooseBase(this, _isBasic)[_isBasic] ? this.type : _defineProperty({}, stringCamelCase(this.type), _classPrivateFieldLooseBase(this, _raw)[_raw].toJSON());\n    }\n    /**\n     * @description Returns the number representation for the value\n     */\n\n  }, {\n    key: \"toNumber\",\n    value: function toNumber() {\n      return this.index;\n    }\n    /**\n     * @description Returns a raw struct representation of the enum types\n     */\n\n  }, {\n    key: \"_toRawStruct\",\n    value: function _toRawStruct() {\n      var _this = this;\n\n      if (_classPrivateFieldLooseBase(this, _isBasic)[_isBasic]) {\n        return _classPrivateFieldLooseBase(this, _isIndexed)[_isIndexed] ? this.defKeys.reduce(function (out, key, index) {\n          out[key] = _classPrivateFieldLooseBase(_this, _indexes)[_indexes][index];\n          return out;\n        }, {}) : this.defKeys;\n      }\n\n      var typeMap = Object.entries(_classPrivateFieldLooseBase(this, _def2)[_def2]).reduce(function (out, _ref9) {\n        var _ref10 = _slicedToArray(_ref9, 2),\n            key = _ref10[0],\n            Type = _ref10[1].Type;\n\n        out[key] = Type;\n        return out;\n      }, {});\n      return Struct.typesToMap(this.registry, typeMap);\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n\n  }, {\n    key: \"toRawType\",\n    value: function toRawType() {\n      return stringify({\n        _enum: this._toRawStruct()\n      });\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.isNull ? this.type : stringify(this.toJSON());\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n\n  }, {\n    key: \"toU8a\",\n    value: function toU8a(isBare) {\n      return u8aConcat(new Uint8Array(isBare ? [] : [this.index]), _classPrivateFieldLooseBase(this, _raw)[_raw].toU8a(isBare));\n    }\n  }], [{\n    key: \"with\",\n    value: function _with(Types) {\n      return /*#__PURE__*/function (_Enum) {\n        _inherits(_class, _Enum);\n\n        var _super = _createSuper(_class);\n\n        function _class(registry, value, index) {\n          var _this2;\n\n          _classCallCheck(this, _class);\n\n          _this2 = _super.call(this, registry, Types, value, index);\n          Object.keys(_classPrivateFieldLooseBase(_assertThisInitialized(_this2), _def2)[_def2]).forEach(function (_key) {\n            var name = stringUpperFirst(stringCamelCase(_key.replace(' ', '_')));\n            var askey = \"as\".concat(name);\n            var iskey = \"is\".concat(name);\n            isUndefined(_this2[iskey]) && Object.defineProperty(_assertThisInitialized(_this2), iskey, {\n              enumerable: true,\n              get: function get() {\n                return _this2.type === _key;\n              }\n            });\n            isUndefined(_this2[askey]) && Object.defineProperty(_assertThisInitialized(_this2), askey, {\n              enumerable: true,\n              get: function get() {\n                assert(_this2[iskey], function () {\n                  return \"Cannot convert '\".concat(_this2.type, \"' via \").concat(askey);\n                });\n                return _this2.value;\n              }\n            });\n          });\n          return _this2;\n        }\n\n        return _class;\n      }(Enum);\n    }\n  }]);\n\n  return Enum;\n}();","map":{"version":3,"sources":["/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/@polkadot/types/codec/Enum.js"],"names":["_classPrivateFieldLooseBase","_classPrivateFieldLooseKey","assert","hexToU8a","isHex","isNumber","isObject","isString","isU8a","isUndefined","stringCamelCase","stringify","stringUpperFirst","u8aConcat","u8aToHex","Null","Struct","mapToTypeMap","isRustEnum","def","defValues","Object","values","some","v","every","extractDef","registry","_def","Array","isArray","reduce","key","index","Type","isBasic","isIndexed","entries","createFromValue","value","entry","find","e","keys","join","decodeFromJSON","map","k","toLowerCase","keyLower","indexOf","error","Error","message","decodeFromString","decodeFromValue","length","subarray","toString","decodeEnum","Enum","_def2","_entryIndex","_indexes","_isBasic","_isIndexed","_raw","createdAtHash","defineProperty","writable","defInfo","decoded","encodedLength","hash","toU8a","isEmpty","isNull","defKeys","other","toNumber","type","toHex","eq","isExtended","toHuman","toJSON","out","typeMap","typesToMap","_enum","_toRawStruct","isBare","Uint8Array","Types","forEach","_key","name","replace","askey","iskey","enumerable","get"],"mappings":"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","sourcesContent":["import _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, hexToU8a, isHex, isNumber, isObject, isString, isU8a, isUndefined, stringCamelCase, stringify, stringUpperFirst, u8aConcat, u8aToHex } from '@polkadot/util';\nimport { Null } from \"../primitive/Null.js\";\nimport { Struct } from \"./Struct.js\";\nimport { mapToTypeMap } from \"./utils/index.js\"; // export interface, this is used in Enum.with, so required as public by TS\n\nfunction isRustEnum(def) {\n  const defValues = Object.values(def);\n\n  if (defValues.some(v => isNumber(v))) {\n    assert(defValues.every(v => isNumber(v) && v >= 0 && v <= 255), 'Invalid number-indexed enum definition');\n    return false;\n  }\n\n  return true;\n}\n\nfunction extractDef(registry, _def) {\n  if (Array.isArray(_def)) {\n    return {\n      def: _def.reduce((def, key, index) => {\n        def[key] = {\n          Type: Null,\n          index\n        };\n        return def;\n      }, {}),\n      isBasic: true,\n      isIndexed: false\n    };\n  }\n\n  let isBasic;\n  let isIndexed;\n  let def;\n\n  if (isRustEnum(_def)) {\n    def = Object.entries(mapToTypeMap(registry, _def)).reduce((def, [key, Type], index) => {\n      def[key] = {\n        Type,\n        index\n      };\n      return def;\n    }, {});\n    isBasic = !Object.values(def).some(({\n      Type\n    }) => Type !== Null);\n    isIndexed = false;\n  } else {\n    def = Object.entries(_def).reduce((def, [key, index]) => {\n      def[key] = {\n        Type: Null,\n        index\n      };\n      return def;\n    }, {});\n    isBasic = true;\n    isIndexed = true;\n  }\n\n  return {\n    def,\n    isBasic,\n    isIndexed\n  };\n}\n\nfunction createFromValue(registry, def, index = 0, value) {\n  const entry = Object.values(def).find(e => e.index === index);\n  assert(!isUndefined(entry), () => `Unable to create Enum via index ${index}, in ${Object.keys(def).join(', ')}`);\n  return {\n    index,\n    value: value instanceof entry.Type ? value : new entry.Type(registry, value)\n  };\n}\n\nfunction decodeFromJSON(registry, def, key, value) {\n  // JSON comes in the form of { \"<type (camelCase)>\": \"<value for type>\" }, here we\n  // additionally force to lower to ensure forward compat\n  const keys = Object.keys(def).map(k => k.toLowerCase());\n  const keyLower = key.toLowerCase();\n  const index = keys.indexOf(keyLower);\n  assert(index !== -1, () => `Cannot map Enum JSON, unable to find '${key}' in ${keys.join(', ')}`);\n\n  try {\n    return createFromValue(registry, def, Object.values(def)[index].index, value);\n  } catch (error) {\n    throw new Error(`Enum(${key}):: ${error.message}`);\n  }\n}\n\nfunction decodeFromString(registry, def, value) {\n  return isHex(value) // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  ? decodeFromValue(registry, def, hexToU8a(value)) : decodeFromJSON(registry, def, value);\n}\n\nfunction decodeFromValue(registry, def, value) {\n  if (isU8a(value)) {\n    // nested, we don't want to match isObject below\n    if (value.length) {\n      return createFromValue(registry, def, value[0], value.subarray(1));\n    }\n  } else if (isNumber(value)) {\n    return createFromValue(registry, def, value);\n  } else if (isString(value)) {\n    return decodeFromString(registry, def, value.toString());\n  } else if (isObject(value)) {\n    const key = Object.keys(value)[0];\n    return decodeFromJSON(registry, def, key, value[key]);\n  } // Worst-case scenario, return the first with default\n\n\n  return createFromValue(registry, def, Object.values(def)[0].index);\n}\n\nfunction decodeEnum(registry, def, value, index) {\n  // NOTE We check the index path first, before looking at values - this allows treating\n  // the optional indexes before anything else, more-specific > less-specific\n  if (isNumber(index)) {\n    return createFromValue(registry, def, index, value); // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  } else if (value instanceof Enum) {\n    return createFromValue(registry, def, value.index, value.value);\n  }\n\n  return decodeFromValue(registry, def, value);\n}\n/**\n * @name Enum\n * @description\n * This implements an enum, that based on the value wraps a different type. It is effectively\n * an extension to enum where the value type is determined by the actual index.\n */\n\n\nvar _def2 = /*#__PURE__*/_classPrivateFieldLooseKey(\"def\");\n\nvar _entryIndex = /*#__PURE__*/_classPrivateFieldLooseKey(\"entryIndex\");\n\nvar _indexes = /*#__PURE__*/_classPrivateFieldLooseKey(\"indexes\");\n\nvar _isBasic = /*#__PURE__*/_classPrivateFieldLooseKey(\"isBasic\");\n\nvar _isIndexed = /*#__PURE__*/_classPrivateFieldLooseKey(\"isIndexed\");\n\nvar _raw = /*#__PURE__*/_classPrivateFieldLooseKey(\"raw\");\n\nexport class Enum {\n  constructor(registry, def, value, index) {\n    this.registry = void 0;\n    this.createdAtHash = void 0;\n    Object.defineProperty(this, _def2, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _entryIndex, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _indexes, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _isBasic, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _isIndexed, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _raw, {\n      writable: true,\n      value: void 0\n    });\n    const defInfo = extractDef(registry, def);\n    const decoded = decodeEnum(registry, defInfo.def, value, index);\n    this.registry = registry;\n    _classPrivateFieldLooseBase(this, _def2)[_def2] = defInfo.def;\n    _classPrivateFieldLooseBase(this, _isBasic)[_isBasic] = defInfo.isBasic;\n    _classPrivateFieldLooseBase(this, _isIndexed)[_isIndexed] = defInfo.isIndexed;\n    _classPrivateFieldLooseBase(this, _indexes)[_indexes] = Object.values(defInfo.def).map(({\n      index\n    }) => index);\n    _classPrivateFieldLooseBase(this, _entryIndex)[_entryIndex] = _classPrivateFieldLooseBase(this, _indexes)[_indexes].indexOf(decoded.index) || 0;\n    _classPrivateFieldLooseBase(this, _raw)[_raw] = decoded.value;\n  }\n\n  static with(Types) {\n    return class extends Enum {\n      constructor(registry, value, index) {\n        super(registry, Types, value, index);\n        Object.keys(_classPrivateFieldLooseBase(this, _def2)[_def2]).forEach(_key => {\n          const name = stringUpperFirst(stringCamelCase(_key.replace(' ', '_')));\n          const askey = `as${name}`;\n          const iskey = `is${name}`;\n          isUndefined(this[iskey]) && Object.defineProperty(this, iskey, {\n            enumerable: true,\n            get: () => this.type === _key\n          });\n          isUndefined(this[askey]) && Object.defineProperty(this, askey, {\n            enumerable: true,\n            get: () => {\n              assert(this[iskey], () => `Cannot convert '${this.type}' via ${askey}`);\n              return this.value;\n            }\n          });\n        });\n      }\n\n    };\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return 1 + _classPrivateFieldLooseBase(this, _raw)[_raw].encodedLength;\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n\n\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description The index of the enum value\n   */\n\n\n  get index() {\n    return _classPrivateFieldLooseBase(this, _indexes)[_indexes][_classPrivateFieldLooseBase(this, _entryIndex)[_entryIndex]];\n  }\n  /**\n   * @description true if this is a basic enum (no values)\n   */\n\n\n  get isBasic() {\n    return _classPrivateFieldLooseBase(this, _isBasic)[_isBasic];\n  }\n  /**\n   * @description Checks if the value is an empty value\n   */\n\n\n  get isEmpty() {\n    return _classPrivateFieldLooseBase(this, _raw)[_raw].isEmpty;\n  }\n  /**\n   * @description Checks if the Enum points to a [[Null]] type\n   */\n\n\n  get isNone() {\n    return this.isNull;\n  }\n  /**\n   * @description Checks if the Enum points to a [[Null]] type (deprecated, use isNone)\n   */\n\n\n  get isNull() {\n    return _classPrivateFieldLooseBase(this, _raw)[_raw] instanceof Null;\n  }\n  /**\n   * @description The available keys for this enum\n   */\n\n\n  get defIndexes() {\n    return _classPrivateFieldLooseBase(this, _indexes)[_indexes];\n  }\n  /**\n   * @description The available keys for this enum\n   */\n\n\n  get defKeys() {\n    return Object.keys(_classPrivateFieldLooseBase(this, _def2)[_def2]);\n  }\n  /**\n   * @description The name of the type this enum value represents\n   */\n\n\n  get type() {\n    return this.defKeys[_classPrivateFieldLooseBase(this, _entryIndex)[_entryIndex]];\n  }\n  /**\n   * @description The value of the enum\n   */\n\n\n  get value() {\n    return _classPrivateFieldLooseBase(this, _raw)[_raw];\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n\n\n  eq(other) {\n    // cater for the case where we only pass the enum index\n    if (isNumber(other)) {\n      return this.toNumber() === other;\n    } else if (_classPrivateFieldLooseBase(this, _isBasic)[_isBasic] && isString(other)) {\n      return this.type === other;\n    } else if (isU8a(other)) {\n      return !this.toU8a().some((entry, index) => entry !== other[index]);\n    } else if (isHex(other)) {\n      return this.toHex() === other;\n    } else if (other instanceof Enum) {\n      return this.index === other.index && this.value.eq(other.value);\n    } else if (isObject(other)) {\n      return this.value.eq(other[this.type]);\n    } // compare the actual wrapper value\n\n\n    return this.value.eq(other);\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n\n\n  toHex() {\n    return u8aToHex(this.toU8a());\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman(isExtended) {\n    return _classPrivateFieldLooseBase(this, _isBasic)[_isBasic] ? this.type : {\n      [this.type]: _classPrivateFieldLooseBase(this, _raw)[_raw].toHuman(isExtended)\n    };\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n\n\n  toJSON() {\n    return _classPrivateFieldLooseBase(this, _isBasic)[_isBasic] ? this.type : {\n      [stringCamelCase(this.type)]: _classPrivateFieldLooseBase(this, _raw)[_raw].toJSON()\n    };\n  }\n  /**\n   * @description Returns the number representation for the value\n   */\n\n\n  toNumber() {\n    return this.index;\n  }\n  /**\n   * @description Returns a raw struct representation of the enum types\n   */\n\n\n  _toRawStruct() {\n    if (_classPrivateFieldLooseBase(this, _isBasic)[_isBasic]) {\n      return _classPrivateFieldLooseBase(this, _isIndexed)[_isIndexed] ? this.defKeys.reduce((out, key, index) => {\n        out[key] = _classPrivateFieldLooseBase(this, _indexes)[_indexes][index];\n        return out;\n      }, {}) : this.defKeys;\n    }\n\n    const typeMap = Object.entries(_classPrivateFieldLooseBase(this, _def2)[_def2]).reduce((out, [key, {\n      Type\n    }]) => {\n      out[key] = Type;\n      return out;\n    }, {});\n    return Struct.typesToMap(this.registry, typeMap);\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return stringify({\n      _enum: this._toRawStruct()\n    });\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n\n\n  toString() {\n    return this.isNull ? this.type : stringify(this.toJSON());\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    return u8aConcat(new Uint8Array(isBare ? [] : [this.index]), _classPrivateFieldLooseBase(this, _raw)[_raw].toU8a(isBare));\n  }\n\n}"]},"metadata":{},"sourceType":"module"}