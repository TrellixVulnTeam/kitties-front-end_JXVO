{"ast":null,"code":"import _regeneratorRuntime from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/rpc-core authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { Observable, publishReplay, refCount } from 'rxjs';\nimport { rpcDefinitions } from '@polkadot/types';\nimport { assert, hexToU8a, isFunction, isNull, isUndefined, logger, memoize, u8aToU8a } from '@polkadot/util';\nimport { drr, refCountDelay } from \"./util/index.js\";\nexport { packageInfo } from \"./packageInfo.js\";\nexport * from \"./util/index.js\";\nvar l = logger('rpc-core');\nvar EMPTY_META = {\n  fallback: undefined,\n  modifier: {\n    isOptional: true\n  },\n  type: {\n    asMap: {\n      linked: {\n        isTrue: false\n      }\n    },\n    isMap: false\n  }\n}; // utility method to create a nicely-formatted error\n\n/** @internal */\n\nfunction logErrorMessage(method, _ref3, error) {\n  var params = _ref3.params,\n      type = _ref3.type;\n  var inputs = params.map(function (_ref4) {\n    var isOptional = _ref4.isOptional,\n        name = _ref4.name,\n        type = _ref4.type;\n    return \"\".concat(name).concat(isOptional ? '?' : '', \": \").concat(type);\n  }).join(', ');\n  l.error(\"\".concat(method, \"(\").concat(inputs, \"): \").concat(type, \":: \").concat(error.message));\n}\n\nfunction isTreatAsHex(key) {\n  // :code is problematic - it does not have the length attached, which is\n  // unlike all other storage entries where it is indeed properly encoded\n  return ['0x3a636f6465'].includes(key.toHex());\n}\n/**\n * @name Rpc\n * @summary The API may use a HTTP or WebSockets provider.\n * @description It allows for querying a Polkadot Client Node.\n * WebSockets provider is recommended since HTTP provider only supports basic querying.\n *\n * ```mermaid\n * graph LR;\n *   A[Api] --> |WebSockets| B[WsProvider];\n *   B --> |endpoint| C[ws://127.0.0.1:9944]\n * ```\n *\n * @example\n * <BR>\n *\n * ```javascript\n * import Rpc from '@polkadot/rpc-core';\n * import { WsProvider } from '@polkadot/rpc-provider/ws';\n *\n * const provider = new WsProvider('ws://127.0.0.1:9944');\n * const rpc = new Rpc(provider);\n * ```\n */\n\n\nvar _instanceId = /*#__PURE__*/_classPrivateFieldLooseKey(\"instanceId\");\n\nvar _registryDefault = /*#__PURE__*/_classPrivateFieldLooseKey(\"registryDefault\");\n\nvar _getBlockRegistry = /*#__PURE__*/_classPrivateFieldLooseKey(\"getBlockRegistry\");\n\nvar _storageCache = /*#__PURE__*/_classPrivateFieldLooseKey(\"storageCache\");\n\nexport var RpcCore = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   * Default constructor for the Api Object\n   * @param  {ProviderInterface} provider An API provider using HTTP or WebSocket\n   */\n  function RpcCore(instanceId, registry, provider) {\n    var _this$sections;\n\n    var userRpc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    _classCallCheck(this, RpcCore);\n\n    Object.defineProperty(this, _instanceId, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _registryDefault, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _getBlockRegistry, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _storageCache, {\n      writable: true,\n      value: new Map()\n    });\n    this.mapping = new Map();\n    this.provider = void 0;\n    this.sections = []; // eslint-disable-next-line @typescript-eslint/unbound-method\n\n    assert(provider && isFunction(provider.send), 'Expected Provider to API create');\n    _classPrivateFieldLooseBase(this, _instanceId)[_instanceId] = instanceId;\n    _classPrivateFieldLooseBase(this, _registryDefault)[_registryDefault] = registry;\n    this.provider = provider;\n    var sectionNames = Object.keys(rpcDefinitions); // these are the base keys (i.e. part of jsonrpc)\n\n    (_this$sections = this.sections).push.apply(_this$sections, _toConsumableArray(sectionNames)); // decorate all interfaces, defined and user on this instance\n\n\n    this.addUserInterfaces(userRpc);\n  }\n  /**\n   * @description Returns the connected status of a provider\n   */\n\n\n  _createClass(RpcCore, [{\n    key: \"isConnected\",\n    get: function get() {\n      return this.provider.isConnected;\n    }\n    /**\n     * @description Manually connect from the attached provider\n     */\n\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      return this.provider.connect();\n    }\n    /**\n     * @description Manually disconnect from the attached provider\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      return this.provider.disconnect();\n    }\n    /**\n     * @description Sets a registry swap (typically from Api)\n     */\n\n  }, {\n    key: \"setRegistrySwap\",\n    value: function setRegistrySwap(registrySwap) {\n      var _this = this;\n\n      _classPrivateFieldLooseBase(this, _getBlockRegistry)[_getBlockRegistry] = memoize(registrySwap, {\n        getInstanceId: function getInstanceId() {\n          return _classPrivateFieldLooseBase(_this, _instanceId)[_instanceId];\n        }\n      });\n    }\n  }, {\n    key: \"addUserInterfaces\",\n    value: function addUserInterfaces(userRpc) {\n      var _this$sections2,\n          _this2 = this;\n\n      // add any extra user-defined sections\n      (_this$sections2 = this.sections).push.apply(_this$sections2, _toConsumableArray(Object.keys(userRpc).filter(function (key) {\n        return !_this2.sections.includes(key);\n      }))); // decorate the sections with base and user methods\n\n\n      this.sections.forEach(function (sectionName) {\n        var _ref, _ref2;\n\n        (_ref = _this2)[_ref2 = sectionName] || (_ref[_ref2] = {});\n        var section = _this2[sectionName];\n        Object.entries(_objectSpread(_objectSpread({}, _this2._createInterface(sectionName, rpcDefinitions[sectionName] || {})), _this2._createInterface(sectionName, userRpc[sectionName] || {}))).forEach(function (_ref5) {\n          var _ref6 = _slicedToArray(_ref5, 2),\n              key = _ref6[0],\n              value = _ref6[1];\n\n          section[key] || (section[key] = value);\n        });\n      });\n    }\n  }, {\n    key: \"_createInterface\",\n    value: function _createInterface(section, methods) {\n      var _this3 = this;\n\n      return Object.entries(methods).filter(function (_ref7) {\n        var _ref8 = _slicedToArray(_ref7, 2),\n            method = _ref8[0],\n            endpoint = _ref8[1].endpoint;\n\n        return !_this3.mapping.has(endpoint || \"\".concat(section, \"_\").concat(method));\n      }).reduce(function (exposed, _ref9) {\n        var _ref10 = _slicedToArray(_ref9, 2),\n            method = _ref10[0],\n            endpoint = _ref10[1].endpoint;\n\n        var def = methods[method];\n        var isSubscription = !!def.pubsub;\n        var jsonrpc = endpoint || \"\".concat(section, \"_\").concat(method);\n\n        _this3.mapping.set(jsonrpc, _objectSpread(_objectSpread({}, def), {}, {\n          isSubscription: isSubscription,\n          jsonrpc: jsonrpc,\n          method: method,\n          section: section\n        }));\n\n        exposed[method] = isSubscription ? _this3._createMethodSubscribe(section, method, def) : _this3._createMethodSend(section, method, def);\n        return exposed;\n      }, {});\n    }\n  }, {\n    key: \"_memomize\",\n    value: function _memomize(creator, def) {\n      var _this4 = this;\n\n      var memoized = memoize(creator('scale'), {\n        getInstanceId: function getInstanceId() {\n          return _classPrivateFieldLooseBase(_this4, _instanceId)[_instanceId];\n        }\n      });\n      memoized.json = creator('json');\n      memoized.raw = creator('raw');\n      memoized.meta = def;\n      return memoized;\n    }\n  }, {\n    key: \"_createMethodSend\",\n    value: function _createMethodSend(section, method, def) {\n      var _this5 = this;\n\n      var rpcName = def.endpoint || \"\".concat(section, \"_\").concat(method);\n      var hashIndex = def.params.findIndex(function (_ref11) {\n        var isHistoric = _ref11.isHistoric;\n        return isHistoric;\n      });\n      var memoized = null; // execute the RPC call, doing a registry swap for historic as applicable\n\n      var callWithRegistry = /*#__PURE__*/function () {\n        var _ref12 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(outputAs, values) {\n          var blockHash, _ref13, registry, params, data;\n\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  blockHash = hashIndex === -1 ? null : values[hashIndex];\n\n                  if (!(outputAs === 'scale' && blockHash && _classPrivateFieldLooseBase(_this5, _getBlockRegistry)[_getBlockRegistry])) {\n                    _context.next = 7;\n                    break;\n                  }\n\n                  _context.next = 4;\n                  return _classPrivateFieldLooseBase(_this5, _getBlockRegistry)[_getBlockRegistry](u8aToU8a(blockHash));\n\n                case 4:\n                  _context.t0 = _context.sent;\n                  _context.next = 8;\n                  break;\n\n                case 7:\n                  _context.t0 = {\n                    registry: _classPrivateFieldLooseBase(_this5, _registryDefault)[_registryDefault]\n                  };\n\n                case 8:\n                  _ref13 = _context.t0;\n                  registry = _ref13.registry;\n                  params = _this5._formatInputs(registry, null, def, values);\n                  _context.next = 13;\n                  return _this5.provider.send(rpcName, params.map(function (param) {\n                    return param.toJSON();\n                  }));\n\n                case 13:\n                  data = _context.sent;\n                  return _context.abrupt(\"return\", outputAs === 'scale' ? _this5._formatOutput(registry, blockHash, method, def, params, data) : registry.createType(outputAs === 'raw' ? 'Raw' : 'Json', data));\n\n                case 15:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee);\n        }));\n\n        return function callWithRegistry(_x, _x2) {\n          return _ref12.apply(this, arguments);\n        };\n      }();\n\n      var creator = function creator(outputAs) {\n        return function () {\n          for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n            values[_key] = arguments[_key];\n          }\n\n          var isDelayed = outputAs === 'scale' && hashIndex !== -1 && !!values[hashIndex];\n          return new Observable(function (observer) {\n            callWithRegistry(outputAs, values).then(function (value) {\n              observer.next(value);\n              observer.complete();\n            }).catch(function (error) {\n              logErrorMessage(method, def, error);\n              observer.error(error);\n              observer.complete();\n            });\n            return function () {\n              var _memoized3;\n\n              var _memoized; // delete old results from cache\n\n\n              (_memoized = memoized) === null || _memoized === void 0 ? void 0 : (_memoized3 = _memoized).unmemoize.apply(_memoized3, values);\n            };\n          }).pipe(publishReplay(1), // create a Replay(1)\n          isDelayed ? refCountDelay() // Unsubscribe after delay\n          : refCount());\n        };\n      };\n\n      memoized = this._memomize(creator, def);\n      return memoized;\n    } // create a subscriptor, it subscribes once and resolves with the id as subscribe\n\n  }, {\n    key: \"_createSubscriber\",\n    value: function _createSubscriber(_ref14, errorHandler) {\n      var _this6 = this;\n\n      var paramsJson = _ref14.paramsJson,\n          subName = _ref14.subName,\n          subType = _ref14.subType,\n          update = _ref14.update;\n      return new Promise(function (resolve, reject) {\n        _this6.provider.subscribe(subType, subName, paramsJson, update).then(resolve).catch(function (error) {\n          errorHandler(error);\n          reject(error);\n        });\n      });\n    }\n  }, {\n    key: \"_createMethodSubscribe\",\n    value: function _createMethodSubscribe(section, method, def) {\n      var _this7 = this;\n\n      var _def$pubsub = _slicedToArray(def.pubsub, 3),\n          updateType = _def$pubsub[0],\n          subMethod = _def$pubsub[1],\n          unsubMethod = _def$pubsub[2];\n\n      var subName = \"\".concat(section, \"_\").concat(subMethod);\n      var unsubName = \"\".concat(section, \"_\").concat(unsubMethod);\n      var subType = \"\".concat(section, \"_\").concat(updateType);\n      var memoized = null;\n\n      var creator = function creator(outputAs) {\n        return function () {\n          for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            values[_key2] = arguments[_key2];\n          }\n\n          return new Observable(function (observer) {\n            // Have at least an empty promise, as used in the unsubscribe\n            var subscriptionPromise = Promise.resolve(null);\n\n            var registry = _classPrivateFieldLooseBase(_this7, _registryDefault)[_registryDefault];\n\n            var errorHandler = function errorHandler(error) {\n              logErrorMessage(method, def, error);\n              observer.error(error);\n            };\n\n            try {\n              var params = _this7._formatInputs(registry, null, def, values);\n\n              var paramsJson = params.map(function (param) {\n                return param.toJSON();\n              });\n\n              var update = function update(error, result) {\n                if (error) {\n                  logErrorMessage(method, def, error);\n                  return;\n                }\n\n                try {\n                  observer.next(outputAs === 'scale' ? _this7._formatOutput(registry, null, method, def, params, result) : registry.createType(outputAs === 'raw' ? 'Raw' : 'Json', result));\n                } catch (error) {\n                  observer.error(error);\n                }\n              };\n\n              subscriptionPromise = _this7._createSubscriber({\n                paramsJson: paramsJson,\n                subName: subName,\n                subType: subType,\n                update: update\n              }, errorHandler);\n            } catch (error) {\n              errorHandler(error);\n            } // Teardown logic\n\n\n            return function () {\n              var _memoized4;\n\n              var _memoized2; // Delete from cache, so old results don't hang around\n\n\n              (_memoized2 = memoized) === null || _memoized2 === void 0 ? void 0 : (_memoized4 = _memoized2).unmemoize.apply(_memoized4, values); // Unsubscribe from provider\n\n              subscriptionPromise.then(function (subscriptionId) {\n                return isNull(subscriptionId) ? Promise.resolve(false) : _this7.provider.unsubscribe(subType, unsubName, subscriptionId);\n              }).catch(function (error) {\n                return logErrorMessage(method, def, error);\n              });\n            };\n          }).pipe(drr());\n        };\n      };\n\n      memoized = this._memomize(creator, def);\n      return memoized;\n    }\n  }, {\n    key: \"_formatInputs\",\n    value: function _formatInputs(registry, blockHash, def, inputs) {\n      var reqArgCount = def.params.filter(function (_ref15) {\n        var isOptional = _ref15.isOptional;\n        return !isOptional;\n      }).length;\n      var optText = reqArgCount === def.params.length ? '' : \" (\".concat(def.params.length - reqArgCount, \" optional)\");\n      assert(inputs.length >= reqArgCount && inputs.length <= def.params.length, function () {\n        return \"Expected \".concat(def.params.length, \" parameters\").concat(optText, \", \").concat(inputs.length, \" found instead\");\n      });\n      return inputs.map(function (input, index) {\n        return registry.createTypeUnsafe(def.params[index].type, [input], {\n          blockHash: blockHash\n        });\n      });\n    }\n  }, {\n    key: \"_formatOutput\",\n    value: function _formatOutput(registry, blockHash, method, rpc, params, result) {\n      var _this8 = this;\n\n      if (rpc.type === 'StorageData') {\n        var key = params[0];\n        return this._formatStorageData(registry, blockHash, key, result);\n      } else if (rpc.type === 'StorageChangeSet') {\n        var keys = params[0];\n        return keys ? this._formatStorageSet(registry, result.block, keys, result.changes) : registry.createType('StorageChangeSet', result);\n      } else if (rpc.type === 'Vec<StorageChangeSet>') {\n        var mapped = result.map(function (_ref16) {\n          var block = _ref16.block,\n              changes = _ref16.changes;\n          return [registry.createType('Hash', block), _this8._formatStorageSet(registry, block, params[0], changes)];\n        }); // we only query at a specific block, not a range - flatten\n\n        return method === 'queryStorageAt' ? mapped[0][1] : mapped;\n      }\n\n      return registry.createTypeUnsafe(rpc.type, [result], {\n        blockHash: blockHash\n      });\n    }\n  }, {\n    key: \"_formatStorageData\",\n    value: function _formatStorageData(registry, blockHash, key, value) {\n      var isEmpty = isNull(value); // we convert to Uint8Array since it maps to the raw encoding, all\n      // data will be correctly encoded (incl. numbers, excl. :code)\n\n      var input = isEmpty ? null : isTreatAsHex(key) ? value : u8aToU8a(value);\n      return this._newType(registry, blockHash, key, input, isEmpty);\n    }\n  }, {\n    key: \"_formatStorageSet\",\n    value: function _formatStorageSet(registry, blockHash, keys, changes) {\n      var _this9 = this;\n\n      // For StorageChangeSet, the changes has the [key, value] mappings\n      var withCache = keys.length !== 1; // multiple return values (via state.storage subscription), decode the values\n      // one at a time, all based on the query types. Three values can be returned -\n      //   - Codec - There is a valid value, non-empty\n      //   - null - The storage key is empty\n\n      return keys.reduce(function (results, key, index) {\n        results.push(_this9._formatStorageSetEntry(registry, blockHash, key, changes, withCache, index));\n        return results;\n      }, []);\n    }\n  }, {\n    key: \"_formatStorageSetEntry\",\n    value: function _formatStorageSetEntry(registry, blockHash, key, changes, witCache, entryIndex) {\n      var hexKey = key.toHex();\n      var found = changes.find(function (_ref17) {\n        var _ref18 = _slicedToArray(_ref17, 1),\n            key = _ref18[0];\n\n        return key === hexKey;\n      }); // if we don't find the value, this is our fallback\n      //   - in the case of an array of values, fill the hole from the cache\n      //   - if a single result value, don't fill - it is not an update hole\n      //   - fallback to an empty option in all cases\n\n      var value = isUndefined(found) ? witCache && _classPrivateFieldLooseBase(this, _storageCache)[_storageCache].get(hexKey) || null : found[1];\n      var isEmpty = isNull(value);\n      var input = isEmpty || isTreatAsHex(key) ? value : u8aToU8a(value); // store the retrieved result - the only issue with this cache is that there is no\n      // clearing of it, so very long running processes (not just a couple of hours, longer)\n      // will increase memory beyond what is allowed.\n\n      _classPrivateFieldLooseBase(this, _storageCache)[_storageCache].set(hexKey, value);\n\n      return this._newType(registry, blockHash, key, input, isEmpty, entryIndex);\n    }\n  }, {\n    key: \"_newType\",\n    value: function _newType(registry, blockHash, key, input, isEmpty) {\n      var entryIndex = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : -1;\n      // single return value (via state.getStorage), decode the value based on the\n      // outputType that we have specified. Fallback to Raw on nothing\n      var type = key.outputType || 'Raw';\n      var meta = key.meta || EMPTY_META;\n      var entryNum = entryIndex === -1 ? '' : \" entry \".concat(entryIndex, \":\");\n\n      try {\n        return registry.createTypeUnsafe(type, [isEmpty ? meta.fallback ? hexToU8a(meta.fallback.toHex()) : undefined : meta.modifier.isOptional ? registry.createTypeUnsafe(type, [input], {\n          blockHash: blockHash,\n          isPedantic: true\n        }) : input], {\n          blockHash: blockHash,\n          isOptional: meta.modifier.isOptional,\n          isPedantic: !meta.modifier.isOptional\n        });\n      } catch (error) {\n        throw new Error(\"Unable to decode storage \".concat(key.section || 'unknown', \".\").concat(key.method || 'unknown', \":\").concat(entryNum, \": \").concat(error.message));\n      }\n    }\n  }]);\n\n  return RpcCore;\n}();","map":{"version":3,"sources":["/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/@polkadot/rpc-core/bundle.js"],"names":["_defineProperty","_classPrivateFieldLooseBase","_classPrivateFieldLooseKey","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","Observable","publishReplay","refCount","rpcDefinitions","assert","hexToU8a","isFunction","isNull","isUndefined","logger","memoize","u8aToU8a","drr","refCountDelay","packageInfo","l","EMPTY_META","fallback","undefined","modifier","isOptional","type","asMap","linked","isTrue","isMap","logErrorMessage","method","error","params","inputs","map","name","join","message","isTreatAsHex","includes","toHex","_instanceId","_registryDefault","_getBlockRegistry","_storageCache","RpcCore","instanceId","registry","provider","userRpc","writable","value","Map","mapping","sections","send","sectionNames","addUserInterfaces","isConnected","connect","disconnect","registrySwap","getInstanceId","sectionName","_ref","_ref2","section","entries","_createInterface","methods","endpoint","has","reduce","exposed","def","isSubscription","pubsub","jsonrpc","set","_createMethodSubscribe","_createMethodSend","creator","memoized","json","raw","meta","rpcName","hashIndex","findIndex","isHistoric","callWithRegistry","outputAs","values","blockHash","_formatInputs","param","toJSON","data","_formatOutput","createType","isDelayed","observer","then","next","complete","catch","_memoized","unmemoize","pipe","_memomize","errorHandler","paramsJson","subName","subType","update","Promise","resolve","reject","subscribe","updateType","subMethod","unsubMethod","unsubName","subscriptionPromise","result","_createSubscriber","_memoized2","subscriptionId","unsubscribe","reqArgCount","optText","input","index","createTypeUnsafe","rpc","_formatStorageData","_formatStorageSet","block","changes","mapped","isEmpty","_newType","withCache","results","_formatStorageSetEntry","witCache","entryIndex","hexKey","found","find","get","outputType","entryNum","isPedantic","Error"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/rpc-core authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { Observable, publishReplay, refCount } from 'rxjs';\nimport { rpcDefinitions } from '@polkadot/types';\nimport { assert, hexToU8a, isFunction, isNull, isUndefined, logger, memoize, u8aToU8a } from '@polkadot/util';\nimport { drr, refCountDelay } from \"./util/index.js\";\nexport { packageInfo } from \"./packageInfo.js\";\nexport * from \"./util/index.js\";\nconst l = logger('rpc-core');\nconst EMPTY_META = {\n  fallback: undefined,\n  modifier: {\n    isOptional: true\n  },\n  type: {\n    asMap: {\n      linked: {\n        isTrue: false\n      }\n    },\n    isMap: false\n  }\n}; // utility method to create a nicely-formatted error\n\n/** @internal */\n\nfunction logErrorMessage(method, {\n  params,\n  type\n}, error) {\n  const inputs = params.map(({\n    isOptional,\n    name,\n    type\n  }) => `${name}${isOptional ? '?' : ''}: ${type}`).join(', ');\n  l.error(`${method}(${inputs}): ${type}:: ${error.message}`);\n}\n\nfunction isTreatAsHex(key) {\n  // :code is problematic - it does not have the length attached, which is\n  // unlike all other storage entries where it is indeed properly encoded\n  return ['0x3a636f6465'].includes(key.toHex());\n}\n/**\n * @name Rpc\n * @summary The API may use a HTTP or WebSockets provider.\n * @description It allows for querying a Polkadot Client Node.\n * WebSockets provider is recommended since HTTP provider only supports basic querying.\n *\n * ```mermaid\n * graph LR;\n *   A[Api] --> |WebSockets| B[WsProvider];\n *   B --> |endpoint| C[ws://127.0.0.1:9944]\n * ```\n *\n * @example\n * <BR>\n *\n * ```javascript\n * import Rpc from '@polkadot/rpc-core';\n * import { WsProvider } from '@polkadot/rpc-provider/ws';\n *\n * const provider = new WsProvider('ws://127.0.0.1:9944');\n * const rpc = new Rpc(provider);\n * ```\n */\n\n\nvar _instanceId = /*#__PURE__*/_classPrivateFieldLooseKey(\"instanceId\");\n\nvar _registryDefault = /*#__PURE__*/_classPrivateFieldLooseKey(\"registryDefault\");\n\nvar _getBlockRegistry = /*#__PURE__*/_classPrivateFieldLooseKey(\"getBlockRegistry\");\n\nvar _storageCache = /*#__PURE__*/_classPrivateFieldLooseKey(\"storageCache\");\n\nexport class RpcCore {\n  /**\n   * @constructor\n   * Default constructor for the Api Object\n   * @param  {ProviderInterface} provider An API provider using HTTP or WebSocket\n   */\n  constructor(instanceId, registry, provider, userRpc = {}) {\n    Object.defineProperty(this, _instanceId, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _registryDefault, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _getBlockRegistry, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _storageCache, {\n      writable: true,\n      value: new Map()\n    });\n    this.mapping = new Map();\n    this.provider = void 0;\n    this.sections = [];\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    assert(provider && isFunction(provider.send), 'Expected Provider to API create');\n    _classPrivateFieldLooseBase(this, _instanceId)[_instanceId] = instanceId;\n    _classPrivateFieldLooseBase(this, _registryDefault)[_registryDefault] = registry;\n    this.provider = provider;\n    const sectionNames = Object.keys(rpcDefinitions); // these are the base keys (i.e. part of jsonrpc)\n\n    this.sections.push(...sectionNames); // decorate all interfaces, defined and user on this instance\n\n    this.addUserInterfaces(userRpc);\n  }\n  /**\n   * @description Returns the connected status of a provider\n   */\n\n\n  get isConnected() {\n    return this.provider.isConnected;\n  }\n  /**\n   * @description Manually connect from the attached provider\n   */\n\n\n  connect() {\n    return this.provider.connect();\n  }\n  /**\n   * @description Manually disconnect from the attached provider\n   */\n\n\n  disconnect() {\n    return this.provider.disconnect();\n  }\n  /**\n   * @description Sets a registry swap (typically from Api)\n   */\n\n\n  setRegistrySwap(registrySwap) {\n    _classPrivateFieldLooseBase(this, _getBlockRegistry)[_getBlockRegistry] = memoize(registrySwap, {\n      getInstanceId: () => _classPrivateFieldLooseBase(this, _instanceId)[_instanceId]\n    });\n  }\n\n  addUserInterfaces(userRpc) {\n    // add any extra user-defined sections\n    this.sections.push(...Object.keys(userRpc).filter(key => !this.sections.includes(key))); // decorate the sections with base and user methods\n\n    this.sections.forEach(sectionName => {\n      var _ref, _ref2;\n\n      (_ref = this)[_ref2 = sectionName] || (_ref[_ref2] = {});\n      const section = this[sectionName];\n      Object.entries(_objectSpread(_objectSpread({}, this._createInterface(sectionName, rpcDefinitions[sectionName] || {})), this._createInterface(sectionName, userRpc[sectionName] || {}))).forEach(([key, value]) => {\n        section[key] || (section[key] = value);\n      });\n    });\n  }\n\n  _createInterface(section, methods) {\n    return Object.entries(methods).filter(([method, {\n      endpoint\n    }]) => !this.mapping.has(endpoint || `${section}_${method}`)).reduce((exposed, [method, {\n      endpoint\n    }]) => {\n      const def = methods[method];\n      const isSubscription = !!def.pubsub;\n      const jsonrpc = endpoint || `${section}_${method}`;\n      this.mapping.set(jsonrpc, _objectSpread(_objectSpread({}, def), {}, {\n        isSubscription,\n        jsonrpc,\n        method,\n        section\n      }));\n      exposed[method] = isSubscription ? this._createMethodSubscribe(section, method, def) : this._createMethodSend(section, method, def);\n      return exposed;\n    }, {});\n  }\n\n  _memomize(creator, def) {\n    const memoized = memoize(creator('scale'), {\n      getInstanceId: () => _classPrivateFieldLooseBase(this, _instanceId)[_instanceId]\n    });\n    memoized.json = creator('json');\n    memoized.raw = creator('raw');\n    memoized.meta = def;\n    return memoized;\n  }\n\n  _createMethodSend(section, method, def) {\n    const rpcName = def.endpoint || `${section}_${method}`;\n    const hashIndex = def.params.findIndex(({\n      isHistoric\n    }) => isHistoric);\n    let memoized = null; // execute the RPC call, doing a registry swap for historic as applicable\n\n    const callWithRegistry = async (outputAs, values) => {\n      const blockHash = hashIndex === -1 ? null : values[hashIndex];\n      const {\n        registry\n      } = outputAs === 'scale' && blockHash && _classPrivateFieldLooseBase(this, _getBlockRegistry)[_getBlockRegistry] ? await _classPrivateFieldLooseBase(this, _getBlockRegistry)[_getBlockRegistry](u8aToU8a(blockHash)) : {\n        registry: _classPrivateFieldLooseBase(this, _registryDefault)[_registryDefault]\n      };\n\n      const params = this._formatInputs(registry, null, def, values);\n\n      const data = await this.provider.send(rpcName, params.map(param => param.toJSON()));\n      return outputAs === 'scale' ? this._formatOutput(registry, blockHash, method, def, params, data) : registry.createType(outputAs === 'raw' ? 'Raw' : 'Json', data);\n    };\n\n    const creator = outputAs => (...values) => {\n      const isDelayed = outputAs === 'scale' && hashIndex !== -1 && !!values[hashIndex];\n      return new Observable(observer => {\n        callWithRegistry(outputAs, values).then(value => {\n          observer.next(value);\n          observer.complete();\n        }).catch(error => {\n          logErrorMessage(method, def, error);\n          observer.error(error);\n          observer.complete();\n        });\n        return () => {\n          var _memoized;\n\n          // delete old results from cache\n          (_memoized = memoized) === null || _memoized === void 0 ? void 0 : _memoized.unmemoize(...values);\n        };\n      }).pipe(publishReplay(1), // create a Replay(1)\n      isDelayed ? refCountDelay() // Unsubscribe after delay\n      : refCount());\n    };\n\n    memoized = this._memomize(creator, def);\n    return memoized;\n  } // create a subscriptor, it subscribes once and resolves with the id as subscribe\n\n\n  _createSubscriber({\n    paramsJson,\n    subName,\n    subType,\n    update\n  }, errorHandler) {\n    return new Promise((resolve, reject) => {\n      this.provider.subscribe(subType, subName, paramsJson, update).then(resolve).catch(error => {\n        errorHandler(error);\n        reject(error);\n      });\n    });\n  }\n\n  _createMethodSubscribe(section, method, def) {\n    const [updateType, subMethod, unsubMethod] = def.pubsub;\n    const subName = `${section}_${subMethod}`;\n    const unsubName = `${section}_${unsubMethod}`;\n    const subType = `${section}_${updateType}`;\n    let memoized = null;\n\n    const creator = outputAs => (...values) => {\n      return new Observable(observer => {\n        // Have at least an empty promise, as used in the unsubscribe\n        let subscriptionPromise = Promise.resolve(null);\n\n        const registry = _classPrivateFieldLooseBase(this, _registryDefault)[_registryDefault];\n\n        const errorHandler = error => {\n          logErrorMessage(method, def, error);\n          observer.error(error);\n        };\n\n        try {\n          const params = this._formatInputs(registry, null, def, values);\n\n          const paramsJson = params.map(param => param.toJSON());\n\n          const update = (error, result) => {\n            if (error) {\n              logErrorMessage(method, def, error);\n              return;\n            }\n\n            try {\n              observer.next(outputAs === 'scale' ? this._formatOutput(registry, null, method, def, params, result) : registry.createType(outputAs === 'raw' ? 'Raw' : 'Json', result));\n            } catch (error) {\n              observer.error(error);\n            }\n          };\n\n          subscriptionPromise = this._createSubscriber({\n            paramsJson,\n            subName,\n            subType,\n            update\n          }, errorHandler);\n        } catch (error) {\n          errorHandler(error);\n        } // Teardown logic\n\n\n        return () => {\n          var _memoized2;\n\n          // Delete from cache, so old results don't hang around\n          (_memoized2 = memoized) === null || _memoized2 === void 0 ? void 0 : _memoized2.unmemoize(...values); // Unsubscribe from provider\n\n          subscriptionPromise.then(subscriptionId => isNull(subscriptionId) ? Promise.resolve(false) : this.provider.unsubscribe(subType, unsubName, subscriptionId)).catch(error => logErrorMessage(method, def, error));\n        };\n      }).pipe(drr());\n    };\n\n    memoized = this._memomize(creator, def);\n    return memoized;\n  }\n\n  _formatInputs(registry, blockHash, def, inputs) {\n    const reqArgCount = def.params.filter(({\n      isOptional\n    }) => !isOptional).length;\n    const optText = reqArgCount === def.params.length ? '' : ` (${def.params.length - reqArgCount} optional)`;\n    assert(inputs.length >= reqArgCount && inputs.length <= def.params.length, () => `Expected ${def.params.length} parameters${optText}, ${inputs.length} found instead`);\n    return inputs.map((input, index) => registry.createTypeUnsafe(def.params[index].type, [input], {\n      blockHash\n    }));\n  }\n\n  _formatOutput(registry, blockHash, method, rpc, params, result) {\n    if (rpc.type === 'StorageData') {\n      const key = params[0];\n      return this._formatStorageData(registry, blockHash, key, result);\n    } else if (rpc.type === 'StorageChangeSet') {\n      const keys = params[0];\n      return keys ? this._formatStorageSet(registry, result.block, keys, result.changes) : registry.createType('StorageChangeSet', result);\n    } else if (rpc.type === 'Vec<StorageChangeSet>') {\n      const mapped = result.map(({\n        block,\n        changes\n      }) => [registry.createType('Hash', block), this._formatStorageSet(registry, block, params[0], changes)]); // we only query at a specific block, not a range - flatten\n\n      return method === 'queryStorageAt' ? mapped[0][1] : mapped;\n    }\n\n    return registry.createTypeUnsafe(rpc.type, [result], {\n      blockHash\n    });\n  }\n\n  _formatStorageData(registry, blockHash, key, value) {\n    const isEmpty = isNull(value); // we convert to Uint8Array since it maps to the raw encoding, all\n    // data will be correctly encoded (incl. numbers, excl. :code)\n\n    const input = isEmpty ? null : isTreatAsHex(key) ? value : u8aToU8a(value);\n    return this._newType(registry, blockHash, key, input, isEmpty);\n  }\n\n  _formatStorageSet(registry, blockHash, keys, changes) {\n    // For StorageChangeSet, the changes has the [key, value] mappings\n    const withCache = keys.length !== 1; // multiple return values (via state.storage subscription), decode the values\n    // one at a time, all based on the query types. Three values can be returned -\n    //   - Codec - There is a valid value, non-empty\n    //   - null - The storage key is empty\n\n    return keys.reduce((results, key, index) => {\n      results.push(this._formatStorageSetEntry(registry, blockHash, key, changes, withCache, index));\n      return results;\n    }, []);\n  }\n\n  _formatStorageSetEntry(registry, blockHash, key, changes, witCache, entryIndex) {\n    const hexKey = key.toHex();\n    const found = changes.find(([key]) => key === hexKey); // if we don't find the value, this is our fallback\n    //   - in the case of an array of values, fill the hole from the cache\n    //   - if a single result value, don't fill - it is not an update hole\n    //   - fallback to an empty option in all cases\n\n    const value = isUndefined(found) ? witCache && _classPrivateFieldLooseBase(this, _storageCache)[_storageCache].get(hexKey) || null : found[1];\n    const isEmpty = isNull(value);\n    const input = isEmpty || isTreatAsHex(key) ? value : u8aToU8a(value); // store the retrieved result - the only issue with this cache is that there is no\n    // clearing of it, so very long running processes (not just a couple of hours, longer)\n    // will increase memory beyond what is allowed.\n\n    _classPrivateFieldLooseBase(this, _storageCache)[_storageCache].set(hexKey, value);\n\n    return this._newType(registry, blockHash, key, input, isEmpty, entryIndex);\n  }\n\n  _newType(registry, blockHash, key, input, isEmpty, entryIndex = -1) {\n    // single return value (via state.getStorage), decode the value based on the\n    // outputType that we have specified. Fallback to Raw on nothing\n    const type = key.outputType || 'Raw';\n    const meta = key.meta || EMPTY_META;\n    const entryNum = entryIndex === -1 ? '' : ` entry ${entryIndex}:`;\n\n    try {\n      return registry.createTypeUnsafe(type, [isEmpty ? meta.fallback ? hexToU8a(meta.fallback.toHex()) : undefined : meta.modifier.isOptional ? registry.createTypeUnsafe(type, [input], {\n        blockHash,\n        isPedantic: true\n      }) : input], {\n        blockHash,\n        isOptional: meta.modifier.isOptional,\n        isPedantic: !meta.modifier.isOptional\n      });\n    } catch (error) {\n      throw new Error(`Unable to decode storage ${key.section || 'unknown'}.${key.method || 'unknown'}:${entryNum}: ${error.message}`);\n    }\n  }\n\n}"]},"metadata":{},"sourceType":"module"}