{"ast":null,"code":"import _slicedToArray from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n// Copyright 2017-2021 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n// Original implementation: https://github.com/paritytech/polka-ui/blob/4858c094684769080f5811f32b081dd7780b0880/src/polkadot.js#L6\nimport { assert, isHex, isU8a, u8aToU8a } from '@polkadot/util';\nimport { base58Decode } from \"../base58/decode.js\";\nimport { checkAddressChecksum } from \"./checksum.js\";\nimport { defaults } from \"./defaults.js\";\nexport function decodeAddress(encoded, ignoreChecksum) {\n  var ss58Format = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n  assert(encoded, 'Invalid empty address passed');\n\n  if (isU8a(encoded) || isHex(encoded)) {\n    return u8aToU8a(encoded);\n  }\n\n  try {\n    var decoded = base58Decode(encoded);\n    assert(defaults.allowedEncodedLengths.includes(decoded.length), 'Invalid decoded address length');\n\n    var _checkAddressChecksum = checkAddressChecksum(decoded),\n        _checkAddressChecksum2 = _slicedToArray(_checkAddressChecksum, 4),\n        isValid = _checkAddressChecksum2[0],\n        endPos = _checkAddressChecksum2[1],\n        ss58Length = _checkAddressChecksum2[2],\n        ss58Decoded = _checkAddressChecksum2[3];\n\n    assert(ignoreChecksum || isValid, 'Invalid decoded address checksum');\n    assert([-1, ss58Decoded].includes(ss58Format), function () {\n      return \"Expected ss58Format \".concat(ss58Format, \", received \").concat(ss58Decoded);\n    });\n    return decoded.slice(ss58Length, endPos);\n  } catch (error) {\n    throw new Error(\"Decoding \".concat(encoded, \": \").concat(error.message));\n  }\n}","map":{"version":3,"sources":["/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/@polkadot/util-crypto/address/decode.js"],"names":["assert","isHex","isU8a","u8aToU8a","base58Decode","checkAddressChecksum","defaults","decodeAddress","encoded","ignoreChecksum","ss58Format","decoded","allowedEncodedLengths","includes","length","isValid","endPos","ss58Length","ss58Decoded","slice","error","Error","message"],"mappings":";AAAA;AACA;AACA;AACA,SAASA,MAAT,EAAiBC,KAAjB,EAAwBC,KAAxB,EAA+BC,QAA/B,QAA+C,gBAA/C;AACA,SAASC,YAAT,QAA6B,qBAA7B;AACA,SAASC,oBAAT,QAAqC,eAArC;AACA,SAASC,QAAT,QAAyB,eAAzB;AACA,OAAO,SAASC,aAAT,CAAuBC,OAAvB,EAAgCC,cAAhC,EAAiE;AAAA,MAAjBC,UAAiB,uEAAJ,CAAC,CAAG;AACtEV,EAAAA,MAAM,CAACQ,OAAD,EAAU,8BAAV,CAAN;;AAEA,MAAIN,KAAK,CAACM,OAAD,CAAL,IAAkBP,KAAK,CAACO,OAAD,CAA3B,EAAsC;AACpC,WAAOL,QAAQ,CAACK,OAAD,CAAf;AACD;;AAED,MAAI;AACF,QAAMG,OAAO,GAAGP,YAAY,CAACI,OAAD,CAA5B;AACAR,IAAAA,MAAM,CAACM,QAAQ,CAACM,qBAAT,CAA+BC,QAA/B,CAAwCF,OAAO,CAACG,MAAhD,CAAD,EAA0D,gCAA1D,CAAN;;AACA,gCAAmDT,oBAAoB,CAACM,OAAD,CAAvE;AAAA;AAAA,QAAOI,OAAP;AAAA,QAAgBC,MAAhB;AAAA,QAAwBC,UAAxB;AAAA,QAAoCC,WAApC;;AACAlB,IAAAA,MAAM,CAACS,cAAc,IAAIM,OAAnB,EAA4B,kCAA5B,CAAN;AACAf,IAAAA,MAAM,CAAC,CAAC,CAAC,CAAF,EAAKkB,WAAL,EAAkBL,QAAlB,CAA2BH,UAA3B,CAAD,EAAyC;AAAA,2CAA6BA,UAA7B,wBAAqDQ,WAArD;AAAA,KAAzC,CAAN;AACA,WAAOP,OAAO,CAACQ,KAAR,CAAcF,UAAd,EAA0BD,MAA1B,CAAP;AACD,GAPD,CAOE,OAAOI,KAAP,EAAc;AACd,UAAM,IAAIC,KAAJ,oBAAsBb,OAAtB,eAAkCY,KAAK,CAACE,OAAxC,EAAN;AACD;AACF","sourcesContent":["// Copyright 2017-2021 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n// Original implementation: https://github.com/paritytech/polka-ui/blob/4858c094684769080f5811f32b081dd7780b0880/src/polkadot.js#L6\nimport { assert, isHex, isU8a, u8aToU8a } from '@polkadot/util';\nimport { base58Decode } from \"../base58/decode.js\";\nimport { checkAddressChecksum } from \"./checksum.js\";\nimport { defaults } from \"./defaults.js\";\nexport function decodeAddress(encoded, ignoreChecksum, ss58Format = -1) {\n  assert(encoded, 'Invalid empty address passed');\n\n  if (isU8a(encoded) || isHex(encoded)) {\n    return u8aToU8a(encoded);\n  }\n\n  try {\n    const decoded = base58Decode(encoded);\n    assert(defaults.allowedEncodedLengths.includes(decoded.length), 'Invalid decoded address length');\n    const [isValid, endPos, ss58Length, ss58Decoded] = checkAddressChecksum(decoded);\n    assert(ignoreChecksum || isValid, 'Invalid decoded address checksum');\n    assert([-1, ss58Decoded].includes(ss58Format), () => `Expected ss58Format ${ss58Format}, received ${ss58Decoded}`);\n    return decoded.slice(ss58Length, endPos);\n  } catch (error) {\n    throw new Error(`Decoding ${encoded}: ${error.message}`);\n  }\n}"]},"metadata":{},"sourceType":"module"}