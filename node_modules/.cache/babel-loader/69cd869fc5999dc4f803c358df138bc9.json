{"ast":null,"code":"// Copyright 2017-2021 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n// Original implementation: https://github.com/paritytech/polka-ui/blob/4858c094684769080f5811f32b081dd7780b0880/src/polkadot.js#L34\nimport { assert, u8aConcat } from '@polkadot/util';\nimport { base58Encode } from \"../base58/encode.js\";\nimport { decodeAddress } from \"./decode.js\";\nimport { defaults } from \"./defaults.js\";\nimport { sshash } from \"./sshash.js\";\nexport function encodeAddress(key) {\n  var ss58Format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaults.prefix;\n  // decode it, this means we can re-encode an address\n  var u8a = decodeAddress(key);\n  assert(ss58Format >= 0 && ss58Format <= 16383 && ![46, 47].includes(ss58Format), 'Out of range ss58Format specified');\n  assert(defaults.allowedDecodedLengths.includes(u8a.length), function () {\n    return \"Expected a valid key to convert, with length \".concat(defaults.allowedDecodedLengths.join(', '));\n  });\n  var input = u8aConcat(ss58Format < 64 ? [ss58Format] : [(ss58Format & 252) >> 2 | 64, ss58Format >> 8 | (ss58Format & 3) << 6], u8a);\n  return base58Encode(u8aConcat(input, sshash(input).subarray(0, [32, 33].includes(u8a.length) ? 2 : 1)));\n}","map":{"version":3,"sources":["/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/@polkadot/util-crypto/address/encode.js"],"names":["assert","u8aConcat","base58Encode","decodeAddress","defaults","sshash","encodeAddress","key","ss58Format","prefix","u8a","includes","allowedDecodedLengths","length","join","input","subarray"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,MAAT,EAAiBC,SAAjB,QAAkC,gBAAlC;AACA,SAASC,YAAT,QAA6B,qBAA7B;AACA,SAASC,aAAT,QAA8B,aAA9B;AACA,SAASC,QAAT,QAAyB,eAAzB;AACA,SAASC,MAAT,QAAuB,aAAvB;AACA,OAAO,SAASC,aAAT,CAAuBC,GAAvB,EAA0D;AAAA,MAA9BC,UAA8B,uEAAjBJ,QAAQ,CAACK,MAAQ;AAC/D;AACA,MAAMC,GAAG,GAAGP,aAAa,CAACI,GAAD,CAAzB;AACAP,EAAAA,MAAM,CAACQ,UAAU,IAAI,CAAd,IAAmBA,UAAU,IAAI,KAAjC,IAA0C,CAAC,CAAC,EAAD,EAAK,EAAL,EAASG,QAAT,CAAkBH,UAAlB,CAA5C,EAA2E,mCAA3E,CAAN;AACAR,EAAAA,MAAM,CAACI,QAAQ,CAACQ,qBAAT,CAA+BD,QAA/B,CAAwCD,GAAG,CAACG,MAA5C,CAAD,EAAsD;AAAA,kEAAsDT,QAAQ,CAACQ,qBAAT,CAA+BE,IAA/B,CAAoC,IAApC,CAAtD;AAAA,GAAtD,CAAN;AACA,MAAMC,KAAK,GAAGd,SAAS,CAACO,UAAU,GAAG,EAAb,GAAkB,CAACA,UAAD,CAAlB,GAAiC,CAAC,CAACA,UAAU,GAAG,GAAd,KAAqC,CAArC,GAAyC,EAA1C,EAAsDA,UAAU,IAAI,CAAd,GAAkB,CAACA,UAAU,GAAG,CAAd,KAAqC,CAA7G,CAAlC,EAAmJE,GAAnJ,CAAvB;AACA,SAAOR,YAAY,CAACD,SAAS,CAACc,KAAD,EAAQV,MAAM,CAACU,KAAD,CAAN,CAAcC,QAAd,CAAuB,CAAvB,EAA0B,CAAC,EAAD,EAAK,EAAL,EAASL,QAAT,CAAkBD,GAAG,CAACG,MAAtB,IAAgC,CAAhC,GAAoC,CAA9D,CAAR,CAAV,CAAnB;AACD","sourcesContent":["// Copyright 2017-2021 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n// Original implementation: https://github.com/paritytech/polka-ui/blob/4858c094684769080f5811f32b081dd7780b0880/src/polkadot.js#L34\nimport { assert, u8aConcat } from '@polkadot/util';\nimport { base58Encode } from \"../base58/encode.js\";\nimport { decodeAddress } from \"./decode.js\";\nimport { defaults } from \"./defaults.js\";\nimport { sshash } from \"./sshash.js\";\nexport function encodeAddress(key, ss58Format = defaults.prefix) {\n  // decode it, this means we can re-encode an address\n  const u8a = decodeAddress(key);\n  assert(ss58Format >= 0 && ss58Format <= 16383 && ![46, 47].includes(ss58Format), 'Out of range ss58Format specified');\n  assert(defaults.allowedDecodedLengths.includes(u8a.length), () => `Expected a valid key to convert, with length ${defaults.allowedDecodedLengths.join(', ')}`);\n  const input = u8aConcat(ss58Format < 64 ? [ss58Format] : [(ss58Format & 0b0000000011111100) >> 2 | 0b01000000, ss58Format >> 8 | (ss58Format & 0b0000000000000011) << 6], u8a);\n  return base58Encode(u8aConcat(input, sshash(input).subarray(0, [32, 33].includes(u8a.length) ? 2 : 1)));\n}"]},"metadata":{},"sourceType":"module"}