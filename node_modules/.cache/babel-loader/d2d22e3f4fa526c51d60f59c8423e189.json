{"ast":null,"code":"import _classCallCheck from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\"; // Copyright 2017-2021 @polkadot/keyring authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\nimport { assert, hexToU8a, isHex, isUndefined, stringToU8a } from '@polkadot/util';\nimport { base64Decode, decodeAddress, encodeAddress, ethereumEncode, hdEthereum, keyExtractSuri, keyFromPath, mnemonicToLegacySeed, mnemonicToMiniSecret, naclKeypairFromSeed as naclFromSeed, schnorrkelKeypairFromSeed as schnorrkelFromSeed, secp256k1KeypairFromSeed as secp256k1FromSeed } from '@polkadot/util-crypto';\nimport { DEV_PHRASE } from \"./defaults.js\";\nimport { createPair } from \"./pair/index.js\";\nimport { Pairs } from \"./pairs.js\";\nvar keypairFromSeed = {\n  ecdsa: function ecdsa(seed) {\n    return secp256k1FromSeed(seed);\n  },\n  ed25519: function ed25519(seed) {\n    return naclFromSeed(seed);\n  },\n  ethereum: function ethereum(seed) {\n    return secp256k1FromSeed(seed);\n  },\n  sr25519: function sr25519(seed) {\n    return schnorrkelFromSeed(seed);\n  }\n};\n/**\n * # @polkadot/keyring\n *\n * ## Overview\n *\n * @name Keyring\n * @summary Keyring management of user accounts\n * @description Allows generation of keyring pairs from a variety of input combinations, such as\n * json object containing account address or public key, account metadata, and account encoded using\n * `addFromJson`, or by providing those values as arguments separately to `addFromAddress`,\n * or by providing the mnemonic (seed phrase) and account metadata as arguments to `addFromMnemonic`.\n * Stores the keyring pairs in a keyring pair dictionary. Removal of the keyring pairs from the keyring pair\n * dictionary is achieved using `removePair`. Retrieval of all the stored pairs via `getPairs` or perform\n * lookup of a pair for a given account address or public key using `getPair`. JSON metadata associated with\n * an account may be obtained using `toJson` accompanied by the account passphrase.\n */\n\nvar _pairs = /*#__PURE__*/_classPrivateFieldLooseKey(\"pairs\");\n\nvar _type = /*#__PURE__*/_classPrivateFieldLooseKey(\"type\");\n\nvar _ss = /*#__PURE__*/_classPrivateFieldLooseKey(\"ss58\");\n\nexport var Keyring = /*#__PURE__*/function () {\n  function Keyring() {\n    var _this = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Keyring);\n\n    Object.defineProperty(this, _pairs, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _type, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _ss, {\n      writable: true,\n      value: void 0\n    });\n    this.decodeAddress = decodeAddress;\n\n    this.encodeAddress = function (address, ss58Format) {\n      return _this.type === 'ethereum' ? ethereumEncode(address) : encodeAddress(address, isUndefined(ss58Format) ? _classPrivateFieldLooseBase(_this, _ss)[_ss] : ss58Format);\n    };\n\n    options.type = options.type || 'ed25519';\n    assert(['ecdsa', 'ethereum', 'ed25519', 'sr25519'].includes(options.type || 'undefined'), function () {\n      return \"Expected a keyring type of either 'ed25519', 'sr25519', 'ethereum' or 'ecdsa', found '\".concat(options.type || 'unknown');\n    });\n    _classPrivateFieldLooseBase(this, _pairs)[_pairs] = new Pairs();\n    _classPrivateFieldLooseBase(this, _ss)[_ss] = options.ss58Format;\n    _classPrivateFieldLooseBase(this, _type)[_type] = options.type;\n  }\n  /**\n   * @description retrieve the pairs (alias for getPairs)\n   */\n\n\n  _createClass(Keyring, [{\n    key: \"pairs\",\n    get: function get() {\n      return this.getPairs();\n    }\n    /**\n     * @description retrieve the publicKeys (alias for getPublicKeys)\n     */\n\n  }, {\n    key: \"publicKeys\",\n    get: function get() {\n      return this.getPublicKeys();\n    }\n    /**\n     * @description Returns the type of the keyring, ed25519, sr25519 or ecdsa\n     */\n\n  }, {\n    key: \"type\",\n    get: function get() {\n      return _classPrivateFieldLooseBase(this, _type)[_type];\n    }\n    /**\n     * @name addPair\n     * @summary Stores an account, given a keyring pair, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n     */\n\n  }, {\n    key: \"addPair\",\n    value: function addPair(pair) {\n      return _classPrivateFieldLooseBase(this, _pairs)[_pairs].add(pair);\n    }\n    /**\n     * @name addFromAddress\n     * @summary Stores an account, given an account address, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n     * @description Allows user to explicitly provide separate inputs including account address or public key, and optionally\n     * the associated account metadata, and the default encoded value as arguments (that may be obtained from the json file\n     * of an account backup), and then generates a keyring pair from them that it passes to\n     * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n     */\n\n  }, {\n    key: \"addFromAddress\",\n    value: function addFromAddress(address) {\n      var meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var encoded = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.type;\n      var ignoreChecksum = arguments.length > 4 ? arguments[4] : undefined;\n      var encType = arguments.length > 5 ? arguments[5] : undefined;\n      var publicKey = this.decodeAddress(address, ignoreChecksum);\n      return this.addPair(createPair({\n        toSS58: this.encodeAddress,\n        type: type\n      }, {\n        publicKey: publicKey,\n        secretKey: new Uint8Array()\n      }, meta, encoded, encType));\n    }\n    /**\n     * @name addFromJson\n     * @summary Stores an account, given JSON data, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n     * @description Allows user to provide a json object argument that contains account information (that may be obtained from the json file\n     * of an account backup), and then generates a keyring pair from it that it passes to\n     * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n     */\n\n  }, {\n    key: \"addFromJson\",\n    value: function addFromJson(json, ignoreChecksum) {\n      return this.addPair(this.createFromJson(json, ignoreChecksum));\n    }\n    /**\n     * @name addFromMnemonic\n     * @summary Stores an account, given a mnemonic, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n     * @description Allows user to provide a mnemonic (seed phrase that is provided when account is originally created)\n     * argument and a metadata argument that contains account information (that may be obtained from the json file\n     * of an account backup), and then generates a keyring pair from it that it passes to\n     * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n     */\n\n  }, {\n    key: \"addFromMnemonic\",\n    value: function addFromMnemonic(mnemonic) {\n      var meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.type;\n      return this.addFromUri(mnemonic, meta, type);\n    }\n    /**\n     * @name addFromPair\n     * @summary Stores an account created from an explicit publicKey/secreteKey combination\n     */\n\n  }, {\n    key: \"addFromPair\",\n    value: function addFromPair(pair) {\n      var meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.type;\n      return this.addPair(this.createFromPair(pair, meta, type));\n    }\n    /**\n     * @name addFromSeed\n     * @summary Stores an account, given seed data, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n     * @description Stores in a keyring pair dictionary the public key of the pair as a key and the pair as the associated value.\n     * Allows user to provide the account seed as an argument, and then generates a keyring pair from it that it passes to\n     * `addPair` to store in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n     */\n\n  }, {\n    key: \"addFromSeed\",\n    value: function addFromSeed(seed) {\n      var meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.type;\n      return this.addPair(createPair({\n        toSS58: this.encodeAddress,\n        type: type\n      }, keypairFromSeed[type](seed), meta, null));\n    }\n    /**\n     * @name addFromUri\n     * @summary Creates an account via an suri\n     * @description Extracts the phrase, path and password from a SURI format for specifying secret keys `<secret>/<soft-key>//<hard-key>///<password>` (the `///password` may be omitted, and `/<soft-key>` and `//<hard-key>` maybe repeated and mixed). The secret can be a hex string, mnemonic phrase or a string (to be padded)\n     */\n\n  }, {\n    key: \"addFromUri\",\n    value: function addFromUri(suri) {\n      var meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.type;\n      return this.addPair(this.createFromUri(suri, meta, type));\n    }\n    /**\n     * @name createFromJson\n     * @description Creates a pair from a JSON keyfile\n     */\n\n  }, {\n    key: \"createFromJson\",\n    value: function createFromJson(_ref, ignoreChecksum) {\n      var address = _ref.address,\n          encoded = _ref.encoded,\n          _ref$encoding = _ref.encoding,\n          content = _ref$encoding.content,\n          type = _ref$encoding.type,\n          version = _ref$encoding.version,\n          meta = _ref.meta;\n      assert(version !== '3' || content[0] === 'pkcs8', function () {\n        return \"Unable to decode non-pkcs8 type, [\".concat(content.join(','), \"] found}\");\n      });\n      var cryptoType = version === '0' || !Array.isArray(content) ? this.type : content[1];\n      var encType = !Array.isArray(type) ? [type] : type;\n      assert(['ed25519', 'sr25519', 'ecdsa', 'ethereum'].includes(cryptoType), function () {\n        return \"Unknown crypto type \".concat(cryptoType);\n      }); // Here the address and publicKey are 32 bytes and isomorphic. This is why the address field needs to be the public key for ethereum type pairs\n\n      var publicKey = isHex(address) ? hexToU8a(address) : this.decodeAddress(address, ignoreChecksum);\n      var decoded = isHex(encoded) ? hexToU8a(encoded) : base64Decode(encoded);\n      return createPair({\n        toSS58: this.encodeAddress,\n        type: cryptoType\n      }, {\n        publicKey: publicKey,\n        secretKey: new Uint8Array()\n      }, meta, decoded, encType);\n    }\n    /**\n     * @name createFromPair\n     * @summary Creates a pair from an explicit publicKey/secreteKey combination\n     */\n\n  }, {\n    key: \"createFromPair\",\n    value: function createFromPair(pair) {\n      var meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.type;\n      return createPair({\n        toSS58: this.encodeAddress,\n        type: type\n      }, pair, meta, null);\n    }\n    /**\n     * @name createFromUri\n     * @summary Creates a Keypair from an suri\n     * @description This creates a pair from the suri, but does not add it to the keyring\n     */\n\n  }, {\n    key: \"createFromUri\",\n    value: function createFromUri(_suri) {\n      var meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.type;\n      // here we only aut-add the dev phrase if we have a hard-derived path\n      var suri = _suri.startsWith('//') ? \"\".concat(DEV_PHRASE).concat(_suri) : _suri;\n\n      var _keyExtractSuri = keyExtractSuri(suri),\n          derivePath = _keyExtractSuri.derivePath,\n          password = _keyExtractSuri.password,\n          path = _keyExtractSuri.path,\n          phrase = _keyExtractSuri.phrase;\n\n      var seed;\n      var isPhraseHex = isHex(phrase, 256);\n\n      if (isPhraseHex) {\n        seed = hexToU8a(phrase);\n      } else {\n        var str = phrase;\n        var parts = str.split(' ');\n\n        if ([12, 15, 18, 21, 24].includes(parts.length)) {\n          seed = type === 'ethereum' ? mnemonicToLegacySeed(phrase, '', false, 64) : mnemonicToMiniSecret(phrase, password);\n        } else {\n          assert(str.length <= 32, 'specified phrase is not a valid mnemonic and is invalid as a raw seed at > 32 bytes');\n          seed = stringToU8a(str.padEnd(32));\n        }\n      }\n\n      var derived = type === 'ethereum' ? isPhraseHex ? keypairFromSeed[type](seed) // for eth, if the private key is provided as suri, it must be derived only once\n      : hdEthereum(seed, derivePath.substring(1)) : keyFromPath(keypairFromSeed[type](seed), path, type);\n      return createPair({\n        toSS58: this.encodeAddress,\n        type: type\n      }, derived, meta, null);\n    }\n    /**\n     * @name encodeAddress\n     * @description Encodes the input into an ss58 representation\n     */\n\n    /**\n     * @name getPair\n     * @summary Retrieves an account keyring pair from the Keyring Pair Dictionary, given an account address\n     * @description Returns a keyring pair value from the keyring pair dictionary by performing\n     * a key lookup using the provided account address or public key (after decoding it).\n     */\n\n  }, {\n    key: \"getPair\",\n    value: function getPair(address) {\n      return _classPrivateFieldLooseBase(this, _pairs)[_pairs].get(address);\n    }\n    /**\n     * @name getPairs\n     * @summary Retrieves all account keyring pairs from the Keyring Pair Dictionary\n     * @description Returns an array list of all the keyring pair values that are stored in the keyring pair dictionary.\n     */\n\n  }, {\n    key: \"getPairs\",\n    value: function getPairs() {\n      return _classPrivateFieldLooseBase(this, _pairs)[_pairs].all();\n    }\n    /**\n     * @name getPublicKeys\n     * @summary Retrieves Public Keys of all Keyring Pairs stored in the Keyring Pair Dictionary\n     * @description Returns an array list of all the public keys associated with each of the keyring pair values that are stored in the keyring pair dictionary.\n     */\n\n  }, {\n    key: \"getPublicKeys\",\n    value: function getPublicKeys() {\n      return _classPrivateFieldLooseBase(this, _pairs)[_pairs].all().map(function (_ref2) {\n        var publicKey = _ref2.publicKey;\n        return publicKey;\n      });\n    }\n    /**\n     * @name removePair\n     * @description Deletes the provided input address or public key from the stored Keyring Pair Dictionary.\n     */\n\n  }, {\n    key: \"removePair\",\n    value: function removePair(address) {\n      _classPrivateFieldLooseBase(this, _pairs)[_pairs].remove(address);\n    }\n    /**\n     * @name setSS58Format;\n     * @description Sets the ss58 format for the keyring\n     */\n\n  }, {\n    key: \"setSS58Format\",\n    value: function setSS58Format(ss58) {\n      _classPrivateFieldLooseBase(this, _ss)[_ss] = ss58;\n    }\n    /**\n     * @name toJson\n     * @summary Returns a JSON object associated with the input argument that contains metadata assocated with an account\n     * @description Returns a JSON object containing the metadata associated with an account\n     * when valid address or public key and when the account passphrase is provided if the account secret\n     * is not already unlocked and available in memory. Note that in [Polkadot-JS Apps](https://github.com/polkadot-js/apps) the user\n     * may backup their account to a JSON file that contains this information.\n     */\n\n  }, {\n    key: \"toJson\",\n    value: function toJson(address, passphrase) {\n      return _classPrivateFieldLooseBase(this, _pairs)[_pairs].get(address).toJson(passphrase);\n    }\n  }]);\n\n  return Keyring;\n}();","map":{"version":3,"sources":["/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/@polkadot/keyring/keyring.js"],"names":["_classPrivateFieldLooseBase","_classPrivateFieldLooseKey","assert","hexToU8a","isHex","isUndefined","stringToU8a","base64Decode","decodeAddress","encodeAddress","ethereumEncode","hdEthereum","keyExtractSuri","keyFromPath","mnemonicToLegacySeed","mnemonicToMiniSecret","naclKeypairFromSeed","naclFromSeed","schnorrkelKeypairFromSeed","schnorrkelFromSeed","secp256k1KeypairFromSeed","secp256k1FromSeed","DEV_PHRASE","createPair","Pairs","keypairFromSeed","ecdsa","seed","ed25519","ethereum","sr25519","_pairs","_type","_ss","Keyring","options","Object","defineProperty","writable","value","address","ss58Format","type","includes","getPairs","getPublicKeys","pair","add","meta","encoded","ignoreChecksum","encType","publicKey","addPair","toSS58","secretKey","Uint8Array","json","createFromJson","mnemonic","addFromUri","createFromPair","suri","createFromUri","encoding","content","version","join","cryptoType","Array","isArray","decoded","_suri","startsWith","derivePath","password","path","phrase","isPhraseHex","str","parts","split","length","padEnd","derived","substring","get","all","map","remove","ss58","passphrase","toJson"],"mappings":"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","sourcesContent":["import _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n// Copyright 2017-2021 @polkadot/keyring authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, hexToU8a, isHex, isUndefined, stringToU8a } from '@polkadot/util';\nimport { base64Decode, decodeAddress, encodeAddress, ethereumEncode, hdEthereum, keyExtractSuri, keyFromPath, mnemonicToLegacySeed, mnemonicToMiniSecret, naclKeypairFromSeed as naclFromSeed, schnorrkelKeypairFromSeed as schnorrkelFromSeed, secp256k1KeypairFromSeed as secp256k1FromSeed } from '@polkadot/util-crypto';\nimport { DEV_PHRASE } from \"./defaults.js\";\nimport { createPair } from \"./pair/index.js\";\nimport { Pairs } from \"./pairs.js\";\nconst keypairFromSeed = {\n  ecdsa: seed => secp256k1FromSeed(seed),\n  ed25519: seed => naclFromSeed(seed),\n  ethereum: seed => secp256k1FromSeed(seed),\n  sr25519: seed => schnorrkelFromSeed(seed)\n};\n/**\n * # @polkadot/keyring\n *\n * ## Overview\n *\n * @name Keyring\n * @summary Keyring management of user accounts\n * @description Allows generation of keyring pairs from a variety of input combinations, such as\n * json object containing account address or public key, account metadata, and account encoded using\n * `addFromJson`, or by providing those values as arguments separately to `addFromAddress`,\n * or by providing the mnemonic (seed phrase) and account metadata as arguments to `addFromMnemonic`.\n * Stores the keyring pairs in a keyring pair dictionary. Removal of the keyring pairs from the keyring pair\n * dictionary is achieved using `removePair`. Retrieval of all the stored pairs via `getPairs` or perform\n * lookup of a pair for a given account address or public key using `getPair`. JSON metadata associated with\n * an account may be obtained using `toJson` accompanied by the account passphrase.\n */\n\nvar _pairs = /*#__PURE__*/_classPrivateFieldLooseKey(\"pairs\");\n\nvar _type = /*#__PURE__*/_classPrivateFieldLooseKey(\"type\");\n\nvar _ss = /*#__PURE__*/_classPrivateFieldLooseKey(\"ss58\");\n\nexport class Keyring {\n  constructor(options = {}) {\n    Object.defineProperty(this, _pairs, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _type, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _ss, {\n      writable: true,\n      value: void 0\n    });\n    this.decodeAddress = decodeAddress;\n\n    this.encodeAddress = (address, ss58Format) => {\n      return this.type === 'ethereum' ? ethereumEncode(address) : encodeAddress(address, isUndefined(ss58Format) ? _classPrivateFieldLooseBase(this, _ss)[_ss] : ss58Format);\n    };\n\n    options.type = options.type || 'ed25519';\n    assert(['ecdsa', 'ethereum', 'ed25519', 'sr25519'].includes(options.type || 'undefined'), () => `Expected a keyring type of either 'ed25519', 'sr25519', 'ethereum' or 'ecdsa', found '${options.type || 'unknown'}`);\n    _classPrivateFieldLooseBase(this, _pairs)[_pairs] = new Pairs();\n    _classPrivateFieldLooseBase(this, _ss)[_ss] = options.ss58Format;\n    _classPrivateFieldLooseBase(this, _type)[_type] = options.type;\n  }\n  /**\n   * @description retrieve the pairs (alias for getPairs)\n   */\n\n\n  get pairs() {\n    return this.getPairs();\n  }\n  /**\n   * @description retrieve the publicKeys (alias for getPublicKeys)\n   */\n\n\n  get publicKeys() {\n    return this.getPublicKeys();\n  }\n  /**\n   * @description Returns the type of the keyring, ed25519, sr25519 or ecdsa\n   */\n\n\n  get type() {\n    return _classPrivateFieldLooseBase(this, _type)[_type];\n  }\n  /**\n   * @name addPair\n   * @summary Stores an account, given a keyring pair, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n   */\n\n\n  addPair(pair) {\n    return _classPrivateFieldLooseBase(this, _pairs)[_pairs].add(pair);\n  }\n  /**\n   * @name addFromAddress\n   * @summary Stores an account, given an account address, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n   * @description Allows user to explicitly provide separate inputs including account address or public key, and optionally\n   * the associated account metadata, and the default encoded value as arguments (that may be obtained from the json file\n   * of an account backup), and then generates a keyring pair from them that it passes to\n   * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n   */\n\n\n  addFromAddress(address, meta = {}, encoded = null, type = this.type, ignoreChecksum, encType) {\n    const publicKey = this.decodeAddress(address, ignoreChecksum);\n    return this.addPair(createPair({\n      toSS58: this.encodeAddress,\n      type\n    }, {\n      publicKey,\n      secretKey: new Uint8Array()\n    }, meta, encoded, encType));\n  }\n  /**\n   * @name addFromJson\n   * @summary Stores an account, given JSON data, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n   * @description Allows user to provide a json object argument that contains account information (that may be obtained from the json file\n   * of an account backup), and then generates a keyring pair from it that it passes to\n   * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n   */\n\n\n  addFromJson(json, ignoreChecksum) {\n    return this.addPair(this.createFromJson(json, ignoreChecksum));\n  }\n  /**\n   * @name addFromMnemonic\n   * @summary Stores an account, given a mnemonic, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n   * @description Allows user to provide a mnemonic (seed phrase that is provided when account is originally created)\n   * argument and a metadata argument that contains account information (that may be obtained from the json file\n   * of an account backup), and then generates a keyring pair from it that it passes to\n   * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n   */\n\n\n  addFromMnemonic(mnemonic, meta = {}, type = this.type) {\n    return this.addFromUri(mnemonic, meta, type);\n  }\n  /**\n   * @name addFromPair\n   * @summary Stores an account created from an explicit publicKey/secreteKey combination\n   */\n\n\n  addFromPair(pair, meta = {}, type = this.type) {\n    return this.addPair(this.createFromPair(pair, meta, type));\n  }\n  /**\n   * @name addFromSeed\n   * @summary Stores an account, given seed data, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n   * @description Stores in a keyring pair dictionary the public key of the pair as a key and the pair as the associated value.\n   * Allows user to provide the account seed as an argument, and then generates a keyring pair from it that it passes to\n   * `addPair` to store in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n   */\n\n\n  addFromSeed(seed, meta = {}, type = this.type) {\n    return this.addPair(createPair({\n      toSS58: this.encodeAddress,\n      type\n    }, keypairFromSeed[type](seed), meta, null));\n  }\n  /**\n   * @name addFromUri\n   * @summary Creates an account via an suri\n   * @description Extracts the phrase, path and password from a SURI format for specifying secret keys `<secret>/<soft-key>//<hard-key>///<password>` (the `///password` may be omitted, and `/<soft-key>` and `//<hard-key>` maybe repeated and mixed). The secret can be a hex string, mnemonic phrase or a string (to be padded)\n   */\n\n\n  addFromUri(suri, meta = {}, type = this.type) {\n    return this.addPair(this.createFromUri(suri, meta, type));\n  }\n  /**\n   * @name createFromJson\n   * @description Creates a pair from a JSON keyfile\n   */\n\n\n  createFromJson({\n    address,\n    encoded,\n    encoding: {\n      content,\n      type,\n      version\n    },\n    meta\n  }, ignoreChecksum) {\n    assert(version !== '3' || content[0] === 'pkcs8', () => `Unable to decode non-pkcs8 type, [${content.join(',')}] found}`);\n    const cryptoType = version === '0' || !Array.isArray(content) ? this.type : content[1];\n    const encType = !Array.isArray(type) ? [type] : type;\n    assert(['ed25519', 'sr25519', 'ecdsa', 'ethereum'].includes(cryptoType), () => `Unknown crypto type ${cryptoType}`); // Here the address and publicKey are 32 bytes and isomorphic. This is why the address field needs to be the public key for ethereum type pairs\n\n    const publicKey = isHex(address) ? hexToU8a(address) : this.decodeAddress(address, ignoreChecksum);\n    const decoded = isHex(encoded) ? hexToU8a(encoded) : base64Decode(encoded);\n    return createPair({\n      toSS58: this.encodeAddress,\n      type: cryptoType\n    }, {\n      publicKey,\n      secretKey: new Uint8Array()\n    }, meta, decoded, encType);\n  }\n  /**\n   * @name createFromPair\n   * @summary Creates a pair from an explicit publicKey/secreteKey combination\n   */\n\n\n  createFromPair(pair, meta = {}, type = this.type) {\n    return createPair({\n      toSS58: this.encodeAddress,\n      type\n    }, pair, meta, null);\n  }\n  /**\n   * @name createFromUri\n   * @summary Creates a Keypair from an suri\n   * @description This creates a pair from the suri, but does not add it to the keyring\n   */\n\n\n  createFromUri(_suri, meta = {}, type = this.type) {\n    // here we only aut-add the dev phrase if we have a hard-derived path\n    const suri = _suri.startsWith('//') ? `${DEV_PHRASE}${_suri}` : _suri;\n    const {\n      derivePath,\n      password,\n      path,\n      phrase\n    } = keyExtractSuri(suri);\n    let seed;\n    const isPhraseHex = isHex(phrase, 256);\n\n    if (isPhraseHex) {\n      seed = hexToU8a(phrase);\n    } else {\n      const str = phrase;\n      const parts = str.split(' ');\n\n      if ([12, 15, 18, 21, 24].includes(parts.length)) {\n        seed = type === 'ethereum' ? mnemonicToLegacySeed(phrase, '', false, 64) : mnemonicToMiniSecret(phrase, password);\n      } else {\n        assert(str.length <= 32, 'specified phrase is not a valid mnemonic and is invalid as a raw seed at > 32 bytes');\n        seed = stringToU8a(str.padEnd(32));\n      }\n    }\n\n    const derived = type === 'ethereum' ? isPhraseHex ? keypairFromSeed[type](seed) // for eth, if the private key is provided as suri, it must be derived only once\n    : hdEthereum(seed, derivePath.substring(1)) : keyFromPath(keypairFromSeed[type](seed), path, type);\n    return createPair({\n      toSS58: this.encodeAddress,\n      type\n    }, derived, meta, null);\n  }\n  /**\n   * @name encodeAddress\n   * @description Encodes the input into an ss58 representation\n   */\n\n\n  /**\n   * @name getPair\n   * @summary Retrieves an account keyring pair from the Keyring Pair Dictionary, given an account address\n   * @description Returns a keyring pair value from the keyring pair dictionary by performing\n   * a key lookup using the provided account address or public key (after decoding it).\n   */\n  getPair(address) {\n    return _classPrivateFieldLooseBase(this, _pairs)[_pairs].get(address);\n  }\n  /**\n   * @name getPairs\n   * @summary Retrieves all account keyring pairs from the Keyring Pair Dictionary\n   * @description Returns an array list of all the keyring pair values that are stored in the keyring pair dictionary.\n   */\n\n\n  getPairs() {\n    return _classPrivateFieldLooseBase(this, _pairs)[_pairs].all();\n  }\n  /**\n   * @name getPublicKeys\n   * @summary Retrieves Public Keys of all Keyring Pairs stored in the Keyring Pair Dictionary\n   * @description Returns an array list of all the public keys associated with each of the keyring pair values that are stored in the keyring pair dictionary.\n   */\n\n\n  getPublicKeys() {\n    return _classPrivateFieldLooseBase(this, _pairs)[_pairs].all().map(({\n      publicKey\n    }) => publicKey);\n  }\n  /**\n   * @name removePair\n   * @description Deletes the provided input address or public key from the stored Keyring Pair Dictionary.\n   */\n\n\n  removePair(address) {\n    _classPrivateFieldLooseBase(this, _pairs)[_pairs].remove(address);\n  }\n  /**\n   * @name setSS58Format;\n   * @description Sets the ss58 format for the keyring\n   */\n\n\n  setSS58Format(ss58) {\n    _classPrivateFieldLooseBase(this, _ss)[_ss] = ss58;\n  }\n  /**\n   * @name toJson\n   * @summary Returns a JSON object associated with the input argument that contains metadata assocated with an account\n   * @description Returns a JSON object containing the metadata associated with an account\n   * when valid address or public key and when the account passphrase is provided if the account secret\n   * is not already unlocked and available in memory. Note that in [Polkadot-JS Apps](https://github.com/polkadot-js/apps) the user\n   * may backup their account to a JSON file that contains this information.\n   */\n\n\n  toJson(address, passphrase) {\n    return _classPrivateFieldLooseBase(this, _pairs)[_pairs].get(address).toJson(passphrase);\n  }\n\n}"]},"metadata":{},"sourceType":"module"}