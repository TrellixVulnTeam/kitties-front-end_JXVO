{"ast":null,"code":"import _slicedToArray from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n// Copyright 2019-2021 @polkadot/wasm-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n// MIT License\n//\n// Copyright (c) 2020 Arjun Barrett\n//\n// Copied from https://github.com/101arrowz/fflate/blob/73c737941ec89d85cdf0ad39ee6f26c5fdc95fd7/src/index.ts\n// This only contains the unzlibSync function, no compression, no async, no workers\n//\n// These 2 issues are addressed as a short-term, stop-gap solution\n//   - https://github.com/polkadot-js/api/issues/2963\n//   - https://github.com/101arrowz/fflate/issues/17\n//\n// Only tweaks make here are some TS adjustments (we use strict null checks), the code is otherwise as-is with\n// only the single required function provided (compression is still being done in the build with fflate)\n\n/* eslint-disable */\n// inflate state\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array,\n    u16 = Uint16Array,\n    u32 = Uint32Array; // code length index map\n\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]); // fixed length extra bits\n\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0,\n/* unused */\n0, 0,\n/* impossible */\n0]); // fixed distance extra bits\n// see fleb note\n\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13,\n/* unused */\n0, 0]); // get base, reverse index map from extra bits\n\nvar freb = function freb(eb, start) {\n  var b = new u16(31);\n\n  for (var i = 0; i < 31; ++i) {\n    b[i] = start += 1 << eb[i - 1];\n  } // numbers here are at max 18 bits\n\n\n  var r = new u32(b[30]);\n\n  for (var _i = 1; _i < 30; ++_i) {\n    for (var j = b[_i]; j < b[_i + 1]; ++j) {\n      r[j] = j - b[_i] << 5 | _i;\n    }\n  }\n\n  return [b, r];\n};\n\nvar _freb = freb(fleb, 2),\n    _freb2 = _slicedToArray(_freb, 2),\n    fl = _freb2[0],\n    revfl = _freb2[1]; // we can ignore the fact that the other numbers are wrong; they never happen anyway\n\n\nfl[28] = 258, revfl[258] = 28;\n\nvar _freb3 = freb(fdeb, 0),\n    _freb4 = _slicedToArray(_freb3, 1),\n    fd = _freb4[0]; // map of value to reverse (assuming 16 bits)\n\n\nvar rev = new u16(32768);\n\nfor (var i = 0; i < 32768; ++i) {\n  // reverse table algorithm from SO\n  var x = (i & 0xAAAA) >>> 1 | (i & 0x5555) << 1;\n  x = (x & 0xCCCC) >>> 2 | (x & 0x3333) << 2;\n  x = (x & 0xF0F0) >>> 4 | (x & 0x0F0F) << 4;\n  rev[i] = ((x & 0xFF00) >>> 8 | (x & 0x00FF) << 8) >>> 1;\n} // create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\n\n\nvar hMap = function hMap(cd, mb, r) {\n  var s = cd.length; // index\n\n  var i = 0; // u16 \"map\": index -> # of codes with bit length = index\n\n  var l = new u16(mb); // length of cd must be 288 (total # of codes)\n\n  for (; i < s; ++i) {\n    ++l[cd[i] - 1];\n  } // u16 \"map\": index -> minimum code for bit length = index\n\n\n  var le = new u16(mb);\n\n  for (i = 0; i < mb; ++i) {\n    le[i] = le[i - 1] + l[i - 1] << 1;\n  }\n\n  var co;\n\n  if (r) {\n    // u16 \"map\": index -> number of actual bits, symbol for code\n    co = new u16(1 << mb); // bits to remove for reverser\n\n    var rvb = 15 - mb;\n\n    for (i = 0; i < s; ++i) {\n      // ignore 0 lengths\n      if (cd[i]) {\n        // num encoding both symbol and bits read\n        var sv = i << 4 | cd[i]; // free bits\n\n        var _r = mb - cd[i]; // start value\n\n\n        var v = le[cd[i] - 1]++ << _r; // m is end value\n\n        for (var m = v | (1 << _r) - 1; v <= m; ++v) {\n          // every 16 bit value starting with the code yields the same result\n          co[rev[v] >>> rvb] = sv;\n        }\n      }\n    }\n  } else {\n    co = new u16(s);\n\n    for (i = 0; i < s; ++i) {\n      co[i] = rev[le[cd[i] - 1]++] >>> 15 - cd[i];\n    }\n  }\n\n  return co;\n}; // fixed length tree\n\n\nvar flt = new u8(288);\n\nfor (var _i2 = 0; _i2 < 144; ++_i2) {\n  flt[_i2] = 8;\n}\n\nfor (var _i3 = 144; _i3 < 256; ++_i3) {\n  flt[_i3] = 9;\n}\n\nfor (var _i4 = 256; _i4 < 280; ++_i4) {\n  flt[_i4] = 7;\n}\n\nfor (var _i5 = 280; _i5 < 288; ++_i5) {\n  flt[_i5] = 8;\n} // fixed distance tree\n\n\nvar fdt = new u8(32);\n\nfor (var _i6 = 0; _i6 < 32; ++_i6) {\n  fdt[_i6] = 5;\n} // fixed length map\n\n\nvar flrm = hMap(flt, 9, 1); // fixed distance map\n\nvar fdrm = hMap(fdt, 5, 1); // read d, starting at bit p and mask with m\n\nvar bits = function bits(d, p, m) {\n  var o = p >>> 3;\n  return (d[o] | d[o + 1] << 8) >>> (p & 7) & m;\n}; // read d, starting at bit p continuing for at least 16 bits\n\n\nvar bits16 = function bits16(d, p) {\n  var o = p >>> 3;\n  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >>> (p & 7);\n}; // get end of byte\n\n\nvar shft = function shft(p) {\n  return (p >>> 3) + (p & 7 && 1);\n}; // typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\n\n\nvar slc = function slc(v, s, e) {\n  if (s == null || s < 0) s = 0;\n  if (e == null || e > v.length) e = v.length; // can't use .constructor in case user-supplied\n\n  var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);\n  n.set(v.subarray(s, e));\n  return n;\n}; // find max of array\n\n\nvar max = function max(a) {\n  var m = a[0];\n\n  for (var _i7 = 1; _i7 < a.length; ++_i7) {\n    if (a[_i7] > m) m = a[_i7];\n  }\n\n  return m;\n}; // expands raw DEFLATE data\n\n\nvar inflt = function inflt(dat, buf, st) {\n  var noSt = !st || st.i;\n  if (!st) st = {}; // source length\n\n  var sl = dat.length; // have to estimate size\n\n  var noBuf = !buf || !noSt; // Assumes roughly 33% compression ratio average\n\n  if (!buf) buf = new u8(sl * 3); // ensure buffer can fit at least l elements\n\n  var cbuf = function cbuf(l) {\n    var bl = buf.length; // need to increase size to fit\n\n    if (l > bl) {\n      // Double or set to necessary, whichever is greater\n      var nbuf = new u8(Math.max(bl << 1, l));\n      nbuf.set(buf);\n      buf = nbuf;\n    }\n  }; //  last chunk         bitpos           bytes\n\n\n  var final = st.f || 0,\n      pos = st.p || 0,\n      bt = st.b || 0,\n      lm = st.l,\n      dm = st.d,\n      lbt = st.m,\n      dbt = st.n;\n  if (final && !lm) return buf; // total bits\n\n  var tbts = sl << 3;\n\n  do {\n    if (!lm) {\n      // BFINAL - this is only 1 when last chunk is next\n      st.f = final = bits(dat, pos, 1); // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n\n      var type = bits(dat, pos + 1, 3);\n      pos += 3;\n\n      if (!type) {\n        // go to end of byte boundary\n        var s = shft(pos) + 4,\n            l = dat[s - 4] | dat[s - 3] << 8,\n            t = s + l;\n\n        if (t > sl) {\n          if (noSt) throw 'unexpected EOF';\n          break;\n        } // ensure size\n\n\n        if (noBuf) cbuf(bt + l); // Copy over uncompressed data\n\n        buf.set(dat.subarray(s, t), bt); // Get new bitpos, update byte count\n\n        st.b = bt += l, st.p = pos = t << 3;\n        continue;\n      } else if (type == 1) lm = flrm, dm = fdrm, lbt = 9, dbt = 5;else if (type == 2) {\n        //  literal                            lengths\n        var hLit = bits(dat, pos, 31) + 257,\n            hcLen = bits(dat, pos + 10, 15) + 4;\n        var tl = hLit + bits(dat, pos + 5, 31) + 1;\n        pos += 14; // length+distance tree\n\n        var ldt = new u8(tl); // code length tree\n\n        var clt = new u8(19);\n\n        for (var _i8 = 0; _i8 < hcLen; ++_i8) {\n          // use index map to get real code\n          clt[clim[_i8]] = bits(dat, pos + _i8 * 3, 7);\n        }\n\n        pos += hcLen * 3; // code lengths bits\n\n        var clb = max(clt),\n            clbmsk = (1 << clb) - 1;\n        if (!noSt && pos + tl * (clb + 7) > tbts) break; // code lengths map\n\n        var clm = hMap(clt, clb, 1);\n\n        for (var _i9 = 0; _i9 < tl;) {\n          var r = clm[bits(dat, pos, clbmsk)]; // bits read\n\n          pos += r & 15; // symbol\n\n          var _s = r >>> 4; // code length to copy\n\n\n          if (_s < 16) {\n            ldt[_i9++] = _s;\n          } else {\n            //  copy   count\n            var c = 0,\n                n = 0;\n            if (_s == 16) n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[_i9 - 1];else if (_s == 17) n = 3 + bits(dat, pos, 7), pos += 3;else if (_s == 18) n = 11 + bits(dat, pos, 127), pos += 7;\n\n            while (n--) {\n              ldt[_i9++] = c;\n            }\n          }\n        } //    length tree                 distance tree\n\n\n        var lt = ldt.subarray(0, hLit),\n            dt = ldt.subarray(hLit); // max length bits\n\n        lbt = max(lt); // max dist bits\n\n        dbt = max(dt);\n        lm = hMap(lt, lbt, 1);\n        dm = hMap(dt, dbt, 1);\n      } else throw 'invalid block type';\n\n      if (pos > tbts) throw 'unexpected EOF';\n    } // Make sure the buffer can hold this + the largest possible addition\n    // maximum chunk size (practically, theoretically infinite) is 2^17;\n\n\n    if (noBuf) cbuf(bt + 131072);\n    var lms = (1 << lbt) - 1,\n        dms = (1 << dbt) - 1;\n    var mxa = lbt + dbt + 18;\n\n    while (noSt || pos + mxa < tbts) {\n      // bits read, code\n      var _c = lm[bits16(dat, pos) & lms],\n          sym = _c >>> 4;\n      pos += _c & 15;\n      if (pos > tbts) throw 'unexpected EOF';\n      if (!_c) throw 'invalid length/literal';\n      if (sym < 256) buf[bt++] = sym;else if (sym == 256) {\n        lm = undefined;\n        break;\n      } else {\n        var add = sym - 254; // no extra bits needed if less\n\n        if (sym > 264) {\n          // index\n          var _i10 = sym - 257,\n              b = fleb[_i10];\n\n          add = bits(dat, pos, (1 << b) - 1) + fl[_i10];\n          pos += b;\n        } // dist\n\n\n        var d = dm[bits16(dat, pos) & dms],\n            dsym = d >>> 4;\n        if (!d) throw 'invalid distance';\n        pos += d & 15;\n        var _dt = fd[dsym];\n\n        if (dsym > 3) {\n          var _b = fdeb[dsym];\n          _dt += bits16(dat, pos) & (1 << _b) - 1, pos += _b;\n        }\n\n        if (pos > tbts) throw 'unexpected EOF';\n        if (noBuf) cbuf(bt + 131072);\n        var end = bt + add;\n\n        for (; bt < end; bt += 4) {\n          buf[bt] = buf[bt - _dt];\n          buf[bt + 1] = buf[bt + 1 - _dt];\n          buf[bt + 2] = buf[bt + 2 - _dt];\n          buf[bt + 3] = buf[bt + 3 - _dt];\n        }\n\n        bt = end;\n      }\n    }\n\n    st.l = lm, st.p = pos, st.b = bt;\n    if (lm) final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n  } while (!final);\n\n  return bt == buf.length ? buf : slc(buf, 0, bt);\n}; // zlib valid\n\n\nvar zlv = function zlv(d) {\n  if ((d[0] & 15) != 8 || d[0] >>> 4 > 7 || (d[0] << 8 | d[1]) % 31) throw 'invalid zlib data';\n  if (d[1] & 32) throw 'invalid zlib data: preset dictionaries not supported';\n};\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\n\n\nexport function unzlibSync(data, out) {\n  return inflt((zlv(data), data.subarray(2, -4)), out);\n}","map":{"version":3,"sources":["/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/@polkadot/wasm-crypto-wasm/fflate.js"],"names":["u8","Uint8Array","u16","Uint16Array","u32","Uint32Array","clim","fleb","fdeb","freb","eb","start","b","i","r","j","fl","revfl","fd","rev","x","hMap","cd","mb","s","length","l","le","co","rvb","sv","v","m","flt","fdt","flrm","fdrm","bits","d","p","o","bits16","shft","slc","e","n","set","subarray","max","a","inflt","dat","buf","st","noSt","sl","noBuf","cbuf","bl","nbuf","Math","final","f","pos","bt","lm","dm","lbt","dbt","tbts","type","t","hLit","hcLen","tl","ldt","clt","clb","clbmsk","clm","c","lt","dt","lms","dms","mxa","sym","undefined","add","dsym","end","zlv","unzlibSync","data","out"],"mappings":"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","sourcesContent":["// Copyright 2019-2021 @polkadot/wasm-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n// MIT License\n//\n// Copyright (c) 2020 Arjun Barrett\n//\n// Copied from https://github.com/101arrowz/fflate/blob/73c737941ec89d85cdf0ad39ee6f26c5fdc95fd7/src/index.ts\n// This only contains the unzlibSync function, no compression, no async, no workers\n//\n// These 2 issues are addressed as a short-term, stop-gap solution\n//   - https://github.com/polkadot-js/api/issues/2963\n//   - https://github.com/101arrowz/fflate/issues/17\n//\n// Only tweaks make here are some TS adjustments (we use strict null checks), the code is otherwise as-is with\n// only the single required function provided (compression is still being done in the build with fflate)\n\n/* eslint-disable */\n// inflate state\n// aliases for shorter compressed code (most minifers don't do this)\nconst u8 = Uint8Array,\n      u16 = Uint16Array,\n      u32 = Uint32Array; // code length index map\n\nconst clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]); // fixed length extra bits\n\nconst fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0,\n/* unused */\n0, 0,\n/* impossible */\n0]); // fixed distance extra bits\n// see fleb note\n\nconst fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13,\n/* unused */\n0, 0]); // get base, reverse index map from extra bits\n\nconst freb = (eb, start) => {\n  const b = new u16(31);\n\n  for (let i = 0; i < 31; ++i) {\n    b[i] = start += 1 << eb[i - 1];\n  } // numbers here are at max 18 bits\n\n\n  const r = new u32(b[30]);\n\n  for (let i = 1; i < 30; ++i) {\n    for (let j = b[i]; j < b[i + 1]; ++j) {\n      r[j] = j - b[i] << 5 | i;\n    }\n  }\n\n  return [b, r];\n};\n\nconst [fl, revfl] = freb(fleb, 2); // we can ignore the fact that the other numbers are wrong; they never happen anyway\n\nfl[28] = 258, revfl[258] = 28;\nconst [fd] = freb(fdeb, 0); // map of value to reverse (assuming 16 bits)\n\nconst rev = new u16(32768);\n\nfor (let i = 0; i < 32768; ++i) {\n  // reverse table algorithm from SO\n  let x = (i & 0xAAAA) >>> 1 | (i & 0x5555) << 1;\n  x = (x & 0xCCCC) >>> 2 | (x & 0x3333) << 2;\n  x = (x & 0xF0F0) >>> 4 | (x & 0x0F0F) << 4;\n  rev[i] = ((x & 0xFF00) >>> 8 | (x & 0x00FF) << 8) >>> 1;\n} // create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\n\n\nconst hMap = (cd, mb, r) => {\n  const s = cd.length; // index\n\n  let i = 0; // u16 \"map\": index -> # of codes with bit length = index\n\n  const l = new u16(mb); // length of cd must be 288 (total # of codes)\n\n  for (; i < s; ++i) ++l[cd[i] - 1]; // u16 \"map\": index -> minimum code for bit length = index\n\n\n  const le = new u16(mb);\n\n  for (i = 0; i < mb; ++i) {\n    le[i] = le[i - 1] + l[i - 1] << 1;\n  }\n\n  let co;\n\n  if (r) {\n    // u16 \"map\": index -> number of actual bits, symbol for code\n    co = new u16(1 << mb); // bits to remove for reverser\n\n    const rvb = 15 - mb;\n\n    for (i = 0; i < s; ++i) {\n      // ignore 0 lengths\n      if (cd[i]) {\n        // num encoding both symbol and bits read\n        const sv = i << 4 | cd[i]; // free bits\n\n        const r = mb - cd[i]; // start value\n\n        let v = le[cd[i] - 1]++ << r; // m is end value\n\n        for (const m = v | (1 << r) - 1; v <= m; ++v) {\n          // every 16 bit value starting with the code yields the same result\n          co[rev[v] >>> rvb] = sv;\n        }\n      }\n    }\n  } else {\n    co = new u16(s);\n\n    for (i = 0; i < s; ++i) co[i] = rev[le[cd[i] - 1]++] >>> 15 - cd[i];\n  }\n\n  return co;\n}; // fixed length tree\n\n\nconst flt = new u8(288);\n\nfor (let i = 0; i < 144; ++i) flt[i] = 8;\n\nfor (let i = 144; i < 256; ++i) flt[i] = 9;\n\nfor (let i = 256; i < 280; ++i) flt[i] = 7;\n\nfor (let i = 280; i < 288; ++i) flt[i] = 8; // fixed distance tree\n\n\nconst fdt = new u8(32);\n\nfor (let i = 0; i < 32; ++i) fdt[i] = 5; // fixed length map\n\n\nconst flrm = hMap(flt, 9, 1); // fixed distance map\n\nconst fdrm = hMap(fdt, 5, 1); // read d, starting at bit p and mask with m\n\nconst bits = (d, p, m) => {\n  const o = p >>> 3;\n  return (d[o] | d[o + 1] << 8) >>> (p & 7) & m;\n}; // read d, starting at bit p continuing for at least 16 bits\n\n\nconst bits16 = (d, p) => {\n  const o = p >>> 3;\n  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >>> (p & 7);\n}; // get end of byte\n\n\nconst shft = p => (p >>> 3) + (p & 7 && 1); // typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\n\n\nconst slc = (v, s, e) => {\n  if (s == null || s < 0) s = 0;\n  if (e == null || e > v.length) e = v.length; // can't use .constructor in case user-supplied\n\n  const n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);\n  n.set(v.subarray(s, e));\n  return n;\n}; // find max of array\n\n\nconst max = a => {\n  let m = a[0];\n\n  for (let i = 1; i < a.length; ++i) {\n    if (a[i] > m) m = a[i];\n  }\n\n  return m;\n}; // expands raw DEFLATE data\n\n\nconst inflt = (dat, buf, st) => {\n  const noSt = !st || st.i;\n  if (!st) st = {}; // source length\n\n  const sl = dat.length; // have to estimate size\n\n  const noBuf = !buf || !noSt; // Assumes roughly 33% compression ratio average\n\n  if (!buf) buf = new u8(sl * 3); // ensure buffer can fit at least l elements\n\n  const cbuf = l => {\n    let bl = buf.length; // need to increase size to fit\n\n    if (l > bl) {\n      // Double or set to necessary, whichever is greater\n      const nbuf = new u8(Math.max(bl << 1, l));\n      nbuf.set(buf);\n      buf = nbuf;\n    }\n  }; //  last chunk         bitpos           bytes\n\n\n  let final = st.f || 0,\n      pos = st.p || 0,\n      bt = st.b || 0,\n      lm = st.l,\n      dm = st.d,\n      lbt = st.m,\n      dbt = st.n;\n  if (final && !lm) return buf; // total bits\n\n  const tbts = sl << 3;\n\n  do {\n    if (!lm) {\n      // BFINAL - this is only 1 when last chunk is next\n      st.f = final = bits(dat, pos, 1); // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n\n      const type = bits(dat, pos + 1, 3);\n      pos += 3;\n\n      if (!type) {\n        // go to end of byte boundary\n        const s = shft(pos) + 4,\n              l = dat[s - 4] | dat[s - 3] << 8,\n              t = s + l;\n\n        if (t > sl) {\n          if (noSt) throw 'unexpected EOF';\n          break;\n        } // ensure size\n\n\n        if (noBuf) cbuf(bt + l); // Copy over uncompressed data\n\n        buf.set(dat.subarray(s, t), bt); // Get new bitpos, update byte count\n\n        st.b = bt += l, st.p = pos = t << 3;\n        continue;\n      } else if (type == 1) lm = flrm, dm = fdrm, lbt = 9, dbt = 5;else if (type == 2) {\n        //  literal                            lengths\n        const hLit = bits(dat, pos, 31) + 257,\n              hcLen = bits(dat, pos + 10, 15) + 4;\n        const tl = hLit + bits(dat, pos + 5, 31) + 1;\n        pos += 14; // length+distance tree\n\n        const ldt = new u8(tl); // code length tree\n\n        const clt = new u8(19);\n\n        for (let i = 0; i < hcLen; ++i) {\n          // use index map to get real code\n          clt[clim[i]] = bits(dat, pos + i * 3, 7);\n        }\n\n        pos += hcLen * 3; // code lengths bits\n\n        const clb = max(clt),\n              clbmsk = (1 << clb) - 1;\n        if (!noSt && pos + tl * (clb + 7) > tbts) break; // code lengths map\n\n        const clm = hMap(clt, clb, 1);\n\n        for (let i = 0; i < tl;) {\n          const r = clm[bits(dat, pos, clbmsk)]; // bits read\n\n          pos += r & 15; // symbol\n\n          const s = r >>> 4; // code length to copy\n\n          if (s < 16) {\n            ldt[i++] = s;\n          } else {\n            //  copy   count\n            let c = 0,\n                n = 0;\n            if (s == 16) n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];else if (s == 17) n = 3 + bits(dat, pos, 7), pos += 3;else if (s == 18) n = 11 + bits(dat, pos, 127), pos += 7;\n\n            while (n--) ldt[i++] = c;\n          }\n        } //    length tree                 distance tree\n\n\n        const lt = ldt.subarray(0, hLit),\n              dt = ldt.subarray(hLit); // max length bits\n\n        lbt = max(lt); // max dist bits\n\n        dbt = max(dt);\n        lm = hMap(lt, lbt, 1);\n        dm = hMap(dt, dbt, 1);\n      } else throw 'invalid block type';\n\n      if (pos > tbts) throw 'unexpected EOF';\n    } // Make sure the buffer can hold this + the largest possible addition\n    // maximum chunk size (practically, theoretically infinite) is 2^17;\n\n\n    if (noBuf) cbuf(bt + 131072);\n    const lms = (1 << lbt) - 1,\n          dms = (1 << dbt) - 1;\n    const mxa = lbt + dbt + 18;\n\n    while (noSt || pos + mxa < tbts) {\n      // bits read, code\n      const c = lm[bits16(dat, pos) & lms],\n            sym = c >>> 4;\n      pos += c & 15;\n      if (pos > tbts) throw 'unexpected EOF';\n      if (!c) throw 'invalid length/literal';\n      if (sym < 256) buf[bt++] = sym;else if (sym == 256) {\n        lm = undefined;\n        break;\n      } else {\n        let add = sym - 254; // no extra bits needed if less\n\n        if (sym > 264) {\n          // index\n          const i = sym - 257,\n                b = fleb[i];\n          add = bits(dat, pos, (1 << b) - 1) + fl[i];\n          pos += b;\n        } // dist\n\n\n        const d = dm[bits16(dat, pos) & dms],\n              dsym = d >>> 4;\n        if (!d) throw 'invalid distance';\n        pos += d & 15;\n        let dt = fd[dsym];\n\n        if (dsym > 3) {\n          const b = fdeb[dsym];\n          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n        }\n\n        if (pos > tbts) throw 'unexpected EOF';\n        if (noBuf) cbuf(bt + 131072);\n        const end = bt + add;\n\n        for (; bt < end; bt += 4) {\n          buf[bt] = buf[bt - dt];\n          buf[bt + 1] = buf[bt + 1 - dt];\n          buf[bt + 2] = buf[bt + 2 - dt];\n          buf[bt + 3] = buf[bt + 3 - dt];\n        }\n\n        bt = end;\n      }\n    }\n\n    st.l = lm, st.p = pos, st.b = bt;\n    if (lm) final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n  } while (!final);\n\n  return bt == buf.length ? buf : slc(buf, 0, bt);\n}; // zlib valid\n\n\nconst zlv = d => {\n  if ((d[0] & 15) != 8 || d[0] >>> 4 > 7 || (d[0] << 8 | d[1]) % 31) throw 'invalid zlib data';\n  if (d[1] & 32) throw 'invalid zlib data: preset dictionaries not supported';\n};\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\n\n\nexport function unzlibSync(data, out) {\n  return inflt((zlv(data), data.subarray(2, -4)), out);\n}"]},"metadata":{},"sourceType":"module"}