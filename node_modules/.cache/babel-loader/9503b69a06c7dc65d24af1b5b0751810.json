{"ast":null,"code":"import _toConsumableArray from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _createClass from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _inherits from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { isHex, isObject, isU8a, u8aToU8a } from '@polkadot/util';\nimport { Struct } from \"../codec/Struct.js\";\nimport { U8aFixed } from \"../codec/U8aFixed.js\";\nimport { getTypeClass } from \"../create/createClass.js\";\nimport { getTypeDef } from \"../create/getTypeDef.js\";\n/**\n * Get a mapping of `argument name -> argument type` for the function, from\n * its metadata.\n *\n * @param meta - The function metadata used to get the definition.\n * @internal\n */\n\nfunction getArgsDef(registry, meta) {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  return GenericCall.filterOrigin(meta).reduce(function (result, _ref) {\n    var name = _ref.name,\n        type = _ref.type;\n    var Type = getTypeClass(registry, getTypeDef(type));\n    result[name.toString()] = Type;\n    return result;\n  }, {});\n}\n/** @internal */\n\n\nfunction decodeCallViaObject(registry, value, _meta) {\n  // we only pass args/methodsIndex out\n  var args = value.args,\n      callIndex = value.callIndex; // Get the correct lookupIndex\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n  var lookupIndex = callIndex instanceof GenericCallIndex ? callIndex.toU8a() : callIndex; // Find metadata with callIndex\n\n  var meta = _meta || registry.findMetaCall(lookupIndex).meta;\n\n  return {\n    args: args,\n    argsDef: getArgsDef(registry, meta),\n    callIndex: callIndex,\n    meta: meta\n  };\n}\n/** @internal */\n\n\nfunction decodeCallViaU8a(registry, value, _meta) {\n  // We need 2 bytes for the callIndex\n  var callIndex = new Uint8Array(2);\n  callIndex.set(value.subarray(0, 2), 0); // Find metadata with callIndex\n\n  var meta = _meta || registry.findMetaCall(callIndex).meta;\n\n  return {\n    args: value.subarray(2),\n    argsDef: getArgsDef(registry, meta),\n    callIndex: callIndex,\n    meta: meta\n  };\n}\n/**\n * Decode input to pass into constructor.\n *\n * @param value - Value to decode, one of:\n * - hex\n * - Uint8Array\n * - {@see DecodeMethodInput}\n * @param _meta - Metadata to use, so that `injectMethods` lookup is not\n * necessary.\n * @internal\n */\n\n\nfunction decodeCall(registry) {\n  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Uint8Array();\n\n  var _meta = arguments.length > 2 ? arguments[2] : undefined;\n\n  if (isHex(value) || isU8a(value)) {\n    return decodeCallViaU8a(registry, u8aToU8a(value), _meta);\n  } else if (isObject(value) && value.callIndex && value.args) {\n    return decodeCallViaObject(registry, value, _meta);\n  }\n\n  throw new Error(\"Call: Cannot decode value '\".concat(value, \"' of type \").concat(typeof value));\n}\n/**\n * @name GenericCallIndex\n * @description\n * A wrapper around the `[sectionIndex, methodIndex]` value that uniquely identifies a method\n */\n\n\nexport var GenericCallIndex = /*#__PURE__*/function (_U8aFixed) {\n  _inherits(GenericCallIndex, _U8aFixed);\n\n  var _super = _createSuper(GenericCallIndex);\n\n  function GenericCallIndex(registry, value) {\n    _classCallCheck(this, GenericCallIndex);\n\n    return _super.call(this, registry, value, 16);\n  }\n\n  return GenericCallIndex;\n}(U8aFixed);\n/**\n * @name GenericCall\n * @description\n * Extrinsic function descriptor\n */\n\nexport var GenericCall = /*#__PURE__*/function (_Struct) {\n  _inherits(GenericCall, _Struct);\n\n  var _super2 = _createSuper(GenericCall);\n\n  function GenericCall(registry, value, meta) {\n    var _this;\n\n    _classCallCheck(this, GenericCall);\n\n    var decoded = decodeCall(registry, value, meta);\n\n    try {\n      _this = _super2.call(this, registry, {\n        callIndex: GenericCallIndex,\n        // eslint-disable-next-line sort-keys\n        args: Struct.with(decoded.argsDef)\n      }, decoded);\n      _this._meta = void 0;\n    } catch (error) {\n      var method = 'unknown.unknown';\n\n      try {\n        var c = registry.findMetaCall(decoded.callIndex);\n        method = \"\".concat(c.section, \".\").concat(c.method);\n      } catch (error) {// ignore\n      }\n\n      throw new Error(\"Call: failed decoding \".concat(method, \":: \").concat(error.message));\n    }\n\n    _this._meta = decoded.meta;\n    return _this;\n  } // If the extrinsic function has an argument of type `Origin`, we ignore it\n\n\n  _createClass(GenericCall, [{\n    key: \"args\",\n    get:\n    /**\n     * @description The arguments for the function call\n     */\n    function get() {\n      // FIXME This should return a Struct instead of an Array\n      return _toConsumableArray(this.get('args').values());\n    }\n    /**\n     * @description The argument definitions\n     */\n\n  }, {\n    key: \"argsDef\",\n    get: function get() {\n      return getArgsDef(this.registry, this.meta);\n    }\n    /**\n     * @description The encoded `[sectionIndex, methodIndex]` identifier\n     */\n\n  }, {\n    key: \"callIndex\",\n    get: function get() {\n      return this.get('callIndex').toU8a();\n    }\n    /**\n     * @description The encoded data\n     */\n\n  }, {\n    key: \"data\",\n    get: function get() {\n      return this.get('args').toU8a();\n    }\n    /**\n     * @description The [[FunctionMetadata]]\n     */\n\n  }, {\n    key: \"meta\",\n    get: function get() {\n      return this._meta;\n    }\n    /**\n     * @description Returns the name of the method\n     */\n\n  }, {\n    key: \"method\",\n    get: function get() {\n      return this.registry.findMetaCall(this.callIndex).method;\n    }\n    /**\n     * @description Returns the module containing the method\n     */\n\n  }, {\n    key: \"section\",\n    get: function get() {\n      return this.registry.findMetaCall(this.callIndex).section;\n    }\n    /**\n     * @description Checks if the source matches this in type\n     */\n\n  }, {\n    key: \"is\",\n    value: function is(other) {\n      return other.callIndex[0] === this.callIndex[0] && other.callIndex[1] === this.callIndex[1];\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n\n  }, {\n    key: \"toHuman\",\n    value: function toHuman(isExpanded) {\n      var _call, _call2;\n\n      var call;\n\n      try {\n        call = this.registry.findMetaCall(this.callIndex);\n      } catch (error) {// swallow\n      }\n\n      return _objectSpread({\n        args: this.args.map(function (arg) {\n          return arg.toHuman(isExpanded);\n        }),\n        // args: this.args.map((arg, index) => call\n        //   ? { [call.meta.args[index].name.toString()]: arg.toHuman(isExpanded) }\n        //   : arg.toHuman(isExpanded)\n        // ),\n        // callIndex: u8aToHex(this.callIndex),\n        method: (_call = call) === null || _call === void 0 ? void 0 : _call.method,\n        section: (_call2 = call) === null || _call2 === void 0 ? void 0 : _call2.section\n      }, isExpanded && call ? {\n        docs: call.meta.docs.map(function (d) {\n          return d.toString();\n        })\n      } : {});\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n\n  }, {\n    key: \"toRawType\",\n    value: function toRawType() {\n      return 'Call';\n    }\n  }], [{\n    key: \"filterOrigin\",\n    value: function filterOrigin(meta) {\n      // FIXME should be `arg.type !== Origin`, but doesn't work...\n      return meta ? meta.args.filter(function (_ref2) {\n        var type = _ref2.type;\n        return type.toString() !== 'Origin';\n      }) : [];\n    }\n  }]);\n\n  return GenericCall;\n}(Struct);","map":{"version":3,"sources":["/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/@polkadot/types/generic/Call.js"],"names":["_defineProperty","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","isHex","isObject","isU8a","u8aToU8a","Struct","U8aFixed","getTypeClass","getTypeDef","getArgsDef","registry","meta","GenericCall","filterOrigin","reduce","result","name","type","Type","toString","decodeCallViaObject","value","_meta","args","callIndex","lookupIndex","GenericCallIndex","toU8a","findMetaCall","argsDef","decodeCallViaU8a","Uint8Array","set","subarray","decodeCall","Error","decoded","with","error","method","c","section","message","get","values","other","isExpanded","_call","_call2","call","map","arg","toHuman","docs","d"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { isHex, isObject, isU8a, u8aToU8a } from '@polkadot/util';\nimport { Struct } from \"../codec/Struct.js\";\nimport { U8aFixed } from \"../codec/U8aFixed.js\";\nimport { getTypeClass } from \"../create/createClass.js\";\nimport { getTypeDef } from \"../create/getTypeDef.js\";\n\n/**\n * Get a mapping of `argument name -> argument type` for the function, from\n * its metadata.\n *\n * @param meta - The function metadata used to get the definition.\n * @internal\n */\nfunction getArgsDef(registry, meta) {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  return GenericCall.filterOrigin(meta).reduce((result, {\n    name,\n    type\n  }) => {\n    const Type = getTypeClass(registry, getTypeDef(type));\n    result[name.toString()] = Type;\n    return result;\n  }, {});\n}\n/** @internal */\n\n\nfunction decodeCallViaObject(registry, value, _meta) {\n  // we only pass args/methodsIndex out\n  const {\n    args,\n    callIndex\n  } = value; // Get the correct lookupIndex\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n  const lookupIndex = callIndex instanceof GenericCallIndex ? callIndex.toU8a() : callIndex; // Find metadata with callIndex\n\n  const meta = _meta || registry.findMetaCall(lookupIndex).meta;\n\n  return {\n    args,\n    argsDef: getArgsDef(registry, meta),\n    callIndex,\n    meta\n  };\n}\n/** @internal */\n\n\nfunction decodeCallViaU8a(registry, value, _meta) {\n  // We need 2 bytes for the callIndex\n  const callIndex = new Uint8Array(2);\n  callIndex.set(value.subarray(0, 2), 0); // Find metadata with callIndex\n\n  const meta = _meta || registry.findMetaCall(callIndex).meta;\n\n  return {\n    args: value.subarray(2),\n    argsDef: getArgsDef(registry, meta),\n    callIndex,\n    meta\n  };\n}\n/**\n * Decode input to pass into constructor.\n *\n * @param value - Value to decode, one of:\n * - hex\n * - Uint8Array\n * - {@see DecodeMethodInput}\n * @param _meta - Metadata to use, so that `injectMethods` lookup is not\n * necessary.\n * @internal\n */\n\n\nfunction decodeCall(registry, value = new Uint8Array(), _meta) {\n  if (isHex(value) || isU8a(value)) {\n    return decodeCallViaU8a(registry, u8aToU8a(value), _meta);\n  } else if (isObject(value) && value.callIndex && value.args) {\n    return decodeCallViaObject(registry, value, _meta);\n  }\n\n  throw new Error(`Call: Cannot decode value '${value}' of type ${typeof value}`);\n}\n/**\n * @name GenericCallIndex\n * @description\n * A wrapper around the `[sectionIndex, methodIndex]` value that uniquely identifies a method\n */\n\n\nexport class GenericCallIndex extends U8aFixed {\n  constructor(registry, value) {\n    super(registry, value, 16);\n  }\n\n}\n/**\n * @name GenericCall\n * @description\n * Extrinsic function descriptor\n */\n\nexport class GenericCall extends Struct {\n  constructor(registry, value, meta) {\n    const decoded = decodeCall(registry, value, meta);\n\n    try {\n      super(registry, {\n        callIndex: GenericCallIndex,\n        // eslint-disable-next-line sort-keys\n        args: Struct.with(decoded.argsDef)\n      }, decoded);\n      this._meta = void 0;\n    } catch (error) {\n      let method = 'unknown.unknown';\n\n      try {\n        const c = registry.findMetaCall(decoded.callIndex);\n        method = `${c.section}.${c.method}`;\n      } catch (error) {// ignore\n      }\n\n      throw new Error(`Call: failed decoding ${method}:: ${error.message}`);\n    }\n\n    this._meta = decoded.meta;\n  } // If the extrinsic function has an argument of type `Origin`, we ignore it\n\n\n  static filterOrigin(meta) {\n    // FIXME should be `arg.type !== Origin`, but doesn't work...\n    return meta ? meta.args.filter(({\n      type\n    }) => type.toString() !== 'Origin') : [];\n  }\n  /**\n   * @description The arguments for the function call\n   */\n\n\n  get args() {\n    // FIXME This should return a Struct instead of an Array\n    return [...this.get('args').values()];\n  }\n  /**\n   * @description The argument definitions\n   */\n\n\n  get argsDef() {\n    return getArgsDef(this.registry, this.meta);\n  }\n  /**\n   * @description The encoded `[sectionIndex, methodIndex]` identifier\n   */\n\n\n  get callIndex() {\n    return this.get('callIndex').toU8a();\n  }\n  /**\n   * @description The encoded data\n   */\n\n\n  get data() {\n    return this.get('args').toU8a();\n  }\n  /**\n   * @description The [[FunctionMetadata]]\n   */\n\n\n  get meta() {\n    return this._meta;\n  }\n  /**\n   * @description Returns the name of the method\n   */\n\n\n  get method() {\n    return this.registry.findMetaCall(this.callIndex).method;\n  }\n  /**\n   * @description Returns the module containing the method\n   */\n\n\n  get section() {\n    return this.registry.findMetaCall(this.callIndex).section;\n  }\n  /**\n   * @description Checks if the source matches this in type\n   */\n\n\n  is(other) {\n    return other.callIndex[0] === this.callIndex[0] && other.callIndex[1] === this.callIndex[1];\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman(isExpanded) {\n    var _call, _call2;\n\n    let call;\n\n    try {\n      call = this.registry.findMetaCall(this.callIndex);\n    } catch (error) {// swallow\n    }\n\n    return _objectSpread({\n      args: this.args.map(arg => arg.toHuman(isExpanded)),\n      // args: this.args.map((arg, index) => call\n      //   ? { [call.meta.args[index].name.toString()]: arg.toHuman(isExpanded) }\n      //   : arg.toHuman(isExpanded)\n      // ),\n      // callIndex: u8aToHex(this.callIndex),\n      method: (_call = call) === null || _call === void 0 ? void 0 : _call.method,\n      section: (_call2 = call) === null || _call2 === void 0 ? void 0 : _call2.section\n    }, isExpanded && call ? {\n      docs: call.meta.docs.map(d => d.toString())\n    } : {});\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return 'Call';\n  }\n\n}"]},"metadata":{},"sourceType":"module"}