{"ast":null,"code":"import _toConsumableArray from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2019-2021 @polkadot/extension-dapp authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { u8aEq } from '@polkadot/util';\nimport { decodeAddress, encodeAddress } from '@polkadot/util-crypto';\nimport { documentReadyPromise } from \"./util.js\"; // expose utility functions\n\nexport { unwrapBytes, wrapBytes } from \"./wrapBytes.js\"; // just a helper (otherwise we cast all-over, so shorter and more readable)\n\nvar win = window; // don't clobber the existing object, but ensure non-undefined\n\nwin.injectedWeb3 = win.injectedWeb3 || {}; // true when anything has been injected and is available\n\nfunction web3IsInjected() {\n  return Object.keys(win.injectedWeb3).length !== 0;\n} // helper to throw a consistent error when not enabled\n\n\nfunction throwError(method) {\n  throw new Error(\"\".concat(method, \": web3Enable(originName) needs to be called before \").concat(method));\n} // internal helper to map from Array<InjectedAccount> -> Array<InjectedAccountWithMeta>\n\n\nfunction mapAccounts(source, list, ss58Format) {\n  return list.map(function (_ref) {\n    var address = _ref.address,\n        genesisHash = _ref.genesisHash,\n        name = _ref.name;\n    var encodedAddress = encodeAddress(decodeAddress(address), ss58Format);\n    return {\n      address: encodedAddress,\n      meta: {\n        genesisHash: genesisHash,\n        name: name,\n        source: source\n      }\n    };\n  });\n} // have we found a properly constructed window.injectedWeb3\n\n\nvar isWeb3Injected = web3IsInjected(); // we keep the last promise created around (for queries)\n\nvar web3EnablePromise = null;\nexport { isWeb3Injected, web3EnablePromise };\n\nfunction getWindowExtensions(originName) {\n  return Promise.all(Object.entries(win.injectedWeb3).map(function (_ref2) {\n    var _ref3 = _slicedToArray(_ref2, 2),\n        name = _ref3[0],\n        _ref3$ = _ref3[1],\n        enable = _ref3$.enable,\n        version = _ref3$.version;\n\n    return Promise.all([Promise.resolve({\n      name: name,\n      version: version\n    }), enable(originName).catch(function (error) {\n      console.error(\"Error initializing \".concat(name, \": \").concat(error.message));\n    })]);\n  }));\n} // enables all the providers found on the injected window interface\n\n\nexport function web3Enable(originName) {\n  if (!originName) {\n    throw new Error('You must pass a name for your app to the web3Enable function');\n  }\n\n  web3EnablePromise = documentReadyPromise(function () {\n    return getWindowExtensions(originName).then(function (values) {\n      return values.filter(function (value) {\n        return !!value[1];\n      }).map(function (_ref4) {\n        var _ref5 = _slicedToArray(_ref4, 2),\n            info = _ref5[0],\n            ext = _ref5[1];\n\n        // if we don't have an accounts subscriber, add a single-shot version\n        if (!ext.accounts.subscribe) {\n          ext.accounts.subscribe = function (cb) {\n            ext.accounts.get().then(cb).catch(console.error);\n            return function () {// no ubsubscribe needed, this is a single-shot\n            };\n          };\n        }\n\n        return _objectSpread(_objectSpread({}, info), ext);\n      });\n    }).catch(function () {\n      return [];\n    }).then(function (values) {\n      var names = values.map(function (_ref6) {\n        var name = _ref6.name,\n            version = _ref6.version;\n        return \"\".concat(name, \"/\").concat(version);\n      });\n      isWeb3Injected = web3IsInjected();\n      console.log(\"web3Enable: Enabled \".concat(values.length, \" extension\").concat(values.length !== 1 ? 's' : '', \": \").concat(names.join(', ')));\n      return values;\n    });\n  });\n  return web3EnablePromise;\n} // retrieve all the accounts accross all providers\n\nexport function web3Accounts() {\n  return _web3Accounts.apply(this, arguments);\n}\n\nfunction _web3Accounts() {\n  _web3Accounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n    var _ref7,\n        ss58Format,\n        accounts,\n        injected,\n        retrieved,\n        addresses,\n        _args2 = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _ref7 = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {}, ss58Format = _ref7.ss58Format;\n\n            if (web3EnablePromise) {\n              _context2.next = 3;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", throwError('web3Accounts'));\n\n          case 3:\n            accounts = [];\n            _context2.next = 6;\n            return web3EnablePromise;\n\n          case 6:\n            injected = _context2.sent;\n            _context2.next = 9;\n            return Promise.all(injected.map( /*#__PURE__*/function () {\n              var _ref10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref9) {\n                var accounts, source, list;\n                return _regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        accounts = _ref9.accounts, source = _ref9.name;\n                        _context.prev = 1;\n                        _context.next = 4;\n                        return accounts.get();\n\n                      case 4:\n                        list = _context.sent;\n                        return _context.abrupt(\"return\", mapAccounts(source, list, ss58Format));\n\n                      case 8:\n                        _context.prev = 8;\n                        _context.t0 = _context[\"catch\"](1);\n                        return _context.abrupt(\"return\", []);\n\n                      case 11:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee, null, [[1, 8]]);\n              }));\n\n              return function (_x7) {\n                return _ref10.apply(this, arguments);\n              };\n            }()));\n\n          case 9:\n            retrieved = _context2.sent;\n            retrieved.forEach(function (result) {\n              accounts.push.apply(accounts, _toConsumableArray(result));\n            });\n            addresses = accounts.map(function (_ref11) {\n              var address = _ref11.address;\n              return address;\n            });\n            console.log(\"web3Accounts: Found \".concat(accounts.length, \" address\").concat(accounts.length !== 1 ? 'es' : '', \": \").concat(addresses.join(', ')));\n            return _context2.abrupt(\"return\", accounts);\n\n          case 14:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _web3Accounts.apply(this, arguments);\n}\n\nexport function web3AccountsSubscribe(_x) {\n  return _web3AccountsSubscribe.apply(this, arguments);\n} // find a specific provider based on the name\n\nfunction _web3AccountsSubscribe() {\n  _web3AccountsSubscribe = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(cb) {\n    var _ref8,\n        ss58Format,\n        accounts,\n        triggerUpdate,\n        unsubs,\n        _args3 = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _ref8 = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {}, ss58Format = _ref8.ss58Format;\n\n            if (web3EnablePromise) {\n              _context3.next = 3;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", throwError('web3AccountsSubscribe'));\n\n          case 3:\n            accounts = {};\n\n            triggerUpdate = function triggerUpdate() {\n              return cb(Object.entries(accounts).reduce(function (result, _ref12) {\n                var _ref13 = _slicedToArray(_ref12, 2),\n                    source = _ref13[0],\n                    list = _ref13[1];\n\n                result.push.apply(result, _toConsumableArray(mapAccounts(source, list, ss58Format)));\n                return result;\n              }, []));\n            };\n\n            _context3.next = 7;\n            return web3EnablePromise;\n\n          case 7:\n            unsubs = _context3.sent.map(function (_ref14) {\n              var subscribe = _ref14.accounts.subscribe,\n                  source = _ref14.name;\n              return subscribe(function (result) {\n                accounts[source] = result; // eslint-disable-next-line @typescript-eslint/no-floating-promises\n\n                triggerUpdate();\n              });\n            });\n            return _context3.abrupt(\"return\", function () {\n              unsubs.forEach(function (unsub) {\n                unsub();\n              });\n            });\n\n          case 9:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _web3AccountsSubscribe.apply(this, arguments);\n}\n\nexport function web3FromSource(_x2) {\n  return _web3FromSource.apply(this, arguments);\n} // find a specific provider based on an address\n\nfunction _web3FromSource() {\n  _web3FromSource = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(source) {\n    var sources, found;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            if (web3EnablePromise) {\n              _context4.next = 2;\n              break;\n            }\n\n            return _context4.abrupt(\"return\", throwError('web3FromSource'));\n\n          case 2:\n            _context4.next = 4;\n            return web3EnablePromise;\n\n          case 4:\n            sources = _context4.sent;\n            found = source && sources.find(function (_ref15) {\n              var name = _ref15.name;\n              return name === source;\n            });\n\n            if (found) {\n              _context4.next = 8;\n              break;\n            }\n\n            throw new Error(\"web3FromSource: Unable to find an injected \".concat(source));\n\n          case 8:\n            return _context4.abrupt(\"return\", found);\n\n          case 9:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _web3FromSource.apply(this, arguments);\n}\n\nexport function web3FromAddress(_x3) {\n  return _web3FromAddress.apply(this, arguments);\n} // retrieve all providers exposed by one source\n\nfunction _web3FromAddress() {\n  _web3FromAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(address) {\n    var accounts, found, accountU8a;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            if (web3EnablePromise) {\n              _context5.next = 2;\n              break;\n            }\n\n            return _context5.abrupt(\"return\", throwError('web3FromAddress'));\n\n          case 2:\n            _context5.next = 4;\n            return web3Accounts();\n\n          case 4:\n            accounts = _context5.sent;\n\n            if (address) {\n              accountU8a = decodeAddress(address);\n              found = accounts.find(function (account) {\n                return u8aEq(decodeAddress(account.address), accountU8a);\n              });\n            }\n\n            if (found) {\n              _context5.next = 8;\n              break;\n            }\n\n            throw new Error(\"web3FromAddress: Unable to find injected \".concat(address));\n\n          case 8:\n            return _context5.abrupt(\"return\", web3FromSource(found.meta.source));\n\n          case 9:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return _web3FromAddress.apply(this, arguments);\n}\n\nexport function web3ListRpcProviders(_x4) {\n  return _web3ListRpcProviders.apply(this, arguments);\n} // retrieve all providers exposed by one source\n\nfunction _web3ListRpcProviders() {\n  _web3ListRpcProviders = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(source) {\n    var _yield$web3FromSource, provider;\n\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _context6.next = 2;\n            return web3FromSource(source);\n\n          case 2:\n            _yield$web3FromSource = _context6.sent;\n            provider = _yield$web3FromSource.provider;\n\n            if (provider) {\n              _context6.next = 7;\n              break;\n            }\n\n            console.warn(\"Extension \".concat(source, \" does not expose any provider\"));\n            return _context6.abrupt(\"return\", null);\n\n          case 7:\n            return _context6.abrupt(\"return\", provider.listProviders());\n\n          case 8:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n  return _web3ListRpcProviders.apply(this, arguments);\n}\n\nexport function web3UseRpcProvider(_x5, _x6) {\n  return _web3UseRpcProvider.apply(this, arguments);\n}\n\nfunction _web3UseRpcProvider() {\n  _web3UseRpcProvider = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(source, key) {\n    var _yield$web3FromSource2, provider, meta;\n\n    return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            _context7.next = 2;\n            return web3FromSource(source);\n\n          case 2:\n            _yield$web3FromSource2 = _context7.sent;\n            provider = _yield$web3FromSource2.provider;\n\n            if (provider) {\n              _context7.next = 6;\n              break;\n            }\n\n            throw new Error(\"Extension \".concat(source, \" does not expose any provider\"));\n\n          case 6:\n            _context7.next = 8;\n            return provider.startProvider(key);\n\n          case 8:\n            meta = _context7.sent;\n            return _context7.abrupt(\"return\", {\n              meta: meta,\n              provider: provider\n            });\n\n          case 10:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n  return _web3UseRpcProvider.apply(this, arguments);\n}","map":{"version":3,"sources":["/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/@polkadot/extension-dapp/index.js"],"names":["_defineProperty","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","u8aEq","decodeAddress","encodeAddress","documentReadyPromise","unwrapBytes","wrapBytes","win","window","injectedWeb3","web3IsInjected","throwError","method","Error","mapAccounts","list","ss58Format","map","address","genesisHash","name","encodedAddress","meta","isWeb3Injected","web3EnablePromise","getWindowExtensions","originName","Promise","all","entries","enable","version","resolve","catch","error","console","message","web3Enable","then","values","value","info","ext","accounts","subscribe","cb","get","names","log","join","web3Accounts","injected","retrieved","result","addresses","web3AccountsSubscribe","triggerUpdate","reduce","unsubs","unsub","web3FromSource","sources","found","find","web3FromAddress","accountU8a","account","web3ListRpcProviders","provider","warn","listProviders","web3UseRpcProvider","startProvider"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2019-2021 @polkadot/extension-dapp authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { u8aEq } from '@polkadot/util';\nimport { decodeAddress, encodeAddress } from '@polkadot/util-crypto';\nimport { documentReadyPromise } from \"./util.js\"; // expose utility functions\n\nexport { unwrapBytes, wrapBytes } from \"./wrapBytes.js\"; // just a helper (otherwise we cast all-over, so shorter and more readable)\n\nconst win = window; // don't clobber the existing object, but ensure non-undefined\n\nwin.injectedWeb3 = win.injectedWeb3 || {}; // true when anything has been injected and is available\n\nfunction web3IsInjected() {\n  return Object.keys(win.injectedWeb3).length !== 0;\n} // helper to throw a consistent error when not enabled\n\n\nfunction throwError(method) {\n  throw new Error(`${method}: web3Enable(originName) needs to be called before ${method}`);\n} // internal helper to map from Array<InjectedAccount> -> Array<InjectedAccountWithMeta>\n\n\nfunction mapAccounts(source, list, ss58Format) {\n  return list.map(({\n    address,\n    genesisHash,\n    name\n  }) => {\n    const encodedAddress = encodeAddress(decodeAddress(address), ss58Format);\n    return {\n      address: encodedAddress,\n      meta: {\n        genesisHash,\n        name,\n        source\n      }\n    };\n  });\n} // have we found a properly constructed window.injectedWeb3\n\n\nlet isWeb3Injected = web3IsInjected(); // we keep the last promise created around (for queries)\n\nlet web3EnablePromise = null;\nexport { isWeb3Injected, web3EnablePromise };\n\nfunction getWindowExtensions(originName) {\n  return Promise.all(Object.entries(win.injectedWeb3).map(([name, {\n    enable,\n    version\n  }]) => Promise.all([Promise.resolve({\n    name,\n    version\n  }), enable(originName).catch(error => {\n    console.error(`Error initializing ${name}: ${error.message}`);\n  })])));\n} // enables all the providers found on the injected window interface\n\n\nexport function web3Enable(originName) {\n  if (!originName) {\n    throw new Error('You must pass a name for your app to the web3Enable function');\n  }\n\n  web3EnablePromise = documentReadyPromise(() => getWindowExtensions(originName).then(values => values.filter(value => !!value[1]).map(([info, ext]) => {\n    // if we don't have an accounts subscriber, add a single-shot version\n    if (!ext.accounts.subscribe) {\n      ext.accounts.subscribe = cb => {\n        ext.accounts.get().then(cb).catch(console.error);\n        return () => {// no ubsubscribe needed, this is a single-shot\n        };\n      };\n    }\n\n    return _objectSpread(_objectSpread({}, info), ext);\n  })).catch(() => []).then(values => {\n    const names = values.map(({\n      name,\n      version\n    }) => `${name}/${version}`);\n    isWeb3Injected = web3IsInjected();\n    console.log(`web3Enable: Enabled ${values.length} extension${values.length !== 1 ? 's' : ''}: ${names.join(', ')}`);\n    return values;\n  }));\n  return web3EnablePromise;\n} // retrieve all the accounts accross all providers\n\nexport async function web3Accounts({\n  ss58Format\n} = {}) {\n  if (!web3EnablePromise) {\n    return throwError('web3Accounts');\n  }\n\n  const accounts = [];\n  const injected = await web3EnablePromise;\n  const retrieved = await Promise.all(injected.map(async ({\n    accounts,\n    name: source\n  }) => {\n    try {\n      const list = await accounts.get();\n      return mapAccounts(source, list, ss58Format);\n    } catch (error) {\n      // cannot handle this one\n      return [];\n    }\n  }));\n  retrieved.forEach(result => {\n    accounts.push(...result);\n  });\n  const addresses = accounts.map(({\n    address\n  }) => address);\n  console.log(`web3Accounts: Found ${accounts.length} address${accounts.length !== 1 ? 'es' : ''}: ${addresses.join(', ')}`);\n  return accounts;\n}\nexport async function web3AccountsSubscribe(cb, {\n  ss58Format\n} = {}) {\n  if (!web3EnablePromise) {\n    return throwError('web3AccountsSubscribe');\n  }\n\n  const accounts = {};\n\n  const triggerUpdate = () => cb(Object.entries(accounts).reduce((result, [source, list]) => {\n    result.push(...mapAccounts(source, list, ss58Format));\n    return result;\n  }, []));\n\n  const unsubs = (await web3EnablePromise).map(({\n    accounts: {\n      subscribe\n    },\n    name: source\n  }) => subscribe(result => {\n    accounts[source] = result; // eslint-disable-next-line @typescript-eslint/no-floating-promises\n\n    triggerUpdate();\n  }));\n  return () => {\n    unsubs.forEach(unsub => {\n      unsub();\n    });\n  };\n} // find a specific provider based on the name\n\nexport async function web3FromSource(source) {\n  if (!web3EnablePromise) {\n    return throwError('web3FromSource');\n  }\n\n  const sources = await web3EnablePromise;\n  const found = source && sources.find(({\n    name\n  }) => name === source);\n\n  if (!found) {\n    throw new Error(`web3FromSource: Unable to find an injected ${source}`);\n  }\n\n  return found;\n} // find a specific provider based on an address\n\nexport async function web3FromAddress(address) {\n  if (!web3EnablePromise) {\n    return throwError('web3FromAddress');\n  }\n\n  const accounts = await web3Accounts();\n  let found;\n\n  if (address) {\n    const accountU8a = decodeAddress(address);\n    found = accounts.find(account => u8aEq(decodeAddress(account.address), accountU8a));\n  }\n\n  if (!found) {\n    throw new Error(`web3FromAddress: Unable to find injected ${address}`);\n  }\n\n  return web3FromSource(found.meta.source);\n} // retrieve all providers exposed by one source\n\nexport async function web3ListRpcProviders(source) {\n  const {\n    provider\n  } = await web3FromSource(source);\n\n  if (!provider) {\n    console.warn(`Extension ${source} does not expose any provider`);\n    return null;\n  }\n\n  return provider.listProviders();\n} // retrieve all providers exposed by one source\n\nexport async function web3UseRpcProvider(source, key) {\n  const {\n    provider\n  } = await web3FromSource(source);\n\n  if (!provider) {\n    throw new Error(`Extension ${source} does not expose any provider`);\n  }\n\n  const meta = await provider.startProvider(key);\n  return {\n    meta,\n    provider\n  };\n}"]},"metadata":{},"sourceType":"module"}