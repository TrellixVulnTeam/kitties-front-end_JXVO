{"ast":null,"code":"import _toConsumableArray from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { assert, compactAddLength, compactStripLength, isUndefined, stringCamelCase, stringLowerFirst, u8aConcat, u8aToU8a } from '@polkadot/util';\nimport { xxhashAsU8a } from '@polkadot/util-crypto';\nimport { Raw } from \"../../../codec/index.js\";\nimport { getHasher } from \"./getHasher.js\";\n/** @internal */\n\nfunction createKeyRaw(registry, itemFn, keys, hashers, args) {\n  return u8aConcat.apply(void 0, [xxhashAsU8a(itemFn.prefix, 128), xxhashAsU8a(itemFn.method, 128)].concat(_toConsumableArray(keys.map(function (type, index) {\n    return getHasher(hashers[index])(registry.createType(type.toString(), args[index]).toU8a());\n  }))));\n}\n/** @internal */\n\n\nfunction createKey(registry, itemFn, keys, hashers, args) {\n  var method = itemFn.method,\n      section = itemFn.section;\n  assert(Array.isArray(args), function () {\n    return \"Call to \".concat(stringCamelCase(section || 'unknown'), \".\").concat(stringCamelCase(method || 'unknown'), \" needs \").concat(keys.length, \" arguments, provided in tuple format\");\n  });\n  assert(args.filter(function (a) {\n    return !isUndefined(a);\n  }).length === keys.length, function () {\n    return \"Call to \".concat(stringCamelCase(section || 'unknown'), \".\").concat(stringCamelCase(method || 'unknown'), \" needs \").concat(keys.length, \" arguments, found [\").concat(args.join(', '), \"]\");\n  }); // as per createKey, always add the length prefix (underlying it is Bytes)\n\n  return compactAddLength(createKeyRaw(registry, itemFn, keys, hashers, args));\n}\n/** @internal */\n\n\nfunction expandWithMeta(_ref, _storageFn) {\n  var meta = _ref.meta,\n      method = _ref.method,\n      prefix = _ref.prefix,\n      section = _ref.section;\n  var storageFn = _storageFn;\n  storageFn.meta = meta;\n  storageFn.method = stringLowerFirst(method);\n  storageFn.prefix = prefix;\n  storageFn.section = section; // explicitly add the actual method in the toJSON, this gets used to determine caching and without it\n  // instances (e.g. collective) will not work since it is only matched on param meta\n\n  storageFn.toJSON = function () {\n    return _objectSpread(_objectSpread({}, meta.toJSON()), {}, {\n      storage: {\n        method: method,\n        prefix: prefix,\n        section: section\n      }\n    });\n  };\n\n  return storageFn;\n}\n/** @internal */\n\n\nfunction extendHeadMeta(registry, _ref2, _ref3, iterFn) {\n  var _ref2$meta = _ref2.meta,\n      docs = _ref2$meta.docs,\n      name = _ref2$meta.name,\n      type = _ref2$meta.type,\n      section = _ref2.section;\n  var method = _ref3.method;\n  var outputType = type.isMap ? type.asMap.key : type.isDoubleMap ? type.asDoubleMap.key1 : type.asNMap.keyVec[0]; // metadata with a fallback value using the type of the key, the normal\n  // meta fallback only applies to actual entry values, create one for head\n\n  iterFn.meta = registry.createType('StorageEntryMetadataLatest', {\n    docs: docs,\n    fallback: registry.createType('Bytes'),\n    modifier: registry.createType('StorageEntryModifierLatest', 1),\n    // required\n    name: name,\n    type: registry.createType('StorageEntryTypeLatest', registry.createType('Type', outputType), 0)\n  });\n  return function () {\n    return registry.createType('StorageKey', iterFn.apply(void 0, arguments), {\n      method: method,\n      section: section\n    });\n  };\n}\n/** @internal */\n\n\nfunction extendPrefixedMap(registry, itemFn, storageFn) {\n  var type = itemFn.meta.type,\n      method = itemFn.method,\n      section = itemFn.section;\n  storageFn.iterKey = extendHeadMeta(registry, itemFn, storageFn, function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    assert(args.length === 0 || type.isDoubleMap && args.length === 1 || type.isNMap && args.length < type.asNMap.hashers.length, function () {\n      return \"Iteration \".concat(stringCamelCase(section || 'unknown'), \".\").concat(stringCamelCase(method || 'unknown'), \" needs arguments to be at least one less than the full arguments, found [\").concat(args.join(', '), \"]\");\n    });\n\n    if (args.length) {\n      if (type.isDoubleMap) {\n        return new Raw(registry, createKeyRaw(registry, itemFn, [type.asDoubleMap.key1], [type.asDoubleMap.hasher], args));\n      } else if (type.isNMap) {\n        var keys = _toConsumableArray(type.asNMap.keyVec);\n\n        var hashers = _toConsumableArray(type.asNMap.hashers); // pick the first n entries where n = args.length which is already verified above to be less that the full arguments.\n\n\n        keys = keys.slice(0, args.length);\n        hashers = hashers.slice(0, args.length);\n        return new Raw(registry, createKeyRaw(registry, itemFn, keys, hashers, args));\n      }\n    }\n\n    return new Raw(registry, createKeyRaw(registry, itemFn, [], [], []));\n  });\n  return storageFn;\n}\n/** @internal */\n\n\nexport function createFunction(registry, itemFn, options) {\n  var type = itemFn.meta.type; // Can only have zero or one argument:\n  //   - storage.system.account(address)\n  //   - storage.timestamp.blockPeriod()\n  // For higher-map queries the params are passed in as an tuple, [key1, key2]\n\n  var storageFn = expandWithMeta(itemFn, function (arg) {\n    return type.isPlain ? options.skipHashing ? compactAddLength(u8aToU8a(options.key)) : createKey(registry, itemFn, [], [], []) : type.isMap ? createKey(registry, itemFn, [type.asMap.key], [type.asMap.hasher], [arg]) : type.isDoubleMap ? createKey(registry, itemFn, [type.asDoubleMap.key1, type.asDoubleMap.key2], [type.asDoubleMap.hasher, type.asDoubleMap.key2Hasher], arg) : createKey(registry, itemFn, type.asNMap.keyVec, type.asNMap.hashers, arg);\n  });\n\n  if (type.isMap || type.isDoubleMap || type.isNMap) {\n    extendPrefixedMap(registry, itemFn, storageFn);\n  }\n\n  storageFn.keyPrefix = function () {\n    return storageFn.iterKey && storageFn.iterKey.apply(storageFn, arguments) || compactStripLength(storageFn())[1];\n  };\n\n  return storageFn;\n}","map":{"version":3,"sources":["/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/@polkadot/types/metadata/decorate/storage/createFunction.js"],"names":["_defineProperty","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","assert","compactAddLength","compactStripLength","isUndefined","stringCamelCase","stringLowerFirst","u8aConcat","u8aToU8a","xxhashAsU8a","Raw","getHasher","createKeyRaw","registry","itemFn","hashers","args","prefix","method","map","type","index","createType","toString","toU8a","createKey","section","Array","isArray","a","join","expandWithMeta","_storageFn","meta","storageFn","toJSON","storage","extendHeadMeta","iterFn","docs","name","outputType","isMap","asMap","isDoubleMap","asDoubleMap","key1","asNMap","keyVec","fallback","modifier","extendPrefixedMap","iterKey","isNMap","hasher","slice","createFunction","options","arg","isPlain","skipHashing","key2","key2Hasher","keyPrefix"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, compactAddLength, compactStripLength, isUndefined, stringCamelCase, stringLowerFirst, u8aConcat, u8aToU8a } from '@polkadot/util';\nimport { xxhashAsU8a } from '@polkadot/util-crypto';\nimport { Raw } from \"../../../codec/index.js\";\nimport { getHasher } from \"./getHasher.js\";\n\n/** @internal */\nfunction createKeyRaw(registry, itemFn, keys, hashers, args) {\n  return u8aConcat(xxhashAsU8a(itemFn.prefix, 128), xxhashAsU8a(itemFn.method, 128), ...keys.map((type, index) => getHasher(hashers[index])(registry.createType(type.toString(), args[index]).toU8a())));\n}\n/** @internal */\n\n\nfunction createKey(registry, itemFn, keys, hashers, args) {\n  const {\n    method,\n    section\n  } = itemFn;\n  assert(Array.isArray(args), () => `Call to ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} needs ${keys.length} arguments, provided in tuple format`);\n  assert(args.filter(a => !isUndefined(a)).length === keys.length, () => `Call to ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} needs ${keys.length} arguments, found [${args.join(', ')}]`); // as per createKey, always add the length prefix (underlying it is Bytes)\n\n  return compactAddLength(createKeyRaw(registry, itemFn, keys, hashers, args));\n}\n/** @internal */\n\n\nfunction expandWithMeta({\n  meta,\n  method,\n  prefix,\n  section\n}, _storageFn) {\n  const storageFn = _storageFn;\n  storageFn.meta = meta;\n  storageFn.method = stringLowerFirst(method);\n  storageFn.prefix = prefix;\n  storageFn.section = section; // explicitly add the actual method in the toJSON, this gets used to determine caching and without it\n  // instances (e.g. collective) will not work since it is only matched on param meta\n\n  storageFn.toJSON = () => _objectSpread(_objectSpread({}, meta.toJSON()), {}, {\n    storage: {\n      method,\n      prefix,\n      section\n    }\n  });\n\n  return storageFn;\n}\n/** @internal */\n\n\nfunction extendHeadMeta(registry, {\n  meta: {\n    docs,\n    name,\n    type\n  },\n  section\n}, {\n  method\n}, iterFn) {\n  const outputType = type.isMap ? type.asMap.key : type.isDoubleMap ? type.asDoubleMap.key1 : type.asNMap.keyVec[0]; // metadata with a fallback value using the type of the key, the normal\n  // meta fallback only applies to actual entry values, create one for head\n\n  iterFn.meta = registry.createType('StorageEntryMetadataLatest', {\n    docs,\n    fallback: registry.createType('Bytes'),\n    modifier: registry.createType('StorageEntryModifierLatest', 1),\n    // required\n    name,\n    type: registry.createType('StorageEntryTypeLatest', registry.createType('Type', outputType), 0)\n  });\n  return (...args) => registry.createType('StorageKey', iterFn(...args), {\n    method,\n    section\n  });\n}\n/** @internal */\n\n\nfunction extendPrefixedMap(registry, itemFn, storageFn) {\n  const {\n    meta: {\n      type\n    },\n    method,\n    section\n  } = itemFn;\n  storageFn.iterKey = extendHeadMeta(registry, itemFn, storageFn, (...args) => {\n    assert(args.length === 0 || type.isDoubleMap && args.length === 1 || type.isNMap && args.length < type.asNMap.hashers.length, () => `Iteration ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} needs arguments to be at least one less than the full arguments, found [${args.join(', ')}]`);\n\n    if (args.length) {\n      if (type.isDoubleMap) {\n        return new Raw(registry, createKeyRaw(registry, itemFn, [type.asDoubleMap.key1], [type.asDoubleMap.hasher], args));\n      } else if (type.isNMap) {\n        let keys = [...type.asNMap.keyVec];\n        let hashers = [...type.asNMap.hashers]; // pick the first n entries where n = args.length which is already verified above to be less that the full arguments.\n\n        keys = keys.slice(0, args.length);\n        hashers = hashers.slice(0, args.length);\n        return new Raw(registry, createKeyRaw(registry, itemFn, keys, hashers, args));\n      }\n    }\n\n    return new Raw(registry, createKeyRaw(registry, itemFn, [], [], []));\n  });\n  return storageFn;\n}\n/** @internal */\n\n\nexport function createFunction(registry, itemFn, options) {\n  const {\n    meta: {\n      type\n    }\n  } = itemFn; // Can only have zero or one argument:\n  //   - storage.system.account(address)\n  //   - storage.timestamp.blockPeriod()\n  // For higher-map queries the params are passed in as an tuple, [key1, key2]\n\n  const storageFn = expandWithMeta(itemFn, arg => type.isPlain ? options.skipHashing ? compactAddLength(u8aToU8a(options.key)) : createKey(registry, itemFn, [], [], []) : type.isMap ? createKey(registry, itemFn, [type.asMap.key], [type.asMap.hasher], [arg]) : type.isDoubleMap ? createKey(registry, itemFn, [type.asDoubleMap.key1, type.asDoubleMap.key2], [type.asDoubleMap.hasher, type.asDoubleMap.key2Hasher], arg) : createKey(registry, itemFn, type.asNMap.keyVec, type.asNMap.hashers, arg));\n\n  if (type.isMap || type.isDoubleMap || type.isNMap) {\n    extendPrefixedMap(registry, itemFn, storageFn);\n  }\n\n  storageFn.keyPrefix = (...args) => storageFn.iterKey && storageFn.iterKey(...args) || compactStripLength(storageFn())[1];\n\n  return storageFn;\n}"]},"metadata":{},"sourceType":"module"}