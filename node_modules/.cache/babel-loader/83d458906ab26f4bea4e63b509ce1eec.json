{"ast":null,"code":"import _toConsumableArray from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _slicedToArray from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, compactFromU8a, compactToU8a, isString, u8aConcat, u8aToU8a } from '@polkadot/util';\nimport { Raw } from \"../codec/Raw.js\";\n/** @internal */\n\nfunction decodeBitVecU8a(value) {\n  if (!value || !value.length) {\n    return [0, new Uint8Array()];\n  } // handle all other Uint8Array inputs, these do have a length prefix which is the number of bits encoded\n\n\n  var _compactFromU8a = compactFromU8a(value),\n      _compactFromU8a2 = _slicedToArray(_compactFromU8a, 2),\n      offset = _compactFromU8a2[0],\n      length = _compactFromU8a2[1];\n\n  var total = offset + Math.ceil(length.toNumber() / 8);\n  assert(total <= value.length, function () {\n    return \"BitVec: required length less than remainder, expected at least \".concat(total, \", found \").concat(value.length);\n  });\n  return [length.toNumber(), value.subarray(offset, total)];\n}\n/** @internal */\n\n\nfunction decodeBitVec(value) {\n  if (Array.isArray(value) || isString(value)) {\n    var u8a = u8aToU8a(value);\n    return [u8a.length / 8, u8a];\n  }\n\n  return decodeBitVecU8a(value);\n}\n/**\n * @name BitVec\n * @description\n * A BitVec that represents an array of bits. The bits are however stored encoded. The difference between this\n * and a normal Bytes would be that the length prefix indicates the number of bits encoded, not the bytes\n */\n\n\nexport var BitVec = /*#__PURE__*/function (_Raw) {\n  _inherits(BitVec, _Raw);\n\n  var _super = _createSuper(BitVec);\n\n  function BitVec(registry, value) {\n    var _this;\n\n    _classCallCheck(this, BitVec);\n\n    var _decodeBitVec = decodeBitVec(value),\n        _decodeBitVec2 = _slicedToArray(_decodeBitVec, 2),\n        decodedLength = _decodeBitVec2[0],\n        u8a = _decodeBitVec2[1];\n\n    _this = _super.call(this, registry, u8a);\n    _this._decodedLength = void 0;\n    _this._decodedLength = decodedLength;\n    return _this;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  _createClass(BitVec, [{\n    key: \"encodedLength\",\n    get: function get() {\n      return this.length + compactToU8a(this._decodedLength).length;\n    }\n  }, {\n    key: \"toHuman\",\n    value: function toHuman() {\n      return \"0b\".concat(_toConsumableArray(this.toU8a(true)).map(function (d) {\n        return \"00000000\".concat(d.toString(2)).slice(-8);\n      }).join('_'));\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n\n  }, {\n    key: \"toRawType\",\n    value: function toRawType() {\n      return 'BitVec';\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n\n  }, {\n    key: \"toU8a\",\n    value: function toU8a(isBare) {\n      var bitVec = _get(_getPrototypeOf(BitVec.prototype), \"toU8a\", this).call(this);\n\n      return isBare ? bitVec : u8aConcat(compactToU8a(this._decodedLength), bitVec);\n    }\n  }]);\n\n  return BitVec;\n}(Raw);","map":{"version":3,"sources":["/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/@polkadot/types/primitive/BitVec.js"],"names":["assert","compactFromU8a","compactToU8a","isString","u8aConcat","u8aToU8a","Raw","decodeBitVecU8a","value","length","Uint8Array","offset","total","Math","ceil","toNumber","subarray","decodeBitVec","Array","isArray","u8a","BitVec","registry","decodedLength","_decodedLength","toU8a","map","d","toString","slice","join","isBare","bitVec"],"mappings":";;;;;;;;AAAA;AACA;AACA,SAASA,MAAT,EAAiBC,cAAjB,EAAiCC,YAAjC,EAA+CC,QAA/C,EAAyDC,SAAzD,EAAoEC,QAApE,QAAoF,gBAApF;AACA,SAASC,GAAT,QAAoB,iBAApB;AACA;;AAEA,SAASC,eAAT,CAAyBC,KAAzB,EAAgC;AAC9B,MAAI,CAACA,KAAD,IAAU,CAACA,KAAK,CAACC,MAArB,EAA6B;AAC3B,WAAO,CAAC,CAAD,EAAI,IAAIC,UAAJ,EAAJ,CAAP;AACD,GAH6B,CAG5B;;;AAGF,wBAAyBT,cAAc,CAACO,KAAD,CAAvC;AAAA;AAAA,MAAOG,MAAP;AAAA,MAAeF,MAAf;;AACA,MAAMG,KAAK,GAAGD,MAAM,GAAGE,IAAI,CAACC,IAAL,CAAUL,MAAM,CAACM,QAAP,KAAoB,CAA9B,CAAvB;AACAf,EAAAA,MAAM,CAACY,KAAK,IAAIJ,KAAK,CAACC,MAAhB,EAAwB;AAAA,oFAAwEG,KAAxE,qBAAwFJ,KAAK,CAACC,MAA9F;AAAA,GAAxB,CAAN;AACA,SAAO,CAACA,MAAM,CAACM,QAAP,EAAD,EAAoBP,KAAK,CAACQ,QAAN,CAAeL,MAAf,EAAuBC,KAAvB,CAApB,CAAP;AACD;AACD;;;AAGA,SAASK,YAAT,CAAsBT,KAAtB,EAA6B;AAC3B,MAAIU,KAAK,CAACC,OAAN,CAAcX,KAAd,KAAwBL,QAAQ,CAACK,KAAD,CAApC,EAA6C;AAC3C,QAAMY,GAAG,GAAGf,QAAQ,CAACG,KAAD,CAApB;AACA,WAAO,CAACY,GAAG,CAACX,MAAJ,GAAa,CAAd,EAAiBW,GAAjB,CAAP;AACD;;AAED,SAAOb,eAAe,CAACC,KAAD,CAAtB;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;;AAGA,WAAaa,MAAb;AAAA;;AAAA;;AACE,kBAAYC,QAAZ,EAAsBd,KAAtB,EAA6B;AAAA;;AAAA;;AAC3B,wBAA6BS,YAAY,CAACT,KAAD,CAAzC;AAAA;AAAA,QAAOe,aAAP;AAAA,QAAsBH,GAAtB;;AACA,8BAAME,QAAN,EAAgBF,GAAhB;AACA,UAAKI,cAAL,GAAsB,KAAK,CAA3B;AACA,UAAKA,cAAL,GAAsBD,aAAtB;AAJ2B;AAK5B;AACD;AACF;AACA;;;AATA;AAAA;AAAA,SAYE,eAAoB;AAClB,aAAO,KAAKd,MAAL,GAAcP,YAAY,CAAC,KAAKsB,cAAN,CAAZ,CAAkCf,MAAvD;AACD;AAdH;AAAA;AAAA,WAgBE,mBAAU;AACR,yBAAY,mBAAI,KAAKgB,KAAL,CAAW,IAAX,CAAJ,EAAsBC,GAAtB,CAA0B,UAAAC,CAAC;AAAA,eAAI,kBAAWA,CAAC,CAACC,QAAF,CAAW,CAAX,CAAX,EAA2BC,KAA3B,CAAiC,CAAC,CAAlC,CAAJ;AAAA,OAA3B,EAAqEC,IAArE,CAA0E,GAA1E,CAAZ;AACD;AACD;AACF;AACA;;AArBA;AAAA;AAAA,WAwBE,qBAAY;AACV,aAAO,QAAP;AACD;AACD;AACF;AACA;AACA;;AA9BA;AAAA;AAAA,WAiCE,eAAMC,MAAN,EAAc;AACZ,UAAMC,MAAM,oEAAZ;;AACA,aAAOD,MAAM,GAAGC,MAAH,GAAY5B,SAAS,CAACF,YAAY,CAAC,KAAKsB,cAAN,CAAb,EAAoCQ,MAApC,CAAlC;AACD;AApCH;;AAAA;AAAA,EAA4B1B,GAA5B","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, compactFromU8a, compactToU8a, isString, u8aConcat, u8aToU8a } from '@polkadot/util';\nimport { Raw } from \"../codec/Raw.js\";\n/** @internal */\n\nfunction decodeBitVecU8a(value) {\n  if (!value || !value.length) {\n    return [0, new Uint8Array()];\n  } // handle all other Uint8Array inputs, these do have a length prefix which is the number of bits encoded\n\n\n  const [offset, length] = compactFromU8a(value);\n  const total = offset + Math.ceil(length.toNumber() / 8);\n  assert(total <= value.length, () => `BitVec: required length less than remainder, expected at least ${total}, found ${value.length}`);\n  return [length.toNumber(), value.subarray(offset, total)];\n}\n/** @internal */\n\n\nfunction decodeBitVec(value) {\n  if (Array.isArray(value) || isString(value)) {\n    const u8a = u8aToU8a(value);\n    return [u8a.length / 8, u8a];\n  }\n\n  return decodeBitVecU8a(value);\n}\n/**\n * @name BitVec\n * @description\n * A BitVec that represents an array of bits. The bits are however stored encoded. The difference between this\n * and a normal Bytes would be that the length prefix indicates the number of bits encoded, not the bytes\n */\n\n\nexport class BitVec extends Raw {\n  constructor(registry, value) {\n    const [decodedLength, u8a] = decodeBitVec(value);\n    super(registry, u8a);\n    this._decodedLength = void 0;\n    this._decodedLength = decodedLength;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return this.length + compactToU8a(this._decodedLength).length;\n  }\n\n  toHuman() {\n    return `0b${[...this.toU8a(true)].map(d => `00000000${d.toString(2)}`.slice(-8)).join('_')}`;\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return 'BitVec';\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    const bitVec = super.toU8a();\n    return isBare ? bitVec : u8aConcat(compactToU8a(this._decodedLength), bitVec);\n  }\n\n}"]},"metadata":{},"sourceType":"module"}