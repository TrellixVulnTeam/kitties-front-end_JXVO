{"ast":null,"code":"import _toConsumableArray from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _slicedToArray from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { assert, isNumber, isString, stringCamelCase, stringify, stringUpperFirst } from '@polkadot/util';\nimport { Struct } from \"../codec/Struct.js\";\nimport { withTypeString } from \"../create/encodeTypes.js\";\nimport { getTypeDef } from \"../create/getTypeDef.js\";\nimport { TypeDefInfo } from \"../types/index.js\"; // Alias the primitive enum with out known values\n\nvar PRIMITIVE_ALIAS = {\n  Char: 'u32',\n  // Rust char is 4-bytes\n  Str: 'Text'\n}; // These are types where we have a specific decoding/encoding override + helpers\n\nvar PRIMITIVE_PATHS = [// match {node, polkadot, ...}_runtime\n'*_runtime::Call', '*_runtime::Event', // these have a specific encoding or logic (for pallets)\n'pallet_democracy::vote::Vote', 'pallet_identity::types::Data', // these are well-known types with additional encoding\n'sp_core::crypto::AccountId32', 'sp_runtime::generic::era::Era', 'sp_runtime::multiaddress::MultiAddress', // shorten some well-known types\n'primitive_types::*', 'sp_arithmetic::per_things::*', // ink!\n'ink_env::types::*'].map(function (p) {\n  return p.split('::');\n}); // Mappings for types that should be converted to set via BitVec\n\nvar SETS = ['pallet_identity::types::BitFlags'].map(function (p) {\n  return p.split('::');\n}); // These we never use these as top-level names, they are wrappers\n\nvar WRAPPERS = ['BoundedBTreeMap', 'BoundedVec', 'Box', 'BTreeMap', 'Cow', 'Result', 'Option', 'WeakBoundedVec']; // These are reserved and/or conflicts with built-in Codec definitions\n\nvar RESERVED = ['call', 'entries', 'hash', 'keys', 'new', 'size'];\n\nfunction matchParts(first, second) {\n  return first.length === second.length && first.every(function (a, index) {\n    var b = second[index].toString();\n    return a === '*' || a === b || a.includes('*') && a.includes('_') && b.includes('_') && matchParts(a.split('_'), b.split('_'));\n  });\n} // check if the path matches the PRIMITIVE_SP (with wildcards)\n\n\nfunction getPrimitivePath(path) {\n  // TODO We need to handle ink! Balance in some way\n  return path.length && PRIMITIVE_PATHS.some(function (p) {\n    return matchParts(p, path);\n  }) ? path[path.length - 1].toString() : null;\n}\n\nfunction removeDuplicateNames(names) {\n  return names.map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        lookupIndex = _ref2[0],\n        name = _ref2[1];\n\n    return [lookupIndex, !name || names.some(function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 2),\n          oIndex = _ref4[0],\n          oName = _ref4[1];\n\n      return name === oName && lookupIndex !== oIndex;\n    }) ? null : name];\n  });\n}\n\nfunction extractName(types, id, _ref5) {\n  var params = _ref5.params,\n      path = _ref5.path;\n  var lookupIndex = id.toNumber();\n\n  if (!path.length || WRAPPERS.includes(path[path.length - 1].toString())) {\n    return [lookupIndex, null];\n  }\n\n  var parts = path.map(function (p) {\n    return stringUpperFirst(stringCamelCase(p));\n  }).filter(function (p, index) {\n    return ( // Remove ::{pallet, traits, types}::\n    index !== 1 || !['Pallet', 'Traits', 'Types'].includes(p.toString())) && ( // sp_runtime::generic::digest::Digest -> sp_runtime::generic::Digest\n    // sp_runtime::multiaddress::MultiAddress -> sp_runtime::MultiAddress\n    index === path.length - 1 || p.toLowerCase() !== path[index + 1].toLowerCase());\n  });\n  var typeName = parts.join('');\n\n  if (parts.length === 2 && parts[parts.length - 1] === 'RawOrigin' && params.length === 2 && params[1].type.isSome) {\n    // Do magic for RawOrigin lookup\n    var instanceType = types[params[1].type.unwrap().toNumber()];\n\n    if (instanceType.type.path.length === 2) {\n      typeName = \"\".concat(typeName).concat(instanceType.type.path[1].toString());\n    }\n  }\n\n  return [lookupIndex, typeName];\n}\n\nfunction extractNames(registry, types) {\n  var dedup = removeDuplicateNames(types.map(function (_ref6) {\n    var id = _ref6.id,\n        type = _ref6.type;\n    return extractName(types, id, type);\n  }));\n\n  var _dedup$reduce = dedup.reduce(function (_ref7, _ref8, index) {\n    var _ref9 = _slicedToArray(_ref7, 2),\n        names = _ref9[0],\n        types = _ref9[1];\n\n    var _ref10 = _slicedToArray(_ref8, 2),\n        lookupIndex = _ref10[0],\n        name = _ref10[1];\n\n    if (name) {\n      // We set the name for this specific type\n      names[index] = name; // we map to the actual lookupIndex\n\n      // we map to the actual lookupIndex\n      types[name] = registry.createLookupType(lookupIndex);\n    }\n\n    return [names, types];\n  }, [{}, {}]),\n      _dedup$reduce2 = _slicedToArray(_dedup$reduce, 2),\n      names = _dedup$reduce2[0],\n      typesNew = _dedup$reduce2[1];\n\n  registry.register(typesNew);\n  return names;\n}\n\nvar _names = /*#__PURE__*/_classPrivateFieldLooseKey(\"names\");\n\nvar _typeDefs = /*#__PURE__*/_classPrivateFieldLooseKey(\"typeDefs\");\n\nvar _createSiDef = /*#__PURE__*/_classPrivateFieldLooseKey(\"createSiDef\");\n\nvar _getLookupId = /*#__PURE__*/_classPrivateFieldLooseKey(\"getLookupId\");\n\nvar _extract = /*#__PURE__*/_classPrivateFieldLooseKey(\"extract\");\n\nvar _extractArray = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractArray\");\n\nvar _extractBitSequence = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractBitSequence\");\n\nvar _extractCompact = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractCompact\");\n\nvar _extractComposite = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractComposite\");\n\nvar _extractCompositeSet = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractCompositeSet\");\n\nvar _extractFields = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractFields\");\n\nvar _extractFieldsAlias = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractFieldsAlias\");\n\nvar _extractHistoric = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractHistoric\");\n\nvar _extractPrimitive = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractPrimitive\");\n\nvar _extractPrimitivePath = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractPrimitivePath\");\n\nvar _extractSequence = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractSequence\");\n\nvar _extractTuple = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractTuple\");\n\nvar _extractVariant = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractVariant\");\n\nvar _extractVariantEnum = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractVariantEnum\");\n\nexport var GenericPortableRegistry = /*#__PURE__*/function (_Struct) {\n  _inherits(GenericPortableRegistry, _Struct);\n\n  var _super = _createSuper(GenericPortableRegistry);\n\n  function GenericPortableRegistry(registry, value) {\n    var _this;\n\n    _classCallCheck(this, GenericPortableRegistry);\n\n    _this = _super.call(this, registry, {\n      types: 'Vec<PortableType>'\n    }, value);\n    Object.defineProperty(_assertThisInitialized(_this), _extractVariantEnum, {\n      value: _extractVariantEnum2\n    });\n    Object.defineProperty(_assertThisInitialized(_this), _extractVariant, {\n      value: _extractVariant2\n    });\n    Object.defineProperty(_assertThisInitialized(_this), _extractTuple, {\n      value: _extractTuple2\n    });\n    Object.defineProperty(_assertThisInitialized(_this), _extractSequence, {\n      value: _extractSequence2\n    });\n    Object.defineProperty(_assertThisInitialized(_this), _extractPrimitivePath, {\n      value: _extractPrimitivePath2\n    });\n    Object.defineProperty(_assertThisInitialized(_this), _extractPrimitive, {\n      value: _extractPrimitive2\n    });\n    Object.defineProperty(_assertThisInitialized(_this), _extractHistoric, {\n      value: _extractHistoric2\n    });\n    Object.defineProperty(_assertThisInitialized(_this), _extractFieldsAlias, {\n      value: _extractFieldsAlias2\n    });\n    Object.defineProperty(_assertThisInitialized(_this), _extractFields, {\n      value: _extractFields2\n    });\n    Object.defineProperty(_assertThisInitialized(_this), _extractCompositeSet, {\n      value: _extractCompositeSet2\n    });\n    Object.defineProperty(_assertThisInitialized(_this), _extractComposite, {\n      value: _extractComposite2\n    });\n    Object.defineProperty(_assertThisInitialized(_this), _extractCompact, {\n      value: _extractCompact2\n    });\n    Object.defineProperty(_assertThisInitialized(_this), _extractBitSequence, {\n      value: _extractBitSequence2\n    });\n    Object.defineProperty(_assertThisInitialized(_this), _extractArray, {\n      value: _extractArray2\n    });\n    Object.defineProperty(_assertThisInitialized(_this), _extract, {\n      value: _extract2\n    });\n    Object.defineProperty(_assertThisInitialized(_this), _getLookupId, {\n      value: _getLookupId2\n    });\n    Object.defineProperty(_assertThisInitialized(_this), _createSiDef, {\n      value: _createSiDef2\n    });\n    Object.defineProperty(_assertThisInitialized(_this), _names, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_assertThisInitialized(_this), _typeDefs, {\n      writable: true,\n      value: {}\n    });\n    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _names)[_names] = extractNames(registry, _this.types);\n    return _this;\n  }\n  /**\n   * @description The types of the registry\n   */\n\n\n  _createClass(GenericPortableRegistry, [{\n    key: \"types\",\n    get: function get() {\n      return this.get('types');\n    }\n    /**\n     * @description Finds a specific type in the registry\n     */\n\n  }, {\n    key: \"getSiType\",\n    value: function getSiType(lookupId) {\n      var found = this.types[_classPrivateFieldLooseBase(this, _getLookupId)[_getLookupId](lookupId)];\n\n      assert(found, function () {\n        return \"PortableRegistry: Unable to find type with lookupId \".concat(lookupId.toString());\n      });\n      return found.type;\n    }\n    /**\n     * @description Lookup the type definition for the index\n     */\n\n  }, {\n    key: \"getTypeDef\",\n    value: function getTypeDef(lookupId) {\n      var _this2 = this;\n\n      var lookupIndex = _classPrivateFieldLooseBase(this, _getLookupId)[_getLookupId](lookupId);\n\n      if (!_classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex]) {\n        // we set first since we will get into circular lookups along the way\n        _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex] = {\n          info: TypeDefInfo.DoNotConstruct,\n          lookupIndex: lookupIndex,\n          lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n          type: this.registry.createLookupType(lookupIndex)\n        };\n\n        var extracted = _classPrivateFieldLooseBase(this, _extract)[_extract](this.getSiType(lookupId), lookupIndex);\n\n        Object.keys(extracted).forEach(function (k) {\n          if (k !== 'lookupName' || extracted[k]) {\n            // these are safe since we are looking through the keys as set\n            _classPrivateFieldLooseBase(_this2, _typeDefs)[_typeDefs][lookupIndex][k] = extracted[k];\n          }\n        }); // don't set lookupName on lower-level, we want to always direct to the type\n\n        if (extracted.info === TypeDefInfo.Plain) {\n          _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex].lookupNameRoot = _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex].lookupName;\n          delete _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex].lookupName;\n        }\n      }\n\n      return _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex];\n    }\n  }]);\n\n  return GenericPortableRegistry;\n}(Struct);\n\nfunction _createSiDef2(lookupId) {\n  var typeDef = this.getTypeDef(lookupId);\n  var lookupIndex = lookupId.toNumber(); // Setup for a lookup on complex types\n\n  return [TypeDefInfo.Enum, TypeDefInfo.Struct].includes(typeDef.info) && typeDef.lookupName ? {\n    docs: typeDef.docs,\n    info: TypeDefInfo.Si,\n    lookupIndex: lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n    type: this.registry.createLookupType(lookupId)\n  } : typeDef;\n}\n\nfunction _getLookupId2(lookupId) {\n  if (isString(lookupId)) {\n    assert(this.registry.isLookupType(lookupId), function () {\n      return \"PortableRegistry: Expected a lookup string type, found \".concat(lookupId);\n    });\n    return parseInt(lookupId.replace('Lookup', ''), 10);\n  } else if (isNumber(lookupId)) {\n    return lookupId;\n  }\n\n  return lookupId.toNumber();\n}\n\nfunction _extract2(type, lookupIndex) {\n  var path = _toConsumableArray(type.path);\n\n  var typeDef;\n  var primType = getPrimitivePath(type.path);\n\n  try {\n    if (primType) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractPrimitivePath)[_extractPrimitivePath](lookupIndex, primType);\n    } else if (type.def.isArray) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractArray)[_extractArray](lookupIndex, type.def.asArray);\n    } else if (type.def.isBitSequence) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractBitSequence)[_extractBitSequence](lookupIndex, type.def.asBitSequence);\n    } else if (type.def.isCompact) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractCompact)[_extractCompact](lookupIndex, type.def.asCompact);\n    } else if (type.def.isComposite) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractComposite)[_extractComposite](lookupIndex, type, type.def.asComposite);\n    } else if (type.def.isHistoricMetaCompat) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractHistoric)[_extractHistoric](lookupIndex, type.def.asHistoricMetaCompat);\n    } else if (type.def.isPrimitive) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractPrimitive)[_extractPrimitive](lookupIndex, type);\n    } else if (type.def.isSequence) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractSequence)[_extractSequence](lookupIndex, type.def.asSequence);\n    } else if (type.def.isTuple) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractTuple)[_extractTuple](lookupIndex, type.def.asTuple);\n    } else if (type.def.isVariant) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractVariant)[_extractVariant](lookupIndex, type, type.def.asVariant);\n    } else {\n      throw new Error(\"Invalid type at index \".concat(lookupIndex, \": No handler for \").concat(type.def.toString()));\n    }\n  } catch (error) {\n    throw new Error(\"PortableRegistry: \".concat(lookupIndex, \": Error extracting \").concat(stringify(type), \": \").concat(error.message));\n  }\n\n  return _objectSpread({\n    docs: type.docs.map(function (d) {\n      return d.toString();\n    }),\n    namespace: path.join('::')\n  }, typeDef);\n}\n\nfunction _extractArray2(lookupIndex, _ref11) {\n  var length = _ref11.len,\n      type = _ref11.type;\n  assert(!length || length.toNumber() <= 256, function () {\n    return \"PortableRegistry: \".concat(lookupIndex, \": Only support for [Type; <length>], where length <= 256\");\n  });\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.VecFixed,\n    length: length.toNumber(),\n    sub: _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type)\n  });\n}\n\nfunction _extractBitSequence2(_, _ref12) {\n  var bitOrderType = _ref12.bitOrderType,\n      bitStoreType = _ref12.bitStoreType;\n\n  var bitOrder = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](bitOrderType);\n\n  var bitStore = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](bitStoreType); // NOTE: Currently the BitVec type is one-way only, i.e. we only use it to decode, not\n  // re-encode stuff. As such we ignore the msb/lsb identifier given by bitOrderType, or rather\n  // we don't pass it though at all\n\n\n  assert(['bitvec::order::Lsb0', 'bitvec::order::Msb0'].includes(bitOrder.namespace || ''), function () {\n    return \"Unexpected bitOrder found as \".concat(bitOrder.namespace || '<unknown>');\n  });\n  assert(bitStore.info === TypeDefInfo.Plain && bitStore.type === 'u8', function () {\n    return \"Only u8 bitStore is currently supported, found \".concat(bitStore.type);\n  });\n  return {\n    info: TypeDefInfo.Plain,\n    type: 'BitVec'\n  };\n}\n\nfunction _extractCompact2(_, _ref13) {\n  var type = _ref13.type;\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Compact,\n    sub: _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type)\n  });\n}\n\nfunction _extractComposite2(lookupIndex, _ref14, _ref15) {\n  var _this3 = this;\n\n  var params = _ref14.params,\n      path = _ref14.path;\n  var fields = _ref15.fields;\n\n  if (path.length === 1 && path[0].eq('BTreeMap')) {\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.BTreeMap,\n      sub: params.map(function (_ref16) {\n        var type = _ref16.type;\n        return _classPrivateFieldLooseBase(_this3, _createSiDef)[_createSiDef](type.unwrap());\n      })\n    });\n  }\n\n  return SETS.some(function (p) {\n    return matchParts(p, path);\n  }) ? _classPrivateFieldLooseBase(this, _extractCompositeSet)[_extractCompositeSet](lookupIndex, params, fields) : _classPrivateFieldLooseBase(this, _extractFields)[_extractFields](lookupIndex, fields);\n}\n\nfunction _extractCompositeSet2(lookupIndex, params, fields) {\n  assert(params.length === 1 && fields.length === 1, function () {\n    return \"PortableRegistry: \".concat(lookupIndex, \": Set handling expects since param and single field\");\n  });\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Set,\n    length: this.registry.createType(this.registry.createLookupType(fields[0].type)).bitLength(),\n    sub: this.getSiType(params[0].type.unwrap()).def.asVariant.variants.map(function (_ref17) {\n      var index = _ref17.index,\n          name = _ref17.name;\n      return {\n        // This will be an issue > 2^53 - 1 ... don't have those (yet)\n        index: index.toNumber(),\n        info: TypeDefInfo.Plain,\n        name: name.toString(),\n        type: 'Null'\n      };\n    })\n  });\n}\n\nfunction _extractFields2(lookupIndex, fields) {\n  var _fields$reduce = fields.reduce(function (_ref18, _ref19) {\n    var _ref20 = _slicedToArray(_ref18, 2),\n        isAllNamed = _ref20[0],\n        isAllUnnamed = _ref20[1];\n\n    var name = _ref19.name;\n    return [isAllNamed && name.isSome, isAllUnnamed && name.isNone];\n  }, [true, true]),\n      _fields$reduce2 = _slicedToArray(_fields$reduce, 2),\n      isStruct = _fields$reduce2[0],\n      isTuple = _fields$reduce2[1];\n\n  assert(isTuple || isStruct, function () {\n    return \"PortableRegistry: \".concat(lookupIndex, \": Invalid fields type detected, expected either Tuple (all unnamed) or Struct (all named)\");\n  });\n\n  if (fields.length === 0) {\n    return {\n      info: TypeDefInfo.Null,\n      type: 'Null'\n    };\n  } else if (isTuple && fields.length === 1) {\n    var typeDef = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](fields[0].type);\n\n    return _objectSpread(_objectSpread({}, typeDef), lookupIndex === -1 ? {} : {\n      lookupIndex: lookupIndex,\n      lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n      lookupNameRoot: typeDef.lookupName\n    });\n  }\n\n  var _classPrivateFieldLoo = _classPrivateFieldLooseBase(this, _extractFieldsAlias)[_extractFieldsAlias](fields),\n      _classPrivateFieldLoo2 = _slicedToArray(_classPrivateFieldLoo, 2),\n      sub = _classPrivateFieldLoo2[0],\n      alias = _classPrivateFieldLoo2[1];\n\n  return withTypeString(this.registry, _objectSpread(_objectSpread(_objectSpread({\n    info: isTuple // Tuple check first\n    ? TypeDefInfo.Tuple : TypeDefInfo.Struct\n  }, alias.size ? {\n    alias: alias\n  } : {}), lookupIndex === -1 ? {} : {\n    lookupIndex: lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex]\n  }), {}, {\n    sub: sub\n  }));\n}\n\nfunction _extractFieldsAlias2(fields) {\n  var _this4 = this;\n\n  var alias = new Map();\n  var sub = fields.map(function (_ref21) {\n    var docs = _ref21.docs,\n        name = _ref21.name,\n        type = _ref21.type;\n\n    var typeDef = _classPrivateFieldLooseBase(_this4, _createSiDef)[_createSiDef](type);\n\n    if (name.isNone) {\n      return typeDef;\n    }\n\n    var nameField = stringCamelCase(name.unwrap());\n    var nameOrig = null;\n\n    if (nameField.includes('#')) {\n      nameOrig = nameField;\n      nameField = nameOrig.replace(/#/g, '_');\n    } else if (RESERVED.includes(nameField)) {\n      nameOrig = nameField;\n      nameField = \"\".concat(nameField, \"_\");\n    }\n\n    if (nameOrig) {\n      alias.set(nameField, nameOrig);\n    }\n\n    return _objectSpread(_objectSpread({}, typeDef), {}, {\n      docs: docs.map(function (d) {\n        return d.toString();\n      }),\n      name: nameField\n    });\n  });\n  return [sub, alias];\n}\n\nfunction _extractHistoric2(_, type) {\n  return _objectSpread(_objectSpread({}, getTypeDef(type)), {}, {\n    displayName: type.toString(),\n    isFromSi: true\n  });\n}\n\nfunction _extractPrimitive2(_, type) {\n  var typeStr = type.def.asPrimitive.type.toString();\n  return {\n    info: TypeDefInfo.Plain,\n    type: PRIMITIVE_ALIAS[typeStr] || typeStr.toLowerCase()\n  };\n}\n\nfunction _extractPrimitivePath2(_, type) {\n  return {\n    info: TypeDefInfo.Plain,\n    type: type\n  };\n}\n\nfunction _extractSequence2(lookupIndex, _ref22) {\n  var type = _ref22.type;\n\n  var sub = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type);\n\n  if (sub.type === 'u8') {\n    return {\n      info: TypeDefInfo.Plain,\n      type: 'Bytes'\n    };\n  }\n\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Vec,\n    lookupIndex: lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n    sub: sub\n  });\n}\n\nfunction _extractTuple2(lookupIndex, ids) {\n  var _this5 = this;\n\n  if (ids.length === 0) {\n    return {\n      info: TypeDefInfo.Null,\n      type: 'Null'\n    };\n  } else if (ids.length === 1) {\n    return this.getTypeDef(ids[0]);\n  }\n\n  var sub = ids.map(function (type) {\n    return _classPrivateFieldLooseBase(_this5, _createSiDef)[_createSiDef](type);\n  });\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Tuple,\n    lookupIndex: lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n    sub: sub\n  });\n}\n\nfunction _extractVariant2(lookupIndex, _ref23, _ref24) {\n  var _this6 = this;\n\n  var params = _ref23.params,\n      path = _ref23.path;\n  var variants = _ref24.variants;\n  var specialVariant = path[0].toString();\n\n  if (specialVariant === 'Option') {\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.Option,\n      sub: _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](params[0].type.unwrap())\n    });\n  } else if (specialVariant === 'Result') {\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.Result,\n      sub: params.map(function (_ref25) {\n        var type = _ref25.type;\n        return _classPrivateFieldLooseBase(_this6, _createSiDef)[_createSiDef](type.unwrap());\n      }).map(function (def, index) {\n        return _objectSpread({\n          name: ['Ok', 'Error'][index]\n        }, def);\n      })\n    });\n  } else if (variants.length === 0) {\n    return {\n      info: TypeDefInfo.Null,\n      type: 'Null'\n    };\n  }\n\n  return _classPrivateFieldLooseBase(this, _extractVariantEnum)[_extractVariantEnum](lookupIndex, variants);\n}\n\nfunction _extractVariantEnum2(lookupIndex, variants) {\n  var _this7 = this;\n\n  var sub = []; // we may get entries out of order, arrange them first before creating with gaps filled\n  // NOTE: Since we mutate, use a copy of the array as an input\n\n  _toConsumableArray(variants).sort(function (a, b) {\n    return a.index.cmp(b.index);\n  }).forEach(function (_ref26) {\n    var fields = _ref26.fields,\n        index = _ref26.index,\n        name = _ref26.name;\n    var desired = index.toNumber();\n\n    while (sub.length !== desired) {\n      sub.push({\n        index: sub.length,\n        info: TypeDefInfo.Null,\n        name: \"Unused\".concat(sub.length),\n        type: 'Null'\n      });\n    }\n\n    sub.push(_objectSpread(_objectSpread({}, _classPrivateFieldLooseBase(_this7, _extractFields)[_extractFields](-1, fields)), {}, {\n      index: index.toNumber(),\n      name: name.toString()\n    }));\n  });\n\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Enum,\n    lookupIndex: lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n    sub: sub\n  });\n}","map":{"version":3,"sources":["/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/@polkadot/types/generic/PortableRegistry.js"],"names":["_defineProperty","_classPrivateFieldLooseBase","_classPrivateFieldLooseKey","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","assert","isNumber","isString","stringCamelCase","stringify","stringUpperFirst","Struct","withTypeString","getTypeDef","TypeDefInfo","PRIMITIVE_ALIAS","Char","Str","PRIMITIVE_PATHS","map","p","split","SETS","WRAPPERS","RESERVED","matchParts","first","second","every","a","index","b","toString","includes","getPrimitivePath","path","some","removeDuplicateNames","names","lookupIndex","name","oIndex","oName","extractName","types","id","params","toNumber","parts","toLowerCase","typeName","join","type","isSome","instanceType","unwrap","extractNames","registry","dedup","reduce","createLookupType","typesNew","register","_names","_typeDefs","_createSiDef","_getLookupId","_extract","_extractArray","_extractBitSequence","_extractCompact","_extractComposite","_extractCompositeSet","_extractFields","_extractFieldsAlias","_extractHistoric","_extractPrimitive","_extractPrimitivePath","_extractSequence","_extractTuple","_extractVariant","_extractVariantEnum","GenericPortableRegistry","value","_extractVariantEnum2","_extractVariant2","_extractTuple2","_extractSequence2","_extractPrimitivePath2","_extractPrimitive2","_extractHistoric2","_extractFieldsAlias2","_extractFields2","_extractCompositeSet2","_extractComposite2","_extractCompact2","_extractBitSequence2","_extractArray2","_extract2","_getLookupId2","_createSiDef2","writable","get","lookupId","found","info","DoNotConstruct","lookupName","extracted","getSiType","k","Plain","lookupNameRoot","typeDef","Enum","docs","Si","isLookupType","parseInt","replace","primType","def","isArray","asArray","isBitSequence","asBitSequence","isCompact","asCompact","isComposite","asComposite","isHistoricMetaCompat","asHistoricMetaCompat","isPrimitive","isSequence","asSequence","isTuple","asTuple","isVariant","asVariant","Error","error","message","d","namespace","len","VecFixed","sub","_","bitOrderType","bitStoreType","bitOrder","bitStore","Compact","fields","eq","BTreeMap","Set","createType","bitLength","variants","isAllNamed","isAllUnnamed","isNone","isStruct","Null","alias","Tuple","size","Map","nameField","nameOrig","set","displayName","isFromSi","typeStr","asPrimitive","Vec","ids","specialVariant","Option","Result","sort","cmp","desired"],"mappings":";;;;;;;AAAA,OAAOA,eAAP,MAA4B,2CAA5B;AACA,OAAOC,2BAAP,MAAwC,uDAAxC;AACA,OAAOC,0BAAP,MAAuC,sDAAvC;;AAEA,SAASC,OAAT,CAAiBC,MAAjB,EAAyBC,cAAzB,EAAyC;AAAE,MAAIC,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYF,MAAZ,CAAX;;AAAgC,MAAIG,MAAM,CAACC,qBAAX,EAAkC;AAAE,QAAIC,OAAO,GAAGF,MAAM,CAACC,qBAAP,CAA6BJ,MAA7B,CAAd;;AAAoD,QAAIC,cAAJ,EAAoB;AAAEI,MAAAA,OAAO,GAAGA,OAAO,CAACC,MAAR,CAAe,UAAUC,GAAV,EAAe;AAAE,eAAOJ,MAAM,CAACK,wBAAP,CAAgCR,MAAhC,EAAwCO,GAAxC,EAA6CE,UAApD;AAAiE,OAAjG,CAAV;AAA+G;;AAACP,IAAAA,IAAI,CAACQ,IAAL,CAAUC,KAAV,CAAgBT,IAAhB,EAAsBG,OAAtB;AAAiC;;AAAC,SAAOH,IAAP;AAAc;;AAEzV,SAASU,aAAT,CAAuBC,MAAvB,EAA+B;AAAE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,SAAS,CAACC,MAA9B,EAAsCF,CAAC,EAAvC,EAA2C;AAAE,QAAIG,MAAM,GAAGF,SAAS,CAACD,CAAD,CAAT,IAAgB,IAAhB,GAAuBC,SAAS,CAACD,CAAD,CAAhC,GAAsC,EAAnD;;AAAuD,QAAIA,CAAC,GAAG,CAAR,EAAW;AAAEf,MAAAA,OAAO,CAACI,MAAM,CAACc,MAAD,CAAP,EAAiB,IAAjB,CAAP,CAA8BC,OAA9B,CAAsC,UAAUC,GAAV,EAAe;AAAEvB,QAAAA,eAAe,CAACiB,MAAD,EAASM,GAAT,EAAcF,MAAM,CAACE,GAAD,CAApB,CAAf;AAA4C,OAAnG;AAAuG,KAApH,MAA0H,IAAIhB,MAAM,CAACiB,yBAAX,EAAsC;AAAEjB,MAAAA,MAAM,CAACkB,gBAAP,CAAwBR,MAAxB,EAAgCV,MAAM,CAACiB,yBAAP,CAAiCH,MAAjC,CAAhC;AAA4E,KAApH,MAA0H;AAAElB,MAAAA,OAAO,CAACI,MAAM,CAACc,MAAD,CAAP,CAAP,CAAwBC,OAAxB,CAAgC,UAAUC,GAAV,EAAe;AAAEhB,QAAAA,MAAM,CAACmB,cAAP,CAAsBT,MAAtB,EAA8BM,GAA9B,EAAmChB,MAAM,CAACK,wBAAP,CAAgCS,MAAhC,EAAwCE,GAAxC,CAAnC;AAAmF,OAApI;AAAwI;AAAE;;AAAC,SAAON,MAAP;AAAgB,C,CAEthB;AACA;;;AACA,SAASU,MAAT,EAAiBC,QAAjB,EAA2BC,QAA3B,EAAqCC,eAArC,EAAsDC,SAAtD,EAAiEC,gBAAjE,QAAyF,gBAAzF;AACA,SAASC,MAAT,QAAuB,oBAAvB;AACA,SAASC,cAAT,QAA+B,0BAA/B;AACA,SAASC,UAAT,QAA2B,yBAA3B;AACA,SAASC,WAAT,QAA4B,mBAA5B,C,CAAiD;;AAEjD,IAAMC,eAAe,GAAG;AACtBC,EAAAA,IAAI,EAAE,KADgB;AAEtB;AACAC,EAAAA,GAAG,EAAE;AAHiB,CAAxB,C,CAIG;;AAEH,IAAMC,eAAe,GAAG,CAAC;AACzB,iBADwB,EACL,kBADK,EACe;AACvC,8BAFwB,EAEQ,8BAFR,EAEwC;AAChE,8BAHwB,EAGQ,+BAHR,EAGyC,wCAHzC,EAGmF;AAC3G,oBAJwB,EAIF,8BAJE,EAI8B;AACtD,mBALwB,EAKHC,GALG,CAKC,UAAAC,CAAC;AAAA,SAAIA,CAAC,CAACC,KAAF,CAAQ,IAAR,CAAJ;AAAA,CALF,CAAxB,C,CAK8C;;AAE9C,IAAMC,IAAI,GAAG,CAAC,kCAAD,EAAqCH,GAArC,CAAyC,UAAAC,CAAC;AAAA,SAAIA,CAAC,CAACC,KAAF,CAAQ,IAAR,CAAJ;AAAA,CAA1C,CAAb,C,CAA2E;;AAE3E,IAAME,QAAQ,GAAG,CAAC,iBAAD,EAAoB,YAApB,EAAkC,KAAlC,EAAyC,UAAzC,EAAqD,KAArD,EAA4D,QAA5D,EAAsE,QAAtE,EAAgF,gBAAhF,CAAjB,C,CAAoH;;AAEpH,IAAMC,QAAQ,GAAG,CAAC,MAAD,EAAS,SAAT,EAAoB,MAApB,EAA4B,MAA5B,EAAoC,KAApC,EAA2C,MAA3C,CAAjB;;AAEA,SAASC,UAAT,CAAoBC,KAApB,EAA2BC,MAA3B,EAAmC;AACjC,SAAOD,KAAK,CAAC5B,MAAN,KAAiB6B,MAAM,CAAC7B,MAAxB,IAAkC4B,KAAK,CAACE,KAAN,CAAY,UAACC,CAAD,EAAIC,KAAJ,EAAc;AACjE,QAAMC,CAAC,GAAGJ,MAAM,CAACG,KAAD,CAAN,CAAcE,QAAd,EAAV;AACA,WAAOH,CAAC,KAAK,GAAN,IAAaA,CAAC,KAAKE,CAAnB,IAAwBF,CAAC,CAACI,QAAF,CAAW,GAAX,KAAmBJ,CAAC,CAACI,QAAF,CAAW,GAAX,CAAnB,IAAsCF,CAAC,CAACE,QAAF,CAAW,GAAX,CAAtC,IAAyDR,UAAU,CAACI,CAAC,CAACR,KAAF,CAAQ,GAAR,CAAD,EAAeU,CAAC,CAACV,KAAF,CAAQ,GAAR,CAAf,CAAlG;AACD,GAHwC,CAAzC;AAID,C,CAAC;;;AAGF,SAASa,gBAAT,CAA0BC,IAA1B,EAAgC;AAC9B;AACA,SAAOA,IAAI,CAACrC,MAAL,IAAeoB,eAAe,CAACkB,IAAhB,CAAqB,UAAAhB,CAAC;AAAA,WAAIK,UAAU,CAACL,CAAD,EAAIe,IAAJ,CAAd;AAAA,GAAtB,CAAf,GAAgEA,IAAI,CAACA,IAAI,CAACrC,MAAL,GAAc,CAAf,CAAJ,CAAsBkC,QAAtB,EAAhE,GAAmG,IAA1G;AACD;;AAED,SAASK,oBAAT,CAA8BC,KAA9B,EAAqC;AACnC,SAAOA,KAAK,CAACnB,GAAN,CAAU;AAAA;AAAA,QAAEoB,WAAF;AAAA,QAAeC,IAAf;;AAAA,WAAyB,CAACD,WAAD,EAAc,CAACC,IAAD,IAASF,KAAK,CAACF,IAAN,CAAW;AAAA;AAAA,UAAEK,MAAF;AAAA,UAAUC,KAAV;;AAAA,aAAqBF,IAAI,KAAKE,KAAT,IAAkBH,WAAW,KAAKE,MAAvD;AAAA,KAAX,CAAT,GAAqF,IAArF,GAA4FD,IAA1G,CAAzB;AAAA,GAAV,CAAP;AACD;;AAED,SAASG,WAAT,CAAqBC,KAArB,EAA4BC,EAA5B,SAGG;AAAA,MAFDC,MAEC,SAFDA,MAEC;AAAA,MADDX,IACC,SADDA,IACC;AACD,MAAMI,WAAW,GAAGM,EAAE,CAACE,QAAH,EAApB;;AAEA,MAAI,CAACZ,IAAI,CAACrC,MAAN,IAAgByB,QAAQ,CAACU,QAAT,CAAkBE,IAAI,CAACA,IAAI,CAACrC,MAAL,GAAc,CAAf,CAAJ,CAAsBkC,QAAtB,EAAlB,CAApB,EAAyE;AACvE,WAAO,CAACO,WAAD,EAAc,IAAd,CAAP;AACD;;AAED,MAAMS,KAAK,GAAGb,IAAI,CAAChB,GAAL,CAAS,UAAAC,CAAC;AAAA,WAAIV,gBAAgB,CAACF,eAAe,CAACY,CAAD,CAAhB,CAApB;AAAA,GAAV,EAAoDhC,MAApD,CAA2D,UAACgC,CAAD,EAAIU,KAAJ;AAAA,WAAc,EAAE;AACzFA,IAAAA,KAAK,KAAK,CAAV,IAAe,CAAC,CAAC,QAAD,EAAW,QAAX,EAAqB,OAArB,EAA8BG,QAA9B,CAAuCb,CAAC,CAACY,QAAF,EAAvC,CADuE,OACZ;AAC3E;AACAF,IAAAA,KAAK,KAAKK,IAAI,CAACrC,MAAL,GAAc,CAAxB,IAA6BsB,CAAC,CAAC6B,WAAF,OAAoBd,IAAI,CAACL,KAAK,GAAG,CAAT,CAAJ,CAAgBmB,WAAhB,EAHsC,CAAd;AAAA,GAA3D,CAAd;AAIA,MAAIC,QAAQ,GAAGF,KAAK,CAACG,IAAN,CAAW,EAAX,CAAf;;AAEA,MAAIH,KAAK,CAAClD,MAAN,KAAiB,CAAjB,IAAsBkD,KAAK,CAACA,KAAK,CAAClD,MAAN,GAAe,CAAhB,CAAL,KAA4B,WAAlD,IAAiEgD,MAAM,CAAChD,MAAP,KAAkB,CAAnF,IAAwFgD,MAAM,CAAC,CAAD,CAAN,CAAUM,IAAV,CAAeC,MAA3G,EAAmH;AACjH;AACA,QAAMC,YAAY,GAAGV,KAAK,CAACE,MAAM,CAAC,CAAD,CAAN,CAAUM,IAAV,CAAeG,MAAf,GAAwBR,QAAxB,EAAD,CAA1B;;AAEA,QAAIO,YAAY,CAACF,IAAb,CAAkBjB,IAAlB,CAAuBrC,MAAvB,KAAkC,CAAtC,EAAyC;AACvCoD,MAAAA,QAAQ,aAAMA,QAAN,SAAiBI,YAAY,CAACF,IAAb,CAAkBjB,IAAlB,CAAuB,CAAvB,EAA0BH,QAA1B,EAAjB,CAAR;AACD;AACF;;AAED,SAAO,CAACO,WAAD,EAAcW,QAAd,CAAP;AACD;;AAED,SAASM,YAAT,CAAsBC,QAAtB,EAAgCb,KAAhC,EAAuC;AACrC,MAAMc,KAAK,GAAGrB,oBAAoB,CAACO,KAAK,CAACzB,GAAN,CAAU;AAAA,QAC3C0B,EAD2C,SAC3CA,EAD2C;AAAA,QAE3CO,IAF2C,SAE3CA,IAF2C;AAAA,WAGvCT,WAAW,CAACC,KAAD,EAAQC,EAAR,EAAYO,IAAZ,CAH4B;AAAA,GAAV,CAAD,CAAlC;;AAIA,sBAA0BM,KAAK,CAACC,MAAN,CAAa,wBAAsC7B,KAAtC,EAAgD;AAAA;AAAA,QAA9CQ,KAA8C;AAAA,QAAvCM,KAAuC;;AAAA;AAAA,QAA9BL,WAA8B;AAAA,QAAjBC,IAAiB;;AACrF,QAAIA,IAAJ,EAAU;AACR;AACAF,MAAAA,KAAK,CAACR,KAAD,CAAL,GAAeU,IAAf,CAFQ,CAEa;;AAAA;AAErBI,MAAAA,KAAK,CAACJ,IAAD,CAAL,GAAciB,QAAQ,CAACG,gBAAT,CAA0BrB,WAA1B,CAAd;AACD;;AAED,WAAO,CAACD,KAAD,EAAQM,KAAR,CAAP;AACD,GATyB,EASvB,CAAC,EAAD,EAAK,EAAL,CATuB,CAA1B;AAAA;AAAA,MAAON,KAAP;AAAA,MAAcuB,QAAd;;AAUAJ,EAAAA,QAAQ,CAACK,QAAT,CAAkBD,QAAlB;AACA,SAAOvB,KAAP;AACD;;AAED,IAAIyB,MAAM,GAAG,aAAanF,0BAA0B,CAAC,OAAD,CAApD;;AAEA,IAAIoF,SAAS,GAAG,aAAapF,0BAA0B,CAAC,UAAD,CAAvD;;AAEA,IAAIqF,YAAY,GAAG,aAAarF,0BAA0B,CAAC,aAAD,CAA1D;;AAEA,IAAIsF,YAAY,GAAG,aAAatF,0BAA0B,CAAC,aAAD,CAA1D;;AAEA,IAAIuF,QAAQ,GAAG,aAAavF,0BAA0B,CAAC,SAAD,CAAtD;;AAEA,IAAIwF,aAAa,GAAG,aAAaxF,0BAA0B,CAAC,cAAD,CAA3D;;AAEA,IAAIyF,mBAAmB,GAAG,aAAazF,0BAA0B,CAAC,oBAAD,CAAjE;;AAEA,IAAI0F,eAAe,GAAG,aAAa1F,0BAA0B,CAAC,gBAAD,CAA7D;;AAEA,IAAI2F,iBAAiB,GAAG,aAAa3F,0BAA0B,CAAC,kBAAD,CAA/D;;AAEA,IAAI4F,oBAAoB,GAAG,aAAa5F,0BAA0B,CAAC,qBAAD,CAAlE;;AAEA,IAAI6F,cAAc,GAAG,aAAa7F,0BAA0B,CAAC,eAAD,CAA5D;;AAEA,IAAI8F,mBAAmB,GAAG,aAAa9F,0BAA0B,CAAC,oBAAD,CAAjE;;AAEA,IAAI+F,gBAAgB,GAAG,aAAa/F,0BAA0B,CAAC,iBAAD,CAA9D;;AAEA,IAAIgG,iBAAiB,GAAG,aAAahG,0BAA0B,CAAC,kBAAD,CAA/D;;AAEA,IAAIiG,qBAAqB,GAAG,aAAajG,0BAA0B,CAAC,sBAAD,CAAnE;;AAEA,IAAIkG,gBAAgB,GAAG,aAAalG,0BAA0B,CAAC,iBAAD,CAA9D;;AAEA,IAAImG,aAAa,GAAG,aAAanG,0BAA0B,CAAC,cAAD,CAA3D;;AAEA,IAAIoG,eAAe,GAAG,aAAapG,0BAA0B,CAAC,gBAAD,CAA7D;;AAEA,IAAIqG,mBAAmB,GAAG,aAAarG,0BAA0B,CAAC,oBAAD,CAAjE;;AAEA,WAAasG,uBAAb;AAAA;;AAAA;;AACE,mCAAYzB,QAAZ,EAAsB0B,KAAtB,EAA6B;AAAA;;AAAA;;AAC3B,8BAAM1B,QAAN,EAAgB;AACdb,MAAAA,KAAK,EAAE;AADO,KAAhB,EAEGuC,KAFH;AAGAlG,IAAAA,MAAM,CAACmB,cAAP,gCAA4B6E,mBAA5B,EAAiD;AAC/CE,MAAAA,KAAK,EAAEC;AADwC,KAAjD;AAGAnG,IAAAA,MAAM,CAACmB,cAAP,gCAA4B4E,eAA5B,EAA6C;AAC3CG,MAAAA,KAAK,EAAEE;AADoC,KAA7C;AAGApG,IAAAA,MAAM,CAACmB,cAAP,gCAA4B2E,aAA5B,EAA2C;AACzCI,MAAAA,KAAK,EAAEG;AADkC,KAA3C;AAGArG,IAAAA,MAAM,CAACmB,cAAP,gCAA4B0E,gBAA5B,EAA8C;AAC5CK,MAAAA,KAAK,EAAEI;AADqC,KAA9C;AAGAtG,IAAAA,MAAM,CAACmB,cAAP,gCAA4ByE,qBAA5B,EAAmD;AACjDM,MAAAA,KAAK,EAAEK;AAD0C,KAAnD;AAGAvG,IAAAA,MAAM,CAACmB,cAAP,gCAA4BwE,iBAA5B,EAA+C;AAC7CO,MAAAA,KAAK,EAAEM;AADsC,KAA/C;AAGAxG,IAAAA,MAAM,CAACmB,cAAP,gCAA4BuE,gBAA5B,EAA8C;AAC5CQ,MAAAA,KAAK,EAAEO;AADqC,KAA9C;AAGAzG,IAAAA,MAAM,CAACmB,cAAP,gCAA4BsE,mBAA5B,EAAiD;AAC/CS,MAAAA,KAAK,EAAEQ;AADwC,KAAjD;AAGA1G,IAAAA,MAAM,CAACmB,cAAP,gCAA4BqE,cAA5B,EAA4C;AAC1CU,MAAAA,KAAK,EAAES;AADmC,KAA5C;AAGA3G,IAAAA,MAAM,CAACmB,cAAP,gCAA4BoE,oBAA5B,EAAkD;AAChDW,MAAAA,KAAK,EAAEU;AADyC,KAAlD;AAGA5G,IAAAA,MAAM,CAACmB,cAAP,gCAA4BmE,iBAA5B,EAA+C;AAC7CY,MAAAA,KAAK,EAAEW;AADsC,KAA/C;AAGA7G,IAAAA,MAAM,CAACmB,cAAP,gCAA4BkE,eAA5B,EAA6C;AAC3Ca,MAAAA,KAAK,EAAEY;AADoC,KAA7C;AAGA9G,IAAAA,MAAM,CAACmB,cAAP,gCAA4BiE,mBAA5B,EAAiD;AAC/Cc,MAAAA,KAAK,EAAEa;AADwC,KAAjD;AAGA/G,IAAAA,MAAM,CAACmB,cAAP,gCAA4BgE,aAA5B,EAA2C;AACzCe,MAAAA,KAAK,EAAEc;AADkC,KAA3C;AAGAhH,IAAAA,MAAM,CAACmB,cAAP,gCAA4B+D,QAA5B,EAAsC;AACpCgB,MAAAA,KAAK,EAAEe;AAD6B,KAAtC;AAGAjH,IAAAA,MAAM,CAACmB,cAAP,gCAA4B8D,YAA5B,EAA0C;AACxCiB,MAAAA,KAAK,EAAEgB;AADiC,KAA1C;AAGAlH,IAAAA,MAAM,CAACmB,cAAP,gCAA4B6D,YAA5B,EAA0C;AACxCkB,MAAAA,KAAK,EAAEiB;AADiC,KAA1C;AAGAnH,IAAAA,MAAM,CAACmB,cAAP,gCAA4B2D,MAA5B,EAAoC;AAClCsC,MAAAA,QAAQ,EAAE,IADwB;AAElClB,MAAAA,KAAK,EAAE,KAAK;AAFsB,KAApC;AAIAlG,IAAAA,MAAM,CAACmB,cAAP,gCAA4B4D,SAA5B,EAAuC;AACrCqC,MAAAA,QAAQ,EAAE,IAD2B;AAErClB,MAAAA,KAAK,EAAE;AAF8B,KAAvC;AAIAxG,IAAAA,2BAA2B,gCAAOoF,MAAP,CAA3B,CAA0CA,MAA1C,IAAoDP,YAAY,CAACC,QAAD,EAAW,MAAKb,KAAhB,CAAhE;AA/D2B;AAgE5B;AACD;AACF;AACA;;;AApEA;AAAA;AAAA,SAuEE,eAAY;AACV,aAAO,KAAK0D,GAAL,CAAS,OAAT,CAAP;AACD;AACD;AACF;AACA;;AA5EA;AAAA;AAAA,WA+EE,mBAAUC,QAAV,EAAoB;AAClB,UAAMC,KAAK,GAAG,KAAK5D,KAAL,CAAWjE,2BAA2B,CAAC,IAAD,EAAOuF,YAAP,CAA3B,CAAgDA,YAAhD,EAA8DqC,QAA9D,CAAX,CAAd;;AAEAlG,MAAAA,MAAM,CAACmG,KAAD,EAAQ;AAAA,6EAA6DD,QAAQ,CAACvE,QAAT,EAA7D;AAAA,OAAR,CAAN;AACA,aAAOwE,KAAK,CAACpD,IAAb;AACD;AACD;AACF;AACA;;AAvFA;AAAA;AAAA,WA0FE,oBAAWmD,QAAX,EAAqB;AAAA;;AACnB,UAAMhE,WAAW,GAAG5D,2BAA2B,CAAC,IAAD,EAAOuF,YAAP,CAA3B,CAAgDA,YAAhD,EAA8DqC,QAA9D,CAApB;;AAEA,UAAI,CAAC5H,2BAA2B,CAAC,IAAD,EAAOqF,SAAP,CAA3B,CAA6CA,SAA7C,EAAwDzB,WAAxD,CAAL,EAA2E;AACzE;AACA5D,QAAAA,2BAA2B,CAAC,IAAD,EAAOqF,SAAP,CAA3B,CAA6CA,SAA7C,EAAwDzB,WAAxD,IAAuE;AACrEkE,UAAAA,IAAI,EAAE3F,WAAW,CAAC4F,cADmD;AAErEnE,UAAAA,WAAW,EAAXA,WAFqE;AAGrEoE,UAAAA,UAAU,EAAEhI,2BAA2B,CAAC,IAAD,EAAOoF,MAAP,CAA3B,CAA0CA,MAA1C,EAAkDxB,WAAlD,CAHyD;AAIrEa,UAAAA,IAAI,EAAE,KAAKK,QAAL,CAAcG,gBAAd,CAA+BrB,WAA/B;AAJ+D,SAAvE;;AAOA,YAAMqE,SAAS,GAAGjI,2BAA2B,CAAC,IAAD,EAAOwF,QAAP,CAA3B,CAA4CA,QAA5C,EAAsD,KAAK0C,SAAL,CAAeN,QAAf,CAAtD,EAAgFhE,WAAhF,CAAlB;;AAEAtD,QAAAA,MAAM,CAACD,IAAP,CAAY4H,SAAZ,EAAuB5G,OAAvB,CAA+B,UAAA8G,CAAC,EAAI;AAClC,cAAIA,CAAC,KAAK,YAAN,IAAsBF,SAAS,CAACE,CAAD,CAAnC,EAAwC;AACtC;AACAnI,YAAAA,2BAA2B,CAAC,MAAD,EAAOqF,SAAP,CAA3B,CAA6CA,SAA7C,EAAwDzB,WAAxD,EAAqEuE,CAArE,IAA0EF,SAAS,CAACE,CAAD,CAAnF;AACD;AACF,SALD,EAXyE,CAgBrE;;AAEJ,YAAIF,SAAS,CAACH,IAAV,KAAmB3F,WAAW,CAACiG,KAAnC,EAA0C;AACxCpI,UAAAA,2BAA2B,CAAC,IAAD,EAAOqF,SAAP,CAA3B,CAA6CA,SAA7C,EAAwDzB,WAAxD,EAAqEyE,cAArE,GAAsFrI,2BAA2B,CAAC,IAAD,EAAOqF,SAAP,CAA3B,CAA6CA,SAA7C,EAAwDzB,WAAxD,EAAqEoE,UAA3J;AACA,iBAAOhI,2BAA2B,CAAC,IAAD,EAAOqF,SAAP,CAA3B,CAA6CA,SAA7C,EAAwDzB,WAAxD,EAAqEoE,UAA5E;AACD;AACF;;AAED,aAAOhI,2BAA2B,CAAC,IAAD,EAAOqF,SAAP,CAA3B,CAA6CA,SAA7C,EAAwDzB,WAAxD,CAAP;AACD;AAtHH;;AAAA;AAAA,EAA6C5B,MAA7C;;AA0HA,SAASyF,aAAT,CAAuBG,QAAvB,EAAiC;AAC/B,MAAMU,OAAO,GAAG,KAAKpG,UAAL,CAAgB0F,QAAhB,CAAhB;AACA,MAAMhE,WAAW,GAAGgE,QAAQ,CAACxD,QAAT,EAApB,CAF+B,CAEU;;AAEzC,SAAO,CAACjC,WAAW,CAACoG,IAAb,EAAmBpG,WAAW,CAACH,MAA/B,EAAuCsB,QAAvC,CAAgDgF,OAAO,CAACR,IAAxD,KAAiEQ,OAAO,CAACN,UAAzE,GAAsF;AAC3FQ,IAAAA,IAAI,EAAEF,OAAO,CAACE,IAD6E;AAE3FV,IAAAA,IAAI,EAAE3F,WAAW,CAACsG,EAFyE;AAG3F7E,IAAAA,WAAW,EAAXA,WAH2F;AAI3FoE,IAAAA,UAAU,EAAEhI,2BAA2B,CAAC,IAAD,EAAOoF,MAAP,CAA3B,CAA0CA,MAA1C,EAAkDxB,WAAlD,CAJ+E;AAK3Fa,IAAAA,IAAI,EAAE,KAAKK,QAAL,CAAcG,gBAAd,CAA+B2C,QAA/B;AALqF,GAAtF,GAMHU,OANJ;AAOD;;AAED,SAASd,aAAT,CAAuBI,QAAvB,EAAiC;AAC/B,MAAIhG,QAAQ,CAACgG,QAAD,CAAZ,EAAwB;AACtBlG,IAAAA,MAAM,CAAC,KAAKoD,QAAL,CAAc4D,YAAd,CAA2Bd,QAA3B,CAAD,EAAuC;AAAA,8EAAgEA,QAAhE;AAAA,KAAvC,CAAN;AACA,WAAOe,QAAQ,CAACf,QAAQ,CAACgB,OAAT,CAAiB,QAAjB,EAA2B,EAA3B,CAAD,EAAiC,EAAjC,CAAf;AACD,GAHD,MAGO,IAAIjH,QAAQ,CAACiG,QAAD,CAAZ,EAAwB;AAC7B,WAAOA,QAAP;AACD;;AAED,SAAOA,QAAQ,CAACxD,QAAT,EAAP;AACD;;AAED,SAASmD,SAAT,CAAmB9C,IAAnB,EAAyBb,WAAzB,EAAsC;AACpC,MAAMJ,IAAI,sBAAOiB,IAAI,CAACjB,IAAZ,CAAV;;AACA,MAAI8E,OAAJ;AACA,MAAMO,QAAQ,GAAGtF,gBAAgB,CAACkB,IAAI,CAACjB,IAAN,CAAjC;;AAEA,MAAI;AACF,QAAIqF,QAAJ,EAAc;AACZP,MAAAA,OAAO,GAAGtI,2BAA2B,CAAC,IAAD,EAAOkG,qBAAP,CAA3B,CAAyDA,qBAAzD,EAAgFtC,WAAhF,EAA6FiF,QAA7F,CAAV;AACD,KAFD,MAEO,IAAIpE,IAAI,CAACqE,GAAL,CAASC,OAAb,EAAsB;AAC3BT,MAAAA,OAAO,GAAGtI,2BAA2B,CAAC,IAAD,EAAOyF,aAAP,CAA3B,CAAiDA,aAAjD,EAAgE7B,WAAhE,EAA6Ea,IAAI,CAACqE,GAAL,CAASE,OAAtF,CAAV;AACD,KAFM,MAEA,IAAIvE,IAAI,CAACqE,GAAL,CAASG,aAAb,EAA4B;AACjCX,MAAAA,OAAO,GAAGtI,2BAA2B,CAAC,IAAD,EAAO0F,mBAAP,CAA3B,CAAuDA,mBAAvD,EAA4E9B,WAA5E,EAAyFa,IAAI,CAACqE,GAAL,CAASI,aAAlG,CAAV;AACD,KAFM,MAEA,IAAIzE,IAAI,CAACqE,GAAL,CAASK,SAAb,EAAwB;AAC7Bb,MAAAA,OAAO,GAAGtI,2BAA2B,CAAC,IAAD,EAAO2F,eAAP,CAA3B,CAAmDA,eAAnD,EAAoE/B,WAApE,EAAiFa,IAAI,CAACqE,GAAL,CAASM,SAA1F,CAAV;AACD,KAFM,MAEA,IAAI3E,IAAI,CAACqE,GAAL,CAASO,WAAb,EAA0B;AAC/Bf,MAAAA,OAAO,GAAGtI,2BAA2B,CAAC,IAAD,EAAO4F,iBAAP,CAA3B,CAAqDA,iBAArD,EAAwEhC,WAAxE,EAAqFa,IAArF,EAA2FA,IAAI,CAACqE,GAAL,CAASQ,WAApG,CAAV;AACD,KAFM,MAEA,IAAI7E,IAAI,CAACqE,GAAL,CAASS,oBAAb,EAAmC;AACxCjB,MAAAA,OAAO,GAAGtI,2BAA2B,CAAC,IAAD,EAAOgG,gBAAP,CAA3B,CAAoDA,gBAApD,EAAsEpC,WAAtE,EAAmFa,IAAI,CAACqE,GAAL,CAASU,oBAA5F,CAAV;AACD,KAFM,MAEA,IAAI/E,IAAI,CAACqE,GAAL,CAASW,WAAb,EAA0B;AAC/BnB,MAAAA,OAAO,GAAGtI,2BAA2B,CAAC,IAAD,EAAOiG,iBAAP,CAA3B,CAAqDA,iBAArD,EAAwErC,WAAxE,EAAqFa,IAArF,CAAV;AACD,KAFM,MAEA,IAAIA,IAAI,CAACqE,GAAL,CAASY,UAAb,EAAyB;AAC9BpB,MAAAA,OAAO,GAAGtI,2BAA2B,CAAC,IAAD,EAAOmG,gBAAP,CAA3B,CAAoDA,gBAApD,EAAsEvC,WAAtE,EAAmFa,IAAI,CAACqE,GAAL,CAASa,UAA5F,CAAV;AACD,KAFM,MAEA,IAAIlF,IAAI,CAACqE,GAAL,CAASc,OAAb,EAAsB;AAC3BtB,MAAAA,OAAO,GAAGtI,2BAA2B,CAAC,IAAD,EAAOoG,aAAP,CAA3B,CAAiDA,aAAjD,EAAgExC,WAAhE,EAA6Ea,IAAI,CAACqE,GAAL,CAASe,OAAtF,CAAV;AACD,KAFM,MAEA,IAAIpF,IAAI,CAACqE,GAAL,CAASgB,SAAb,EAAwB;AAC7BxB,MAAAA,OAAO,GAAGtI,2BAA2B,CAAC,IAAD,EAAOqG,eAAP,CAA3B,CAAmDA,eAAnD,EAAoEzC,WAApE,EAAiFa,IAAjF,EAAuFA,IAAI,CAACqE,GAAL,CAASiB,SAAhG,CAAV;AACD,KAFM,MAEA;AACL,YAAM,IAAIC,KAAJ,iCAAmCpG,WAAnC,8BAAkEa,IAAI,CAACqE,GAAL,CAASzF,QAAT,EAAlE,EAAN;AACD;AACF,GAxBD,CAwBE,OAAO4G,KAAP,EAAc;AACd,UAAM,IAAID,KAAJ,6BAA+BpG,WAA/B,gCAAgE9B,SAAS,CAAC2C,IAAD,CAAzE,eAAoFwF,KAAK,CAACC,OAA1F,EAAN;AACD;;AAED,SAAOnJ,aAAa,CAAC;AACnByH,IAAAA,IAAI,EAAE/D,IAAI,CAAC+D,IAAL,CAAUhG,GAAV,CAAc,UAAA2H,CAAC;AAAA,aAAIA,CAAC,CAAC9G,QAAF,EAAJ;AAAA,KAAf,CADa;AAEnB+G,IAAAA,SAAS,EAAE5G,IAAI,CAACgB,IAAL,CAAU,IAAV;AAFQ,GAAD,EAGjB8D,OAHiB,CAApB;AAID;;AAED,SAAShB,cAAT,CAAwB1D,WAAxB,UAGG;AAAA,MAFIzC,MAEJ,UAFDkJ,GAEC;AAAA,MADD5F,IACC,UADDA,IACC;AACD/C,EAAAA,MAAM,CAAC,CAACP,MAAD,IAAWA,MAAM,CAACiD,QAAP,MAAqB,GAAjC,EAAsC;AAAA,uCAA2BR,WAA3B;AAAA,GAAtC,CAAN;AACA,SAAO3B,cAAc,CAAC,KAAK6C,QAAN,EAAgB;AACnCgD,IAAAA,IAAI,EAAE3F,WAAW,CAACmI,QADiB;AAEnCnJ,IAAAA,MAAM,EAAEA,MAAM,CAACiD,QAAP,EAF2B;AAGnCmG,IAAAA,GAAG,EAAEvK,2BAA2B,CAAC,IAAD,EAAOsF,YAAP,CAA3B,CAAgDA,YAAhD,EAA8Db,IAA9D;AAH8B,GAAhB,CAArB;AAKD;;AAED,SAAS4C,oBAAT,CAA8BmD,CAA9B,UAGG;AAAA,MAFDC,YAEC,UAFDA,YAEC;AAAA,MADDC,YACC,UADDA,YACC;;AACD,MAAMC,QAAQ,GAAG3K,2BAA2B,CAAC,IAAD,EAAOsF,YAAP,CAA3B,CAAgDA,YAAhD,EAA8DmF,YAA9D,CAAjB;;AAEA,MAAMG,QAAQ,GAAG5K,2BAA2B,CAAC,IAAD,EAAOsF,YAAP,CAA3B,CAAgDA,YAAhD,EAA8DoF,YAA9D,CAAjB,CAHC,CAG6F;AAC9F;AACA;;;AAGAhJ,EAAAA,MAAM,CAAC,CAAC,qBAAD,EAAwB,qBAAxB,EAA+C4B,QAA/C,CAAwDqH,QAAQ,CAACP,SAAT,IAAsB,EAA9E,CAAD,EAAoF;AAAA,kDAAsCO,QAAQ,CAACP,SAAT,IAAsB,WAA5D;AAAA,GAApF,CAAN;AACA1I,EAAAA,MAAM,CAACkJ,QAAQ,CAAC9C,IAAT,KAAkB3F,WAAW,CAACiG,KAA9B,IAAuCwC,QAAQ,CAACnG,IAAT,KAAkB,IAA1D,EAAgE;AAAA,oEAAwDmG,QAAQ,CAACnG,IAAjE;AAAA,GAAhE,CAAN;AACA,SAAO;AACLqD,IAAAA,IAAI,EAAE3F,WAAW,CAACiG,KADb;AAEL3D,IAAAA,IAAI,EAAE;AAFD,GAAP;AAID;;AAED,SAAS2C,gBAAT,CAA0BoD,CAA1B,UAEG;AAAA,MADD/F,IACC,UADDA,IACC;AACD,SAAOxC,cAAc,CAAC,KAAK6C,QAAN,EAAgB;AACnCgD,IAAAA,IAAI,EAAE3F,WAAW,CAAC0I,OADiB;AAEnCN,IAAAA,GAAG,EAAEvK,2BAA2B,CAAC,IAAD,EAAOsF,YAAP,CAA3B,CAAgDA,YAAhD,EAA8Db,IAA9D;AAF8B,GAAhB,CAArB;AAID;;AAED,SAAS0C,kBAAT,CAA4BvD,WAA5B,kBAKG;AAAA;;AAAA,MAJDO,MAIC,UAJDA,MAIC;AAAA,MAHDX,IAGC,UAHDA,IAGC;AAAA,MADDsH,MACC,UADDA,MACC;;AACD,MAAItH,IAAI,CAACrC,MAAL,KAAgB,CAAhB,IAAqBqC,IAAI,CAAC,CAAD,CAAJ,CAAQuH,EAAR,CAAW,UAAX,CAAzB,EAAiD;AAC/C,WAAO9I,cAAc,CAAC,KAAK6C,QAAN,EAAgB;AACnCgD,MAAAA,IAAI,EAAE3F,WAAW,CAAC6I,QADiB;AAEnCT,MAAAA,GAAG,EAAEpG,MAAM,CAAC3B,GAAP,CAAW;AAAA,YACdiC,IADc,UACdA,IADc;AAAA,eAEVzE,2BAA2B,CAAC,MAAD,EAAOsF,YAAP,CAA3B,CAAgDA,YAAhD,EAA8Db,IAAI,CAACG,MAAL,EAA9D,CAFU;AAAA,OAAX;AAF8B,KAAhB,CAArB;AAMD;;AAED,SAAOjC,IAAI,CAACc,IAAL,CAAU,UAAAhB,CAAC;AAAA,WAAIK,UAAU,CAACL,CAAD,EAAIe,IAAJ,CAAd;AAAA,GAAX,IAAsCxD,2BAA2B,CAAC,IAAD,EAAO6F,oBAAP,CAA3B,CAAwDA,oBAAxD,EAA8EjC,WAA9E,EAA2FO,MAA3F,EAAmG2G,MAAnG,CAAtC,GAAmJ9K,2BAA2B,CAAC,IAAD,EAAO8F,cAAP,CAA3B,CAAkDA,cAAlD,EAAkElC,WAAlE,EAA+EkH,MAA/E,CAA1J;AACD;;AAED,SAAS5D,qBAAT,CAA+BtD,WAA/B,EAA4CO,MAA5C,EAAoD2G,MAApD,EAA4D;AAC1DpJ,EAAAA,MAAM,CAACyC,MAAM,CAAChD,MAAP,KAAkB,CAAlB,IAAuB2J,MAAM,CAAC3J,MAAP,KAAkB,CAA1C,EAA6C;AAAA,uCAA2ByC,WAA3B;AAAA,GAA7C,CAAN;AACA,SAAO3B,cAAc,CAAC,KAAK6C,QAAN,EAAgB;AACnCgD,IAAAA,IAAI,EAAE3F,WAAW,CAAC8I,GADiB;AAEnC9J,IAAAA,MAAM,EAAE,KAAK2D,QAAL,CAAcoG,UAAd,CAAyB,KAAKpG,QAAL,CAAcG,gBAAd,CAA+B6F,MAAM,CAAC,CAAD,CAAN,CAAUrG,IAAzC,CAAzB,EAAyE0G,SAAzE,EAF2B;AAGnCZ,IAAAA,GAAG,EAAE,KAAKrC,SAAL,CAAe/D,MAAM,CAAC,CAAD,CAAN,CAAUM,IAAV,CAAeG,MAAf,EAAf,EAAwCkE,GAAxC,CAA4CiB,SAA5C,CAAsDqB,QAAtD,CAA+D5I,GAA/D,CAAmE;AAAA,UACtEW,KADsE,UACtEA,KADsE;AAAA,UAEtEU,IAFsE,UAEtEA,IAFsE;AAAA,aAGjE;AACL;AACAV,QAAAA,KAAK,EAAEA,KAAK,CAACiB,QAAN,EAFF;AAGL0D,QAAAA,IAAI,EAAE3F,WAAW,CAACiG,KAHb;AAILvE,QAAAA,IAAI,EAAEA,IAAI,CAACR,QAAL,EAJD;AAKLoB,QAAAA,IAAI,EAAE;AALD,OAHiE;AAAA,KAAnE;AAH8B,GAAhB,CAArB;AAcD;;AAED,SAASwC,eAAT,CAAyBrD,WAAzB,EAAsCkH,MAAtC,EAA8C;AAC5C,uBAA4BA,MAAM,CAAC9F,MAAP,CAAc;AAAA;AAAA,QAAEqG,UAAF;AAAA,QAAcC,YAAd;;AAAA,QACxCzH,IADwC,UACxCA,IADwC;AAAA,WAEpC,CAACwH,UAAU,IAAIxH,IAAI,CAACa,MAApB,EAA4B4G,YAAY,IAAIzH,IAAI,CAAC0H,MAAjD,CAFoC;AAAA,GAAd,EAEoC,CAAC,IAAD,EAAO,IAAP,CAFpC,CAA5B;AAAA;AAAA,MAAOC,QAAP;AAAA,MAAiB5B,OAAjB;;AAGAlI,EAAAA,MAAM,CAACkI,OAAO,IAAI4B,QAAZ,EAAsB;AAAA,uCAA2B5H,WAA3B;AAAA,GAAtB,CAAN;;AAEA,MAAIkH,MAAM,CAAC3J,MAAP,KAAkB,CAAtB,EAAyB;AACvB,WAAO;AACL2G,MAAAA,IAAI,EAAE3F,WAAW,CAACsJ,IADb;AAELhH,MAAAA,IAAI,EAAE;AAFD,KAAP;AAID,GALD,MAKO,IAAImF,OAAO,IAAIkB,MAAM,CAAC3J,MAAP,KAAkB,CAAjC,EAAoC;AACzC,QAAMmH,OAAO,GAAGtI,2BAA2B,CAAC,IAAD,EAAOsF,YAAP,CAA3B,CAAgDA,YAAhD,EAA8DwF,MAAM,CAAC,CAAD,CAAN,CAAUrG,IAAxE,CAAhB;;AAEA,WAAO1D,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKuH,OAAL,CAAd,EAA6B1E,WAAW,KAAK,CAAC,CAAjB,GAAqB,EAArB,GAA0B;AACzEA,MAAAA,WAAW,EAAXA,WADyE;AAEzEoE,MAAAA,UAAU,EAAEhI,2BAA2B,CAAC,IAAD,EAAOoF,MAAP,CAA3B,CAA0CA,MAA1C,EAAkDxB,WAAlD,CAF6D;AAGzEyE,MAAAA,cAAc,EAAEC,OAAO,CAACN;AAHiD,KAAvD,CAApB;AAKD;;AAED,8BAAqBhI,2BAA2B,CAAC,IAAD,EAAO+F,mBAAP,CAA3B,CAAuDA,mBAAvD,EAA4E+E,MAA5E,CAArB;AAAA;AAAA,MAAOP,GAAP;AAAA,MAAYmB,KAAZ;;AAEA,SAAOzJ,cAAc,CAAC,KAAK6C,QAAN,EAAgB/D,aAAa,CAACA,aAAa,CAACA,aAAa,CAAC;AAC7E+G,IAAAA,IAAI,EAAE8B,OAAO,CAAC;AAAD,MACXzH,WAAW,CAACwJ,KADD,GACSxJ,WAAW,CAACH;AAF2C,GAAD,EAG3E0J,KAAK,CAACE,IAAN,GAAa;AACdF,IAAAA,KAAK,EAALA;AADc,GAAb,GAEC,EAL0E,CAAd,EAKvD9H,WAAW,KAAK,CAAC,CAAjB,GAAqB,EAArB,GAA0B;AACjCA,IAAAA,WAAW,EAAXA,WADiC;AAEjCoE,IAAAA,UAAU,EAAEhI,2BAA2B,CAAC,IAAD,EAAOoF,MAAP,CAA3B,CAA0CA,MAA1C,EAAkDxB,WAAlD;AAFqB,GAL6B,CAAd,EAQ9C,EAR8C,EAQ1C;AACN2G,IAAAA,GAAG,EAAHA;AADM,GAR0C,CAA7B,CAArB;AAWD;;AAED,SAASvD,oBAAT,CAA8B8D,MAA9B,EAAsC;AAAA;;AACpC,MAAMY,KAAK,GAAG,IAAIG,GAAJ,EAAd;AACA,MAAMtB,GAAG,GAAGO,MAAM,CAACtI,GAAP,CAAW,kBAIjB;AAAA,QAHJgG,IAGI,UAHJA,IAGI;AAAA,QAFJ3E,IAEI,UAFJA,IAEI;AAAA,QADJY,IACI,UADJA,IACI;;AACJ,QAAM6D,OAAO,GAAGtI,2BAA2B,CAAC,MAAD,EAAOsF,YAAP,CAA3B,CAAgDA,YAAhD,EAA8Db,IAA9D,CAAhB;;AAEA,QAAIZ,IAAI,CAAC0H,MAAT,EAAiB;AACf,aAAOjD,OAAP;AACD;;AAED,QAAIwD,SAAS,GAAGjK,eAAe,CAACgC,IAAI,CAACe,MAAL,EAAD,CAA/B;AACA,QAAImH,QAAQ,GAAG,IAAf;;AAEA,QAAID,SAAS,CAACxI,QAAV,CAAmB,GAAnB,CAAJ,EAA6B;AAC3ByI,MAAAA,QAAQ,GAAGD,SAAX;AACAA,MAAAA,SAAS,GAAGC,QAAQ,CAACnD,OAAT,CAAiB,IAAjB,EAAuB,GAAvB,CAAZ;AACD,KAHD,MAGO,IAAI/F,QAAQ,CAACS,QAAT,CAAkBwI,SAAlB,CAAJ,EAAkC;AACvCC,MAAAA,QAAQ,GAAGD,SAAX;AACAA,MAAAA,SAAS,aAAMA,SAAN,MAAT;AACD;;AAED,QAAIC,QAAJ,EAAc;AACZL,MAAAA,KAAK,CAACM,GAAN,CAAUF,SAAV,EAAqBC,QAArB;AACD;;AAED,WAAOhL,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKuH,OAAL,CAAd,EAA6B,EAA7B,EAAiC;AACnDE,MAAAA,IAAI,EAAEA,IAAI,CAAChG,GAAL,CAAS,UAAA2H,CAAC;AAAA,eAAIA,CAAC,CAAC9G,QAAF,EAAJ;AAAA,OAAV,CAD6C;AAEnDQ,MAAAA,IAAI,EAAEiI;AAF6C,KAAjC,CAApB;AAID,GA9BW,CAAZ;AA+BA,SAAO,CAACvB,GAAD,EAAMmB,KAAN,CAAP;AACD;;AAED,SAAS3E,iBAAT,CAA2ByD,CAA3B,EAA8B/F,IAA9B,EAAoC;AAClC,SAAO1D,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKmB,UAAU,CAACuC,IAAD,CAAf,CAAd,EAAsC,EAAtC,EAA0C;AAC5DwH,IAAAA,WAAW,EAAExH,IAAI,CAACpB,QAAL,EAD+C;AAE5D6I,IAAAA,QAAQ,EAAE;AAFkD,GAA1C,CAApB;AAID;;AAED,SAASpF,kBAAT,CAA4B0D,CAA5B,EAA+B/F,IAA/B,EAAqC;AACnC,MAAM0H,OAAO,GAAG1H,IAAI,CAACqE,GAAL,CAASsD,WAAT,CAAqB3H,IAArB,CAA0BpB,QAA1B,EAAhB;AACA,SAAO;AACLyE,IAAAA,IAAI,EAAE3F,WAAW,CAACiG,KADb;AAEL3D,IAAAA,IAAI,EAAErC,eAAe,CAAC+J,OAAD,CAAf,IAA4BA,OAAO,CAAC7H,WAAR;AAF7B,GAAP;AAID;;AAED,SAASuC,sBAAT,CAAgC2D,CAAhC,EAAmC/F,IAAnC,EAAyC;AACvC,SAAO;AACLqD,IAAAA,IAAI,EAAE3F,WAAW,CAACiG,KADb;AAEL3D,IAAAA,IAAI,EAAJA;AAFK,GAAP;AAID;;AAED,SAASmC,iBAAT,CAA2BhD,WAA3B,UAEG;AAAA,MADDa,IACC,UADDA,IACC;;AACD,MAAM8F,GAAG,GAAGvK,2BAA2B,CAAC,IAAD,EAAOsF,YAAP,CAA3B,CAAgDA,YAAhD,EAA8Db,IAA9D,CAAZ;;AAEA,MAAI8F,GAAG,CAAC9F,IAAJ,KAAa,IAAjB,EAAuB;AACrB,WAAO;AACLqD,MAAAA,IAAI,EAAE3F,WAAW,CAACiG,KADb;AAEL3D,MAAAA,IAAI,EAAE;AAFD,KAAP;AAID;;AAED,SAAOxC,cAAc,CAAC,KAAK6C,QAAN,EAAgB;AACnCgD,IAAAA,IAAI,EAAE3F,WAAW,CAACkK,GADiB;AAEnCzI,IAAAA,WAAW,EAAXA,WAFmC;AAGnCoE,IAAAA,UAAU,EAAEhI,2BAA2B,CAAC,IAAD,EAAOoF,MAAP,CAA3B,CAA0CA,MAA1C,EAAkDxB,WAAlD,CAHuB;AAInC2G,IAAAA,GAAG,EAAHA;AAJmC,GAAhB,CAArB;AAMD;;AAED,SAAS5D,cAAT,CAAwB/C,WAAxB,EAAqC0I,GAArC,EAA0C;AAAA;;AACxC,MAAIA,GAAG,CAACnL,MAAJ,KAAe,CAAnB,EAAsB;AACpB,WAAO;AACL2G,MAAAA,IAAI,EAAE3F,WAAW,CAACsJ,IADb;AAELhH,MAAAA,IAAI,EAAE;AAFD,KAAP;AAID,GALD,MAKO,IAAI6H,GAAG,CAACnL,MAAJ,KAAe,CAAnB,EAAsB;AAC3B,WAAO,KAAKe,UAAL,CAAgBoK,GAAG,CAAC,CAAD,CAAnB,CAAP;AACD;;AAED,MAAM/B,GAAG,GAAG+B,GAAG,CAAC9J,GAAJ,CAAQ,UAAAiC,IAAI;AAAA,WAAIzE,2BAA2B,CAAC,MAAD,EAAOsF,YAAP,CAA3B,CAAgDA,YAAhD,EAA8Db,IAA9D,CAAJ;AAAA,GAAZ,CAAZ;AACA,SAAOxC,cAAc,CAAC,KAAK6C,QAAN,EAAgB;AACnCgD,IAAAA,IAAI,EAAE3F,WAAW,CAACwJ,KADiB;AAEnC/H,IAAAA,WAAW,EAAXA,WAFmC;AAGnCoE,IAAAA,UAAU,EAAEhI,2BAA2B,CAAC,IAAD,EAAOoF,MAAP,CAA3B,CAA0CA,MAA1C,EAAkDxB,WAAlD,CAHuB;AAInC2G,IAAAA,GAAG,EAAHA;AAJmC,GAAhB,CAArB;AAMD;;AAED,SAAS7D,gBAAT,CAA0B9C,WAA1B,kBAKG;AAAA;;AAAA,MAJDO,MAIC,UAJDA,MAIC;AAAA,MAHDX,IAGC,UAHDA,IAGC;AAAA,MADD4H,QACC,UADDA,QACC;AACD,MAAMmB,cAAc,GAAG/I,IAAI,CAAC,CAAD,CAAJ,CAAQH,QAAR,EAAvB;;AAEA,MAAIkJ,cAAc,KAAK,QAAvB,EAAiC;AAC/B,WAAOtK,cAAc,CAAC,KAAK6C,QAAN,EAAgB;AACnCgD,MAAAA,IAAI,EAAE3F,WAAW,CAACqK,MADiB;AAEnCjC,MAAAA,GAAG,EAAEvK,2BAA2B,CAAC,IAAD,EAAOsF,YAAP,CAA3B,CAAgDA,YAAhD,EAA8DnB,MAAM,CAAC,CAAD,CAAN,CAAUM,IAAV,CAAeG,MAAf,EAA9D;AAF8B,KAAhB,CAArB;AAID,GALD,MAKO,IAAI2H,cAAc,KAAK,QAAvB,EAAiC;AACtC,WAAOtK,cAAc,CAAC,KAAK6C,QAAN,EAAgB;AACnCgD,MAAAA,IAAI,EAAE3F,WAAW,CAACsK,MADiB;AAEnClC,MAAAA,GAAG,EAAEpG,MAAM,CAAC3B,GAAP,CAAW;AAAA,YACdiC,IADc,UACdA,IADc;AAAA,eAEVzE,2BAA2B,CAAC,MAAD,EAAOsF,YAAP,CAA3B,CAAgDA,YAAhD,EAA8Db,IAAI,CAACG,MAAL,EAA9D,CAFU;AAAA,OAAX,EAE+EpC,GAF/E,CAEmF,UAACsG,GAAD,EAAM3F,KAAN;AAAA,eAAgBpC,aAAa,CAAC;AACpH8C,UAAAA,IAAI,EAAE,CAAC,IAAD,EAAO,OAAP,EAAgBV,KAAhB;AAD8G,SAAD,EAElH2F,GAFkH,CAA7B;AAAA,OAFnF;AAF8B,KAAhB,CAArB;AAQD,GATM,MASA,IAAIsC,QAAQ,CAACjK,MAAT,KAAoB,CAAxB,EAA2B;AAChC,WAAO;AACL2G,MAAAA,IAAI,EAAE3F,WAAW,CAACsJ,IADb;AAELhH,MAAAA,IAAI,EAAE;AAFD,KAAP;AAID;;AAED,SAAOzE,2BAA2B,CAAC,IAAD,EAAOsG,mBAAP,CAA3B,CAAuDA,mBAAvD,EAA4E1C,WAA5E,EAAyFwH,QAAzF,CAAP;AACD;;AAED,SAAS3E,oBAAT,CAA8B7C,WAA9B,EAA2CwH,QAA3C,EAAqD;AAAA;;AACnD,MAAMb,GAAG,GAAG,EAAZ,CADmD,CACnC;AAChB;;AAEA,qBAAIa,QAAJ,EAAcsB,IAAd,CAAmB,UAACxJ,CAAD,EAAIE,CAAJ;AAAA,WAAUF,CAAC,CAACC,KAAF,CAAQwJ,GAAR,CAAYvJ,CAAC,CAACD,KAAd,CAAV;AAAA,GAAnB,EAAmD9B,OAAnD,CAA2D,kBAIrD;AAAA,QAHJyJ,MAGI,UAHJA,MAGI;AAAA,QAFJ3H,KAEI,UAFJA,KAEI;AAAA,QADJU,IACI,UADJA,IACI;AACJ,QAAM+I,OAAO,GAAGzJ,KAAK,CAACiB,QAAN,EAAhB;;AAEA,WAAOmG,GAAG,CAACpJ,MAAJ,KAAeyL,OAAtB,EAA+B;AAC7BrC,MAAAA,GAAG,CAAC1J,IAAJ,CAAS;AACPsC,QAAAA,KAAK,EAAEoH,GAAG,CAACpJ,MADJ;AAEP2G,QAAAA,IAAI,EAAE3F,WAAW,CAACsJ,IAFX;AAGP5H,QAAAA,IAAI,kBAAW0G,GAAG,CAACpJ,MAAf,CAHG;AAIPsD,QAAAA,IAAI,EAAE;AAJC,OAAT;AAMD;;AAED8F,IAAAA,GAAG,CAAC1J,IAAJ,CAASE,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKf,2BAA2B,CAAC,MAAD,EAAO8F,cAAP,CAA3B,CAAkDA,cAAlD,EAAkE,CAAC,CAAnE,EAAsEgF,MAAtE,CAAL,CAAd,EAAmG,EAAnG,EAAuG;AAC3H3H,MAAAA,KAAK,EAAEA,KAAK,CAACiB,QAAN,EADoH;AAE3HP,MAAAA,IAAI,EAAEA,IAAI,CAACR,QAAL;AAFqH,KAAvG,CAAtB;AAID,GApBD;;AAqBA,SAAOpB,cAAc,CAAC,KAAK6C,QAAN,EAAgB;AACnCgD,IAAAA,IAAI,EAAE3F,WAAW,CAACoG,IADiB;AAEnC3E,IAAAA,WAAW,EAAXA,WAFmC;AAGnCoE,IAAAA,UAAU,EAAEhI,2BAA2B,CAAC,IAAD,EAAOoF,MAAP,CAA3B,CAA0CA,MAA1C,EAAkDxB,WAAlD,CAHuB;AAInC2G,IAAAA,GAAG,EAAHA;AAJmC,GAAhB,CAArB;AAMD","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, isNumber, isString, stringCamelCase, stringify, stringUpperFirst } from '@polkadot/util';\nimport { Struct } from \"../codec/Struct.js\";\nimport { withTypeString } from \"../create/encodeTypes.js\";\nimport { getTypeDef } from \"../create/getTypeDef.js\";\nimport { TypeDefInfo } from \"../types/index.js\"; // Alias the primitive enum with out known values\n\nconst PRIMITIVE_ALIAS = {\n  Char: 'u32',\n  // Rust char is 4-bytes\n  Str: 'Text'\n}; // These are types where we have a specific decoding/encoding override + helpers\n\nconst PRIMITIVE_PATHS = [// match {node, polkadot, ...}_runtime\n'*_runtime::Call', '*_runtime::Event', // these have a specific encoding or logic (for pallets)\n'pallet_democracy::vote::Vote', 'pallet_identity::types::Data', // these are well-known types with additional encoding\n'sp_core::crypto::AccountId32', 'sp_runtime::generic::era::Era', 'sp_runtime::multiaddress::MultiAddress', // shorten some well-known types\n'primitive_types::*', 'sp_arithmetic::per_things::*', // ink!\n'ink_env::types::*'].map(p => p.split('::')); // Mappings for types that should be converted to set via BitVec\n\nconst SETS = ['pallet_identity::types::BitFlags'].map(p => p.split('::')); // These we never use these as top-level names, they are wrappers\n\nconst WRAPPERS = ['BoundedBTreeMap', 'BoundedVec', 'Box', 'BTreeMap', 'Cow', 'Result', 'Option', 'WeakBoundedVec']; // These are reserved and/or conflicts with built-in Codec definitions\n\nconst RESERVED = ['call', 'entries', 'hash', 'keys', 'new', 'size'];\n\nfunction matchParts(first, second) {\n  return first.length === second.length && first.every((a, index) => {\n    const b = second[index].toString();\n    return a === '*' || a === b || a.includes('*') && a.includes('_') && b.includes('_') && matchParts(a.split('_'), b.split('_'));\n  });\n} // check if the path matches the PRIMITIVE_SP (with wildcards)\n\n\nfunction getPrimitivePath(path) {\n  // TODO We need to handle ink! Balance in some way\n  return path.length && PRIMITIVE_PATHS.some(p => matchParts(p, path)) ? path[path.length - 1].toString() : null;\n}\n\nfunction removeDuplicateNames(names) {\n  return names.map(([lookupIndex, name]) => [lookupIndex, !name || names.some(([oIndex, oName]) => name === oName && lookupIndex !== oIndex) ? null : name]);\n}\n\nfunction extractName(types, id, {\n  params,\n  path\n}) {\n  const lookupIndex = id.toNumber();\n\n  if (!path.length || WRAPPERS.includes(path[path.length - 1].toString())) {\n    return [lookupIndex, null];\n  }\n\n  const parts = path.map(p => stringUpperFirst(stringCamelCase(p))).filter((p, index) => ( // Remove ::{pallet, traits, types}::\n  index !== 1 || !['Pallet', 'Traits', 'Types'].includes(p.toString())) && ( // sp_runtime::generic::digest::Digest -> sp_runtime::generic::Digest\n  // sp_runtime::multiaddress::MultiAddress -> sp_runtime::MultiAddress\n  index === path.length - 1 || p.toLowerCase() !== path[index + 1].toLowerCase()));\n  let typeName = parts.join('');\n\n  if (parts.length === 2 && parts[parts.length - 1] === 'RawOrigin' && params.length === 2 && params[1].type.isSome) {\n    // Do magic for RawOrigin lookup\n    const instanceType = types[params[1].type.unwrap().toNumber()];\n\n    if (instanceType.type.path.length === 2) {\n      typeName = `${typeName}${instanceType.type.path[1].toString()}`;\n    }\n  }\n\n  return [lookupIndex, typeName];\n}\n\nfunction extractNames(registry, types) {\n  const dedup = removeDuplicateNames(types.map(({\n    id,\n    type\n  }) => extractName(types, id, type)));\n  const [names, typesNew] = dedup.reduce(([names, types], [lookupIndex, name], index) => {\n    if (name) {\n      // We set the name for this specific type\n      names[index] = name; // we map to the actual lookupIndex\n\n      types[name] = registry.createLookupType(lookupIndex);\n    }\n\n    return [names, types];\n  }, [{}, {}]);\n  registry.register(typesNew);\n  return names;\n}\n\nvar _names = /*#__PURE__*/_classPrivateFieldLooseKey(\"names\");\n\nvar _typeDefs = /*#__PURE__*/_classPrivateFieldLooseKey(\"typeDefs\");\n\nvar _createSiDef = /*#__PURE__*/_classPrivateFieldLooseKey(\"createSiDef\");\n\nvar _getLookupId = /*#__PURE__*/_classPrivateFieldLooseKey(\"getLookupId\");\n\nvar _extract = /*#__PURE__*/_classPrivateFieldLooseKey(\"extract\");\n\nvar _extractArray = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractArray\");\n\nvar _extractBitSequence = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractBitSequence\");\n\nvar _extractCompact = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractCompact\");\n\nvar _extractComposite = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractComposite\");\n\nvar _extractCompositeSet = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractCompositeSet\");\n\nvar _extractFields = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractFields\");\n\nvar _extractFieldsAlias = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractFieldsAlias\");\n\nvar _extractHistoric = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractHistoric\");\n\nvar _extractPrimitive = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractPrimitive\");\n\nvar _extractPrimitivePath = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractPrimitivePath\");\n\nvar _extractSequence = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractSequence\");\n\nvar _extractTuple = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractTuple\");\n\nvar _extractVariant = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractVariant\");\n\nvar _extractVariantEnum = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractVariantEnum\");\n\nexport class GenericPortableRegistry extends Struct {\n  constructor(registry, value) {\n    super(registry, {\n      types: 'Vec<PortableType>'\n    }, value);\n    Object.defineProperty(this, _extractVariantEnum, {\n      value: _extractVariantEnum2\n    });\n    Object.defineProperty(this, _extractVariant, {\n      value: _extractVariant2\n    });\n    Object.defineProperty(this, _extractTuple, {\n      value: _extractTuple2\n    });\n    Object.defineProperty(this, _extractSequence, {\n      value: _extractSequence2\n    });\n    Object.defineProperty(this, _extractPrimitivePath, {\n      value: _extractPrimitivePath2\n    });\n    Object.defineProperty(this, _extractPrimitive, {\n      value: _extractPrimitive2\n    });\n    Object.defineProperty(this, _extractHistoric, {\n      value: _extractHistoric2\n    });\n    Object.defineProperty(this, _extractFieldsAlias, {\n      value: _extractFieldsAlias2\n    });\n    Object.defineProperty(this, _extractFields, {\n      value: _extractFields2\n    });\n    Object.defineProperty(this, _extractCompositeSet, {\n      value: _extractCompositeSet2\n    });\n    Object.defineProperty(this, _extractComposite, {\n      value: _extractComposite2\n    });\n    Object.defineProperty(this, _extractCompact, {\n      value: _extractCompact2\n    });\n    Object.defineProperty(this, _extractBitSequence, {\n      value: _extractBitSequence2\n    });\n    Object.defineProperty(this, _extractArray, {\n      value: _extractArray2\n    });\n    Object.defineProperty(this, _extract, {\n      value: _extract2\n    });\n    Object.defineProperty(this, _getLookupId, {\n      value: _getLookupId2\n    });\n    Object.defineProperty(this, _createSiDef, {\n      value: _createSiDef2\n    });\n    Object.defineProperty(this, _names, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _typeDefs, {\n      writable: true,\n      value: {}\n    });\n    _classPrivateFieldLooseBase(this, _names)[_names] = extractNames(registry, this.types);\n  }\n  /**\n   * @description The types of the registry\n   */\n\n\n  get types() {\n    return this.get('types');\n  }\n  /**\n   * @description Finds a specific type in the registry\n   */\n\n\n  getSiType(lookupId) {\n    const found = this.types[_classPrivateFieldLooseBase(this, _getLookupId)[_getLookupId](lookupId)];\n\n    assert(found, () => `PortableRegistry: Unable to find type with lookupId ${lookupId.toString()}`);\n    return found.type;\n  }\n  /**\n   * @description Lookup the type definition for the index\n   */\n\n\n  getTypeDef(lookupId) {\n    const lookupIndex = _classPrivateFieldLooseBase(this, _getLookupId)[_getLookupId](lookupId);\n\n    if (!_classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex]) {\n      // we set first since we will get into circular lookups along the way\n      _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex] = {\n        info: TypeDefInfo.DoNotConstruct,\n        lookupIndex,\n        lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n        type: this.registry.createLookupType(lookupIndex)\n      };\n\n      const extracted = _classPrivateFieldLooseBase(this, _extract)[_extract](this.getSiType(lookupId), lookupIndex);\n\n      Object.keys(extracted).forEach(k => {\n        if (k !== 'lookupName' || extracted[k]) {\n          // these are safe since we are looking through the keys as set\n          _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex][k] = extracted[k];\n        }\n      }); // don't set lookupName on lower-level, we want to always direct to the type\n\n      if (extracted.info === TypeDefInfo.Plain) {\n        _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex].lookupNameRoot = _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex].lookupName;\n        delete _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex].lookupName;\n      }\n    }\n\n    return _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex];\n  }\n\n}\n\nfunction _createSiDef2(lookupId) {\n  const typeDef = this.getTypeDef(lookupId);\n  const lookupIndex = lookupId.toNumber(); // Setup for a lookup on complex types\n\n  return [TypeDefInfo.Enum, TypeDefInfo.Struct].includes(typeDef.info) && typeDef.lookupName ? {\n    docs: typeDef.docs,\n    info: TypeDefInfo.Si,\n    lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n    type: this.registry.createLookupType(lookupId)\n  } : typeDef;\n}\n\nfunction _getLookupId2(lookupId) {\n  if (isString(lookupId)) {\n    assert(this.registry.isLookupType(lookupId), () => `PortableRegistry: Expected a lookup string type, found ${lookupId}`);\n    return parseInt(lookupId.replace('Lookup', ''), 10);\n  } else if (isNumber(lookupId)) {\n    return lookupId;\n  }\n\n  return lookupId.toNumber();\n}\n\nfunction _extract2(type, lookupIndex) {\n  const path = [...type.path];\n  let typeDef;\n  const primType = getPrimitivePath(type.path);\n\n  try {\n    if (primType) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractPrimitivePath)[_extractPrimitivePath](lookupIndex, primType);\n    } else if (type.def.isArray) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractArray)[_extractArray](lookupIndex, type.def.asArray);\n    } else if (type.def.isBitSequence) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractBitSequence)[_extractBitSequence](lookupIndex, type.def.asBitSequence);\n    } else if (type.def.isCompact) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractCompact)[_extractCompact](lookupIndex, type.def.asCompact);\n    } else if (type.def.isComposite) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractComposite)[_extractComposite](lookupIndex, type, type.def.asComposite);\n    } else if (type.def.isHistoricMetaCompat) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractHistoric)[_extractHistoric](lookupIndex, type.def.asHistoricMetaCompat);\n    } else if (type.def.isPrimitive) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractPrimitive)[_extractPrimitive](lookupIndex, type);\n    } else if (type.def.isSequence) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractSequence)[_extractSequence](lookupIndex, type.def.asSequence);\n    } else if (type.def.isTuple) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractTuple)[_extractTuple](lookupIndex, type.def.asTuple);\n    } else if (type.def.isVariant) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractVariant)[_extractVariant](lookupIndex, type, type.def.asVariant);\n    } else {\n      throw new Error(`Invalid type at index ${lookupIndex}: No handler for ${type.def.toString()}`);\n    }\n  } catch (error) {\n    throw new Error(`PortableRegistry: ${lookupIndex}: Error extracting ${stringify(type)}: ${error.message}`);\n  }\n\n  return _objectSpread({\n    docs: type.docs.map(d => d.toString()),\n    namespace: path.join('::')\n  }, typeDef);\n}\n\nfunction _extractArray2(lookupIndex, {\n  len: length,\n  type\n}) {\n  assert(!length || length.toNumber() <= 256, () => `PortableRegistry: ${lookupIndex}: Only support for [Type; <length>], where length <= 256`);\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.VecFixed,\n    length: length.toNumber(),\n    sub: _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type)\n  });\n}\n\nfunction _extractBitSequence2(_, {\n  bitOrderType,\n  bitStoreType\n}) {\n  const bitOrder = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](bitOrderType);\n\n  const bitStore = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](bitStoreType); // NOTE: Currently the BitVec type is one-way only, i.e. we only use it to decode, not\n  // re-encode stuff. As such we ignore the msb/lsb identifier given by bitOrderType, or rather\n  // we don't pass it though at all\n\n\n  assert(['bitvec::order::Lsb0', 'bitvec::order::Msb0'].includes(bitOrder.namespace || ''), () => `Unexpected bitOrder found as ${bitOrder.namespace || '<unknown>'}`);\n  assert(bitStore.info === TypeDefInfo.Plain && bitStore.type === 'u8', () => `Only u8 bitStore is currently supported, found ${bitStore.type}`);\n  return {\n    info: TypeDefInfo.Plain,\n    type: 'BitVec'\n  };\n}\n\nfunction _extractCompact2(_, {\n  type\n}) {\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Compact,\n    sub: _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type)\n  });\n}\n\nfunction _extractComposite2(lookupIndex, {\n  params,\n  path\n}, {\n  fields\n}) {\n  if (path.length === 1 && path[0].eq('BTreeMap')) {\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.BTreeMap,\n      sub: params.map(({\n        type\n      }) => _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type.unwrap()))\n    });\n  }\n\n  return SETS.some(p => matchParts(p, path)) ? _classPrivateFieldLooseBase(this, _extractCompositeSet)[_extractCompositeSet](lookupIndex, params, fields) : _classPrivateFieldLooseBase(this, _extractFields)[_extractFields](lookupIndex, fields);\n}\n\nfunction _extractCompositeSet2(lookupIndex, params, fields) {\n  assert(params.length === 1 && fields.length === 1, () => `PortableRegistry: ${lookupIndex}: Set handling expects since param and single field`);\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Set,\n    length: this.registry.createType(this.registry.createLookupType(fields[0].type)).bitLength(),\n    sub: this.getSiType(params[0].type.unwrap()).def.asVariant.variants.map(({\n      index,\n      name\n    }) => ({\n      // This will be an issue > 2^53 - 1 ... don't have those (yet)\n      index: index.toNumber(),\n      info: TypeDefInfo.Plain,\n      name: name.toString(),\n      type: 'Null'\n    }))\n  });\n}\n\nfunction _extractFields2(lookupIndex, fields) {\n  const [isStruct, isTuple] = fields.reduce(([isAllNamed, isAllUnnamed], {\n    name\n  }) => [isAllNamed && name.isSome, isAllUnnamed && name.isNone], [true, true]);\n  assert(isTuple || isStruct, () => `PortableRegistry: ${lookupIndex}: Invalid fields type detected, expected either Tuple (all unnamed) or Struct (all named)`);\n\n  if (fields.length === 0) {\n    return {\n      info: TypeDefInfo.Null,\n      type: 'Null'\n    };\n  } else if (isTuple && fields.length === 1) {\n    const typeDef = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](fields[0].type);\n\n    return _objectSpread(_objectSpread({}, typeDef), lookupIndex === -1 ? {} : {\n      lookupIndex,\n      lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n      lookupNameRoot: typeDef.lookupName\n    });\n  }\n\n  const [sub, alias] = _classPrivateFieldLooseBase(this, _extractFieldsAlias)[_extractFieldsAlias](fields);\n\n  return withTypeString(this.registry, _objectSpread(_objectSpread(_objectSpread({\n    info: isTuple // Tuple check first\n    ? TypeDefInfo.Tuple : TypeDefInfo.Struct\n  }, alias.size ? {\n    alias\n  } : {}), lookupIndex === -1 ? {} : {\n    lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex]\n  }), {}, {\n    sub\n  }));\n}\n\nfunction _extractFieldsAlias2(fields) {\n  const alias = new Map();\n  const sub = fields.map(({\n    docs,\n    name,\n    type\n  }) => {\n    const typeDef = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type);\n\n    if (name.isNone) {\n      return typeDef;\n    }\n\n    let nameField = stringCamelCase(name.unwrap());\n    let nameOrig = null;\n\n    if (nameField.includes('#')) {\n      nameOrig = nameField;\n      nameField = nameOrig.replace(/#/g, '_');\n    } else if (RESERVED.includes(nameField)) {\n      nameOrig = nameField;\n      nameField = `${nameField}_`;\n    }\n\n    if (nameOrig) {\n      alias.set(nameField, nameOrig);\n    }\n\n    return _objectSpread(_objectSpread({}, typeDef), {}, {\n      docs: docs.map(d => d.toString()),\n      name: nameField\n    });\n  });\n  return [sub, alias];\n}\n\nfunction _extractHistoric2(_, type) {\n  return _objectSpread(_objectSpread({}, getTypeDef(type)), {}, {\n    displayName: type.toString(),\n    isFromSi: true\n  });\n}\n\nfunction _extractPrimitive2(_, type) {\n  const typeStr = type.def.asPrimitive.type.toString();\n  return {\n    info: TypeDefInfo.Plain,\n    type: PRIMITIVE_ALIAS[typeStr] || typeStr.toLowerCase()\n  };\n}\n\nfunction _extractPrimitivePath2(_, type) {\n  return {\n    info: TypeDefInfo.Plain,\n    type\n  };\n}\n\nfunction _extractSequence2(lookupIndex, {\n  type\n}) {\n  const sub = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type);\n\n  if (sub.type === 'u8') {\n    return {\n      info: TypeDefInfo.Plain,\n      type: 'Bytes'\n    };\n  }\n\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Vec,\n    lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n    sub\n  });\n}\n\nfunction _extractTuple2(lookupIndex, ids) {\n  if (ids.length === 0) {\n    return {\n      info: TypeDefInfo.Null,\n      type: 'Null'\n    };\n  } else if (ids.length === 1) {\n    return this.getTypeDef(ids[0]);\n  }\n\n  const sub = ids.map(type => _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type));\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Tuple,\n    lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n    sub\n  });\n}\n\nfunction _extractVariant2(lookupIndex, {\n  params,\n  path\n}, {\n  variants\n}) {\n  const specialVariant = path[0].toString();\n\n  if (specialVariant === 'Option') {\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.Option,\n      sub: _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](params[0].type.unwrap())\n    });\n  } else if (specialVariant === 'Result') {\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.Result,\n      sub: params.map(({\n        type\n      }) => _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type.unwrap())).map((def, index) => _objectSpread({\n        name: ['Ok', 'Error'][index]\n      }, def))\n    });\n  } else if (variants.length === 0) {\n    return {\n      info: TypeDefInfo.Null,\n      type: 'Null'\n    };\n  }\n\n  return _classPrivateFieldLooseBase(this, _extractVariantEnum)[_extractVariantEnum](lookupIndex, variants);\n}\n\nfunction _extractVariantEnum2(lookupIndex, variants) {\n  const sub = []; // we may get entries out of order, arrange them first before creating with gaps filled\n  // NOTE: Since we mutate, use a copy of the array as an input\n\n  [...variants].sort((a, b) => a.index.cmp(b.index)).forEach(({\n    fields,\n    index,\n    name\n  }) => {\n    const desired = index.toNumber();\n\n    while (sub.length !== desired) {\n      sub.push({\n        index: sub.length,\n        info: TypeDefInfo.Null,\n        name: `Unused${sub.length}`,\n        type: 'Null'\n      });\n    }\n\n    sub.push(_objectSpread(_objectSpread({}, _classPrivateFieldLooseBase(this, _extractFields)[_extractFields](-1, fields)), {}, {\n      index: index.toNumber(),\n      name: name.toString()\n    }));\n  });\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Enum,\n    lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n    sub\n  });\n}"]},"metadata":{},"sourceType":"module"}