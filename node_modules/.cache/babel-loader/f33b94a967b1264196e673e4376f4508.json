{"ast":null,"code":"import _toConsumableArray from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n// Copyright 2017-2021 @polkadot/api authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { logger } from '@polkadot/util';\nvar l = logger('api/augment');\n\nfunction logLength(type, values) {\n  var and = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  return values.length ? \" \".concat(values.length, \" \").concat(type).concat(and.length ? ' and' : '') : '';\n}\n\nfunction logValues(type, values) {\n  return values.length ? \"\\n\\t\".concat(type.padStart(7), \": \").concat(values.sort().join(', ')) : '';\n} // log details to console\n\n\nfunction warn(prefix, type, _ref) {\n  var _ref2 = _slicedToArray(_ref, 2),\n      added = _ref2[0],\n      removed = _ref2[1];\n\n  if (added.length || removed.length) {\n    l.warn(\"api.\".concat(prefix, \": Found\").concat(logLength('added', added, removed)).concat(logLength('removed', removed), \" \").concat(type, \":\").concat(logValues('added', added)).concat(logValues('removed', removed)));\n  }\n}\n\nfunction extractKeys(src, dst) {\n  return [Object.keys(src), Object.keys(dst)];\n}\n\nfunction findSectionExcludes(a, b) {\n  return a.filter(function (section) {\n    return !b.includes(section);\n  });\n}\n\nfunction extractSections(src, dst) {\n  var _extractKeys = extractKeys(src, dst),\n      _extractKeys2 = _slicedToArray(_extractKeys, 2),\n      srcSections = _extractKeys2[0],\n      dstSections = _extractKeys2[1];\n\n  return [findSectionExcludes(srcSections, dstSections), findSectionExcludes(dstSections, srcSections)];\n}\n\nfunction findMethodExcludes(src, dst) {\n  var srcSections = Object.keys(src);\n  var dstSections = Object.keys(dst);\n  return dstSections.filter(function (section) {\n    return srcSections.includes(section);\n  }).reduce(function (rmMethods, section) {\n    var srcMethods = Object.keys(src[section]);\n    return rmMethods.concat.apply(rmMethods, _toConsumableArray(Object.keys(dst[section]).filter(function (method) {\n      return !srcMethods.includes(method);\n    }).map(function (method) {\n      return \"\".concat(section, \".\").concat(method);\n    })));\n  }, []);\n}\n\nfunction extractMethods(src, dst) {\n  return [findMethodExcludes(dst, src), findMethodExcludes(src, dst)];\n}\n/**\n * Takes a decorated api section (e.g. api.tx) and augment it with the details. It does not override what is\n * already available, but rather just adds new missing ites into the result object.\n * @internal\n */\n\n\nexport function augmentObject(prefix, src, dst) {\n  var fromEmpty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  if (fromEmpty) {\n    Object.keys(dst).forEach(function (key) {\n      delete dst[key];\n    });\n  }\n\n  if (prefix && Object.keys(dst).length) {\n    warn(prefix, 'modules', extractSections(src, dst));\n    warn(prefix, 'calls', extractMethods(src, dst));\n  }\n\n  return Object.keys(src).reduce(function (newSection, sectionName) {\n    var section = src[sectionName];\n    newSection[sectionName] = Object.keys(section).reduce(function (result, methodName) {\n      // TODO When it does match, check the actual details and warn when there are differences\n      if (!result[methodName]) {\n        result[methodName] = section[methodName];\n      }\n\n      return result;\n    }, dst[sectionName] || {});\n    return newSection;\n  }, dst);\n}","map":{"version":3,"sources":["/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/@polkadot/api/util/augmentObject.js"],"names":["logger","l","logLength","type","values","and","length","logValues","padStart","sort","join","warn","prefix","added","removed","extractKeys","src","dst","Object","keys","findSectionExcludes","a","b","filter","section","includes","extractSections","srcSections","dstSections","findMethodExcludes","reduce","rmMethods","srcMethods","concat","method","map","extractMethods","augmentObject","fromEmpty","forEach","key","newSection","sectionName","result","methodName"],"mappings":"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","sourcesContent":["// Copyright 2017-2021 @polkadot/api authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { logger } from '@polkadot/util';\nconst l = logger('api/augment');\n\nfunction logLength(type, values, and = []) {\n  return values.length ? ` ${values.length} ${type}${and.length ? ' and' : ''}` : '';\n}\n\nfunction logValues(type, values) {\n  return values.length ? `\\n\\t${type.padStart(7)}: ${values.sort().join(', ')}` : '';\n} // log details to console\n\n\nfunction warn(prefix, type, [added, removed]) {\n  if (added.length || removed.length) {\n    l.warn(`api.${prefix}: Found${logLength('added', added, removed)}${logLength('removed', removed)} ${type}:${logValues('added', added)}${logValues('removed', removed)}`);\n  }\n}\n\nfunction extractKeys(src, dst) {\n  return [Object.keys(src), Object.keys(dst)];\n}\n\nfunction findSectionExcludes(a, b) {\n  return a.filter(section => !b.includes(section));\n}\n\nfunction extractSections(src, dst) {\n  const [srcSections, dstSections] = extractKeys(src, dst);\n  return [findSectionExcludes(srcSections, dstSections), findSectionExcludes(dstSections, srcSections)];\n}\n\nfunction findMethodExcludes(src, dst) {\n  const srcSections = Object.keys(src);\n  const dstSections = Object.keys(dst);\n  return dstSections.filter(section => srcSections.includes(section)).reduce((rmMethods, section) => {\n    const srcMethods = Object.keys(src[section]);\n    return rmMethods.concat(...Object.keys(dst[section]).filter(method => !srcMethods.includes(method)).map(method => `${section}.${method}`));\n  }, []);\n}\n\nfunction extractMethods(src, dst) {\n  return [findMethodExcludes(dst, src), findMethodExcludes(src, dst)];\n}\n/**\n * Takes a decorated api section (e.g. api.tx) and augment it with the details. It does not override what is\n * already available, but rather just adds new missing ites into the result object.\n * @internal\n */\n\n\nexport function augmentObject(prefix, src, dst, fromEmpty = false) {\n  if (fromEmpty) {\n    Object.keys(dst).forEach(key => {\n      delete dst[key];\n    });\n  }\n\n  if (prefix && Object.keys(dst).length) {\n    warn(prefix, 'modules', extractSections(src, dst));\n    warn(prefix, 'calls', extractMethods(src, dst));\n  }\n\n  return Object.keys(src).reduce((newSection, sectionName) => {\n    const section = src[sectionName];\n    newSection[sectionName] = Object.keys(section).reduce((result, methodName) => {\n      // TODO When it does match, check the actual details and warn when there are differences\n      if (!result[methodName]) {\n        result[methodName] = section[methodName];\n      }\n\n      return result;\n    }, dst[sectionName] || {});\n    return newSection;\n  }, dst);\n}"]},"metadata":{},"sourceType":"module"}