{"ast":null,"code":"import _classCallCheck from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _slicedToArray from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, compactAddLength, compactFromU8a, compactToU8a, isString, isU8a, u8aToU8a } from '@polkadot/util';\nimport { Raw } from \"../codec/Raw.js\"; // Bytes are used for things like on-chain code, so it has a healthy limit\n\nvar MAX_LENGTH = 10 * 1024 * 1024;\n/** @internal */\n\nfunction decodeBytesU8a(value) {\n  if (!value.length) {\n    return new Uint8Array();\n  } // handle all other Uint8Array inputs, these do have a length prefix\n\n\n  var _compactFromU8a = compactFromU8a(value),\n      _compactFromU8a2 = _slicedToArray(_compactFromU8a, 2),\n      offset = _compactFromU8a2[0],\n      length = _compactFromU8a2[1];\n\n  var total = offset + length.toNumber();\n  assert(length.lten(MAX_LENGTH), function () {\n    return \"Bytes length \".concat(length.toString(), \" exceeds \").concat(MAX_LENGTH);\n  });\n  assert(total <= value.length, function () {\n    return \"Bytes: required length less than remainder, expected at least \".concat(total, \", found \").concat(value.length);\n  });\n  return value.subarray(offset, total);\n}\n/** @internal */\n\n\nfunction decodeBytes(value) {\n  if (Array.isArray(value) || isString(value)) {\n    return u8aToU8a(value);\n  } else if (!(value instanceof Raw) && isU8a(value)) {\n    // We are ensuring we are not a Raw instance. In the case of a Raw we already have gotten\n    // rid of the length, i.e. new Bytes(new Bytes(...)) will work as expected\n    return decodeBytesU8a(value);\n  }\n\n  return value;\n}\n/**\n * @name Bytes\n * @description\n * A Bytes wrapper for Vec<u8>. The significant difference between this and a normal Uint8Array\n * is that this version allows for length-encoding. (i.e. it is a variable-item codec, the same\n * as what is found in [[Text]] and [[Vec]])\n */\n\n\nexport var Bytes = /*#__PURE__*/function (_Raw) {\n  _inherits(Bytes, _Raw);\n\n  var _super = _createSuper(Bytes);\n\n  function Bytes(registry, value) {\n    _classCallCheck(this, Bytes);\n\n    return _super.call(this, registry, decodeBytes(value));\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  _createClass(Bytes, [{\n    key: \"encodedLength\",\n    get: function get() {\n      return this.length + compactToU8a(this.length).length;\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n\n  }, {\n    key: \"toRawType\",\n    value: function toRawType() {\n      return 'Bytes';\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n\n  }, {\n    key: \"toU8a\",\n    value: function toU8a(isBare) {\n      return isBare ? _get(_getPrototypeOf(Bytes.prototype), \"toU8a\", this).call(this, isBare) : compactAddLength(this);\n    }\n  }]);\n\n  return Bytes;\n}(Raw);","map":{"version":3,"sources":["/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/@polkadot/types/primitive/Bytes.js"],"names":["assert","compactAddLength","compactFromU8a","compactToU8a","isString","isU8a","u8aToU8a","Raw","MAX_LENGTH","decodeBytesU8a","value","length","Uint8Array","offset","total","toNumber","lten","toString","subarray","decodeBytes","Array","isArray","Bytes","registry","isBare"],"mappings":";;;;;;;AAAA;AACA;AACA,SAASA,MAAT,EAAiBC,gBAAjB,EAAmCC,cAAnC,EAAmDC,YAAnD,EAAiEC,QAAjE,EAA2EC,KAA3E,EAAkFC,QAAlF,QAAkG,gBAAlG;AACA,SAASC,GAAT,QAAoB,iBAApB,C,CAAuC;;AAEvC,IAAMC,UAAU,GAAG,KAAK,IAAL,GAAY,IAA/B;AACA;;AAEA,SAASC,cAAT,CAAwBC,KAAxB,EAA+B;AAC7B,MAAI,CAACA,KAAK,CAACC,MAAX,EAAmB;AACjB,WAAO,IAAIC,UAAJ,EAAP;AACD,GAH4B,CAG3B;;;AAGF,wBAAyBV,cAAc,CAACQ,KAAD,CAAvC;AAAA;AAAA,MAAOG,MAAP;AAAA,MAAeF,MAAf;;AACA,MAAMG,KAAK,GAAGD,MAAM,GAAGF,MAAM,CAACI,QAAP,EAAvB;AACAf,EAAAA,MAAM,CAACW,MAAM,CAACK,IAAP,CAAYR,UAAZ,CAAD,EAA0B;AAAA,kCAAsBG,MAAM,CAACM,QAAP,EAAtB,sBAAmDT,UAAnD;AAAA,GAA1B,CAAN;AACAR,EAAAA,MAAM,CAACc,KAAK,IAAIJ,KAAK,CAACC,MAAhB,EAAwB;AAAA,mFAAuEG,KAAvE,qBAAuFJ,KAAK,CAACC,MAA7F;AAAA,GAAxB,CAAN;AACA,SAAOD,KAAK,CAACQ,QAAN,CAAeL,MAAf,EAAuBC,KAAvB,CAAP;AACD;AACD;;;AAGA,SAASK,WAAT,CAAqBT,KAArB,EAA4B;AAC1B,MAAIU,KAAK,CAACC,OAAN,CAAcX,KAAd,KAAwBN,QAAQ,CAACM,KAAD,CAApC,EAA6C;AAC3C,WAAOJ,QAAQ,CAACI,KAAD,CAAf;AACD,GAFD,MAEO,IAAI,EAAEA,KAAK,YAAYH,GAAnB,KAA2BF,KAAK,CAACK,KAAD,CAApC,EAA6C;AAClD;AACA;AACA,WAAOD,cAAc,CAACC,KAAD,CAArB;AACD;;AAED,SAAOA,KAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,WAAaY,KAAb;AAAA;;AAAA;;AACE,iBAAYC,QAAZ,EAAsBb,KAAtB,EAA6B;AAAA;;AAAA,6BACrBa,QADqB,EACXJ,WAAW,CAACT,KAAD,CADA;AAE5B;AACD;AACF;AACA;;;AANA;AAAA;AAAA,SASE,eAAoB;AAClB,aAAO,KAAKC,MAAL,GAAcR,YAAY,CAAC,KAAKQ,MAAN,CAAZ,CAA0BA,MAA/C;AACD;AACD;AACF;AACA;;AAdA;AAAA;AAAA,WAiBE,qBAAY;AACV,aAAO,OAAP;AACD;AACD;AACF;AACA;AACA;;AAvBA;AAAA;AAAA,WA0BE,eAAMa,MAAN,EAAc;AACZ,aAAOA,MAAM,oEAAeA,MAAf,IAAyBvB,gBAAgB,CAAC,IAAD,CAAtD;AACD;AA5BH;;AAAA;AAAA,EAA2BM,GAA3B","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, compactAddLength, compactFromU8a, compactToU8a, isString, isU8a, u8aToU8a } from '@polkadot/util';\nimport { Raw } from \"../codec/Raw.js\"; // Bytes are used for things like on-chain code, so it has a healthy limit\n\nconst MAX_LENGTH = 10 * 1024 * 1024;\n/** @internal */\n\nfunction decodeBytesU8a(value) {\n  if (!value.length) {\n    return new Uint8Array();\n  } // handle all other Uint8Array inputs, these do have a length prefix\n\n\n  const [offset, length] = compactFromU8a(value);\n  const total = offset + length.toNumber();\n  assert(length.lten(MAX_LENGTH), () => `Bytes length ${length.toString()} exceeds ${MAX_LENGTH}`);\n  assert(total <= value.length, () => `Bytes: required length less than remainder, expected at least ${total}, found ${value.length}`);\n  return value.subarray(offset, total);\n}\n/** @internal */\n\n\nfunction decodeBytes(value) {\n  if (Array.isArray(value) || isString(value)) {\n    return u8aToU8a(value);\n  } else if (!(value instanceof Raw) && isU8a(value)) {\n    // We are ensuring we are not a Raw instance. In the case of a Raw we already have gotten\n    // rid of the length, i.e. new Bytes(new Bytes(...)) will work as expected\n    return decodeBytesU8a(value);\n  }\n\n  return value;\n}\n/**\n * @name Bytes\n * @description\n * A Bytes wrapper for Vec<u8>. The significant difference between this and a normal Uint8Array\n * is that this version allows for length-encoding. (i.e. it is a variable-item codec, the same\n * as what is found in [[Text]] and [[Vec]])\n */\n\n\nexport class Bytes extends Raw {\n  constructor(registry, value) {\n    super(registry, decodeBytes(value));\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return this.length + compactToU8a(this.length).length;\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return 'Bytes';\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    return isBare ? super.toU8a(isBare) : compactAddLength(this);\n  }\n\n}"]},"metadata":{},"sourceType":"module"}