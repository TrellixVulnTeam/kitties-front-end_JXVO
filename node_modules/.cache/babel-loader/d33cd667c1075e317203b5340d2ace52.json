{"ast":null,"code":"import _classCallCheck from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _slicedToArray from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { isBigInt, isBn, isHex, isNumber, isU8a, u8aConcat, u8aToBn, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { decodeAddress } from '@polkadot/util-crypto';\nimport { Base } from \"../codec/Base.js\";\nimport { GenericAccountIndex } from \"../generic/AccountIndex.js\";\nimport { GenericEthereumAccountId } from \"./AccountId.js\"; // eslint-disable-next-line no-use-before-define\n\nexport var ACCOUNT_ID_PREFIX = new Uint8Array([0xff]);\n/** @internal */\n\nfunction decodeString(registry, value) {\n  var decoded = decodeAddress(value);\n  return decoded.length === 20 ? registry.createType('EthereumAccountId', decoded) : registry.createType('AccountIndex', u8aToBn(decoded, true));\n}\n/** @internal */\n\n\nfunction decodeU8a(registry, value) {\n  // This allows us to instantiate an address with a raw publicKey. Do this first before\n  // we checking the first byte, otherwise we may split an already-existent valid address\n  if (value.length === 20) {\n    return registry.createType('EthereumAccountId', value);\n  } else if (value[0] === 0xff) {\n    return registry.createType('EthereumAccountId', value.subarray(1));\n  }\n\n  var _GenericAccountIndex$ = GenericAccountIndex.readLength(value),\n      _GenericAccountIndex$2 = _slicedToArray(_GenericAccountIndex$, 2),\n      offset = _GenericAccountIndex$2[0],\n      length = _GenericAccountIndex$2[1];\n\n  return registry.createType('AccountIndex', u8aToBn(value.subarray(offset, offset + length), true));\n}\n/**\n * @name GenericEthereumLookupSource\n * @description\n * A wrapper around an EthereumAccountId and/or AccountIndex that is encoded with a prefix.\n * Since we are dealing with underlying publicKeys (or shorter encoded addresses),\n * we extend from Base with an AccountId/AccountIndex wrapper. Basically the Address\n * is encoded as `[ <prefix-byte>, ...publicKey/...bytes ]` as per spec\n */\n\n\nexport var GenericEthereumLookupSource = /*#__PURE__*/function (_Base) {\n  _inherits(GenericEthereumLookupSource, _Base);\n\n  var _super = _createSuper(GenericEthereumLookupSource);\n\n  function GenericEthereumLookupSource(registry) {\n    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Uint8Array();\n\n    _classCallCheck(this, GenericEthereumLookupSource);\n\n    return _super.call(this, registry, GenericEthereumLookupSource._decodeAddress(registry, value));\n  }\n  /** @internal */\n\n\n  _createClass(GenericEthereumLookupSource, [{\n    key: \"encodedLength\",\n    get:\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    function get() {\n      var rawLength = this._rawLength;\n      return rawLength + ( // for 1 byte AccountIndexes, we are not adding a specific prefix\n      rawLength > 1 ? 1 : 0);\n    }\n    /**\n     * @description The length of the raw value, either AccountIndex or AccountId\n     */\n\n  }, {\n    key: \"_rawLength\",\n    get: function get() {\n      return this._raw instanceof GenericAccountIndex ? GenericAccountIndex.calcLength(this._raw) : this._raw.encodedLength;\n    }\n    /**\n     * @description Returns a hex string representation of the value\n     */\n\n  }, {\n    key: \"toHex\",\n    value: function toHex() {\n      return u8aToHex(this.toU8a());\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n\n  }, {\n    key: \"toRawType\",\n    value: function toRawType() {\n      return 'Address';\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n\n  }, {\n    key: \"toU8a\",\n    value: function toU8a(isBare) {\n      var encoded = this._raw.toU8a().subarray(0, this._rawLength);\n\n      return isBare ? encoded : u8aConcat(this._raw instanceof GenericAccountIndex ? GenericAccountIndex.writeLength(encoded) : ACCOUNT_ID_PREFIX, encoded);\n    }\n  }], [{\n    key: \"_decodeAddress\",\n    value: function _decodeAddress(registry, value) {\n      return value instanceof GenericEthereumLookupSource ? value._raw : value instanceof GenericEthereumAccountId || value instanceof GenericAccountIndex ? value : isBn(value) || isNumber(value) || isBigInt(value) ? registry.createType('AccountIndex', value) : Array.isArray(value) || isHex(value) || isU8a(value) ? decodeU8a(registry, u8aToU8a(value)) : decodeString(registry, value);\n    }\n  }]);\n\n  return GenericEthereumLookupSource;\n}(Base);","map":{"version":3,"sources":["/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/@polkadot/types/ethereum/LookupSource.js"],"names":["isBigInt","isBn","isHex","isNumber","isU8a","u8aConcat","u8aToBn","u8aToHex","u8aToU8a","decodeAddress","Base","GenericAccountIndex","GenericEthereumAccountId","ACCOUNT_ID_PREFIX","Uint8Array","decodeString","registry","value","decoded","length","createType","decodeU8a","subarray","readLength","offset","GenericEthereumLookupSource","_decodeAddress","rawLength","_rawLength","_raw","calcLength","encodedLength","toU8a","isBare","encoded","writeLength","Array","isArray"],"mappings":"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","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { isBigInt, isBn, isHex, isNumber, isU8a, u8aConcat, u8aToBn, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { decodeAddress } from '@polkadot/util-crypto';\nimport { Base } from \"../codec/Base.js\";\nimport { GenericAccountIndex } from \"../generic/AccountIndex.js\";\nimport { GenericEthereumAccountId } from \"./AccountId.js\"; // eslint-disable-next-line no-use-before-define\n\nexport const ACCOUNT_ID_PREFIX = new Uint8Array([0xff]);\n/** @internal */\n\nfunction decodeString(registry, value) {\n  const decoded = decodeAddress(value);\n  return decoded.length === 20 ? registry.createType('EthereumAccountId', decoded) : registry.createType('AccountIndex', u8aToBn(decoded, true));\n}\n/** @internal */\n\n\nfunction decodeU8a(registry, value) {\n  // This allows us to instantiate an address with a raw publicKey. Do this first before\n  // we checking the first byte, otherwise we may split an already-existent valid address\n  if (value.length === 20) {\n    return registry.createType('EthereumAccountId', value);\n  } else if (value[0] === 0xff) {\n    return registry.createType('EthereumAccountId', value.subarray(1));\n  }\n\n  const [offset, length] = GenericAccountIndex.readLength(value);\n  return registry.createType('AccountIndex', u8aToBn(value.subarray(offset, offset + length), true));\n}\n/**\n * @name GenericEthereumLookupSource\n * @description\n * A wrapper around an EthereumAccountId and/or AccountIndex that is encoded with a prefix.\n * Since we are dealing with underlying publicKeys (or shorter encoded addresses),\n * we extend from Base with an AccountId/AccountIndex wrapper. Basically the Address\n * is encoded as `[ <prefix-byte>, ...publicKey/...bytes ]` as per spec\n */\n\n\nexport class GenericEthereumLookupSource extends Base {\n  constructor(registry, value = new Uint8Array()) {\n    super(registry, GenericEthereumLookupSource._decodeAddress(registry, value));\n  }\n  /** @internal */\n\n\n  static _decodeAddress(registry, value) {\n    return value instanceof GenericEthereumLookupSource ? value._raw : value instanceof GenericEthereumAccountId || value instanceof GenericAccountIndex ? value : isBn(value) || isNumber(value) || isBigInt(value) ? registry.createType('AccountIndex', value) : Array.isArray(value) || isHex(value) || isU8a(value) ? decodeU8a(registry, u8aToU8a(value)) : decodeString(registry, value);\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    const rawLength = this._rawLength;\n    return rawLength + ( // for 1 byte AccountIndexes, we are not adding a specific prefix\n    rawLength > 1 ? 1 : 0);\n  }\n  /**\n   * @description The length of the raw value, either AccountIndex or AccountId\n   */\n\n\n  get _rawLength() {\n    return this._raw instanceof GenericAccountIndex ? GenericAccountIndex.calcLength(this._raw) : this._raw.encodedLength;\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n\n\n  toHex() {\n    return u8aToHex(this.toU8a());\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return 'Address';\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    const encoded = this._raw.toU8a().subarray(0, this._rawLength);\n\n    return isBare ? encoded : u8aConcat(this._raw instanceof GenericAccountIndex ? GenericAccountIndex.writeLength(encoded) : ACCOUNT_ID_PREFIX, encoded);\n  }\n\n}"]},"metadata":{},"sourceType":"module"}