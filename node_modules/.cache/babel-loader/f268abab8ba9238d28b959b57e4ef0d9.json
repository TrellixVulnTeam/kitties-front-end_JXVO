{"ast":null,"code":"import _slicedToArray from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n// Copyright 2017-2021 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert } from '@polkadot/util';\nimport { mnemonicValidate } from \"../../mnemonic/index.js\";\nimport { naclKeypairFromSeed } from \"../../nacl/index.js\";\nimport { HARDENED, hdValidatePath } from \"../validatePath.js\";\nimport { ledgerDerivePrivate } from \"./derivePrivate.js\";\nimport { ledgerMaster } from \"./master.js\";\nexport function hdLedger(_mnemonic, path) {\n  var parts = _mnemonic.split(' ').map(function (s) {\n    return s.trim();\n  }).filter(function (s) {\n    return s;\n  });\n\n  assert([12, 24, 25].includes(parts.length), 'Expected a mnemonic with 24 words (or 25 including a password)');\n\n  var _ref = parts.length === 25 ? [parts.slice(0, 24).join(' '), parts[24]] : [parts.join(' '), ''],\n      _ref2 = _slicedToArray(_ref, 2),\n      mnemonic = _ref2[0],\n      password = _ref2[1];\n\n  assert(mnemonicValidate(mnemonic), 'Invalid mnemonic passed to ledger derivation');\n  assert(hdValidatePath(path), 'Invalid derivation path');\n  return naclKeypairFromSeed(path.split('/').slice(1).map(function (n) {\n    return parseInt(n.replace(/'$/, ''), 10);\n  }).map(function (n) {\n    return n < HARDENED ? n + HARDENED : n;\n  }).reduce(function (x, n) {\n    return ledgerDerivePrivate(x, n);\n  }, ledgerMaster(mnemonic, password)).slice(0, 32));\n}","map":{"version":3,"sources":["/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/@polkadot/util-crypto/hd/ledger/index.js"],"names":["assert","mnemonicValidate","naclKeypairFromSeed","HARDENED","hdValidatePath","ledgerDerivePrivate","ledgerMaster","hdLedger","_mnemonic","path","parts","split","map","s","trim","filter","includes","length","slice","join","mnemonic","password","n","parseInt","replace","reduce","x"],"mappings":";AAAA;AACA;AACA,SAASA,MAAT,QAAuB,gBAAvB;AACA,SAASC,gBAAT,QAAiC,yBAAjC;AACA,SAASC,mBAAT,QAAoC,qBAApC;AACA,SAASC,QAAT,EAAmBC,cAAnB,QAAyC,oBAAzC;AACA,SAASC,mBAAT,QAAoC,oBAApC;AACA,SAASC,YAAT,QAA6B,aAA7B;AACA,OAAO,SAASC,QAAT,CAAkBC,SAAlB,EAA6BC,IAA7B,EAAmC;AACxC,MAAMC,KAAK,GAAGF,SAAS,CAACG,KAAV,CAAgB,GAAhB,EAAqBC,GAArB,CAAyB,UAAAC,CAAC;AAAA,WAAIA,CAAC,CAACC,IAAF,EAAJ;AAAA,GAA1B,EAAwCC,MAAxC,CAA+C,UAAAF,CAAC;AAAA,WAAIA,CAAJ;AAAA,GAAhD,CAAd;;AAEAb,EAAAA,MAAM,CAAC,CAAC,EAAD,EAAK,EAAL,EAAS,EAAT,EAAagB,QAAb,CAAsBN,KAAK,CAACO,MAA5B,CAAD,EAAsC,gEAAtC,CAAN;;AACA,aAA6BP,KAAK,CAACO,MAAN,KAAiB,EAAjB,GAAsB,CAACP,KAAK,CAACQ,KAAN,CAAY,CAAZ,EAAe,EAAf,EAAmBC,IAAnB,CAAwB,GAAxB,CAAD,EAA+BT,KAAK,CAAC,EAAD,CAApC,CAAtB,GAAkE,CAACA,KAAK,CAACS,IAAN,CAAW,GAAX,CAAD,EAAkB,EAAlB,CAA/F;AAAA;AAAA,MAAOC,QAAP;AAAA,MAAiBC,QAAjB;;AACArB,EAAAA,MAAM,CAACC,gBAAgB,CAACmB,QAAD,CAAjB,EAA6B,8CAA7B,CAAN;AACApB,EAAAA,MAAM,CAACI,cAAc,CAACK,IAAD,CAAf,EAAuB,yBAAvB,CAAN;AACA,SAAOP,mBAAmB,CAACO,IAAI,CAACE,KAAL,CAAW,GAAX,EAAgBO,KAAhB,CAAsB,CAAtB,EAAyBN,GAAzB,CAA6B,UAAAU,CAAC;AAAA,WAAIC,QAAQ,CAACD,CAAC,CAACE,OAAF,CAAU,IAAV,EAAgB,EAAhB,CAAD,EAAsB,EAAtB,CAAZ;AAAA,GAA9B,EAAqEZ,GAArE,CAAyE,UAAAU,CAAC;AAAA,WAAIA,CAAC,GAAGnB,QAAJ,GAAemB,CAAC,GAAGnB,QAAnB,GAA8BmB,CAAlC;AAAA,GAA1E,EAA+GG,MAA/G,CAAsH,UAACC,CAAD,EAAIJ,CAAJ;AAAA,WAAUjB,mBAAmB,CAACqB,CAAD,EAAIJ,CAAJ,CAA7B;AAAA,GAAtH,EAA2JhB,YAAY,CAACc,QAAD,EAAWC,QAAX,CAAvK,EAA6LH,KAA7L,CAAmM,CAAnM,EAAsM,EAAtM,CAAD,CAA1B;AACD","sourcesContent":["// Copyright 2017-2021 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert } from '@polkadot/util';\nimport { mnemonicValidate } from \"../../mnemonic/index.js\";\nimport { naclKeypairFromSeed } from \"../../nacl/index.js\";\nimport { HARDENED, hdValidatePath } from \"../validatePath.js\";\nimport { ledgerDerivePrivate } from \"./derivePrivate.js\";\nimport { ledgerMaster } from \"./master.js\";\nexport function hdLedger(_mnemonic, path) {\n  const parts = _mnemonic.split(' ').map(s => s.trim()).filter(s => s);\n\n  assert([12, 24, 25].includes(parts.length), 'Expected a mnemonic with 24 words (or 25 including a password)');\n  const [mnemonic, password] = parts.length === 25 ? [parts.slice(0, 24).join(' '), parts[24]] : [parts.join(' '), ''];\n  assert(mnemonicValidate(mnemonic), 'Invalid mnemonic passed to ledger derivation');\n  assert(hdValidatePath(path), 'Invalid derivation path');\n  return naclKeypairFromSeed(path.split('/').slice(1).map(n => parseInt(n.replace(/'$/, ''), 10)).map(n => n < HARDENED ? n + HARDENED : n).reduce((x, n) => ledgerDerivePrivate(x, n), ledgerMaster(mnemonic, password)).slice(0, 32));\n}"]},"metadata":{},"sourceType":"module"}