{"ast":null,"code":"import _slicedToArray from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { u8aToHex } from '@polkadot/util';\n/**\n * Given an u8a, and an array of Type constructors, decode the u8a against the\n * types, and return an array of decoded values.\n *\n * @param u8a - The u8a to decode.\n * @param types - The array of Constructor to decode the U8a against.\n */\n\nexport function decodeU8a(registry, u8a, _types, _keys) {\n  var _ref = Array.isArray(_types) ? [_types, _keys || []] : [Object.values(_types), Object.keys(_types)],\n      _ref2 = _slicedToArray(_ref, 2),\n      types = _ref2[0],\n      keys = _ref2[1];\n\n  var result = [];\n  var offset = 0;\n\n  for (var i = 0; i < types.length; i++) {\n    var Type = types[i];\n\n    try {\n      var value = new Type(registry, u8a.subarray(offset));\n      result.push(value);\n      offset += value.encodedLength;\n    } catch (error) {\n      var rawType = void 0;\n\n      try {\n        rawType = new Type(registry).toRawType();\n      } catch (_unused) {\n        rawType = '';\n      }\n\n      throw new Error(\"decodeU8a: failed at \".concat(u8aToHex(u8a.subarray(offset).slice(0, 8)), \"\\u2026 on \").concat(keys[i] ? \"\".concat(keys[i]) : '').concat(rawType ? \": \".concat(rawType) : '', \":: \").concat(error.message));\n    }\n  }\n\n  return result;\n}","map":{"version":3,"sources":["/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/@polkadot/types/codec/utils/decodeU8a.js"],"names":["u8aToHex","decodeU8a","registry","u8a","_types","_keys","Array","isArray","Object","values","keys","types","result","offset","i","length","Type","value","subarray","push","encodedLength","error","rawType","toRawType","Error","slice","message"],"mappings":";AAAA;AACA;AACA,SAASA,QAAT,QAAyB,gBAAzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,SAAT,CAAmBC,QAAnB,EAA6BC,GAA7B,EAAkCC,MAAlC,EAA0CC,KAA1C,EAAiD;AACtD,aAAsBC,KAAK,CAACC,OAAN,CAAcH,MAAd,IAAwB,CAACA,MAAD,EAASC,KAAK,IAAI,EAAlB,CAAxB,GAAgD,CAACG,MAAM,CAACC,MAAP,CAAcL,MAAd,CAAD,EAAwBI,MAAM,CAACE,IAAP,CAAYN,MAAZ,CAAxB,CAAtE;AAAA;AAAA,MAAOO,KAAP;AAAA,MAAcD,IAAd;;AACA,MAAME,MAAM,GAAG,EAAf;AACA,MAAIC,MAAM,GAAG,CAAb;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,KAAK,CAACI,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AACrC,QAAME,IAAI,GAAGL,KAAK,CAACG,CAAD,CAAlB;;AAEA,QAAI;AACF,UAAMG,KAAK,GAAG,IAAID,IAAJ,CAASd,QAAT,EAAmBC,GAAG,CAACe,QAAJ,CAAaL,MAAb,CAAnB,CAAd;AACAD,MAAAA,MAAM,CAACO,IAAP,CAAYF,KAAZ;AACAJ,MAAAA,MAAM,IAAII,KAAK,CAACG,aAAhB;AACD,KAJD,CAIE,OAAOC,KAAP,EAAc;AACd,UAAIC,OAAO,SAAX;;AAEA,UAAI;AACFA,QAAAA,OAAO,GAAG,IAAIN,IAAJ,CAASd,QAAT,EAAmBqB,SAAnB,EAAV;AACD,OAFD,CAEE,gBAAM;AACND,QAAAA,OAAO,GAAG,EAAV;AACD;;AAED,YAAM,IAAIE,KAAJ,gCAAkCxB,QAAQ,CAACG,GAAG,CAACe,QAAJ,CAAaL,MAAb,EAAqBY,KAArB,CAA2B,CAA3B,EAA8B,CAA9B,CAAD,CAA1C,uBAAoFf,IAAI,CAACI,CAAD,CAAJ,aAAaJ,IAAI,CAACI,CAAD,CAAjB,IAAyB,EAA7G,SAAkHQ,OAAO,eAAQA,OAAR,IAAoB,EAA7I,gBAAqJD,KAAK,CAACK,OAA3J,EAAN;AACD;AACF;;AAED,SAAOd,MAAP;AACD","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { u8aToHex } from '@polkadot/util';\n/**\n * Given an u8a, and an array of Type constructors, decode the u8a against the\n * types, and return an array of decoded values.\n *\n * @param u8a - The u8a to decode.\n * @param types - The array of Constructor to decode the U8a against.\n */\n\nexport function decodeU8a(registry, u8a, _types, _keys) {\n  const [types, keys] = Array.isArray(_types) ? [_types, _keys || []] : [Object.values(_types), Object.keys(_types)];\n  const result = [];\n  let offset = 0;\n\n  for (let i = 0; i < types.length; i++) {\n    const Type = types[i];\n\n    try {\n      const value = new Type(registry, u8a.subarray(offset));\n      result.push(value);\n      offset += value.encodedLength;\n    } catch (error) {\n      let rawType;\n\n      try {\n        rawType = new Type(registry).toRawType();\n      } catch {\n        rawType = '';\n      }\n\n      throw new Error(`decodeU8a: failed at ${u8aToHex(u8a.subarray(offset).slice(0, 8))}â€¦ on ${keys[i] ? `${keys[i]}` : ''}${rawType ? `: ${rawType}` : ''}:: ${error.message}`);\n    }\n  }\n\n  return result;\n}"]},"metadata":{},"sourceType":"module"}