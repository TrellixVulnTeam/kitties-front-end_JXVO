{"ast":null,"code":"import _classCallCheck from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _slicedToArray from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, isFunction, isString, isU8a } from '@polkadot/util';\nimport { Bytes } from \"./Bytes.js\";\nvar HASHER_MAP = {\n  // opaque\n  Blake2_128: [16, false],\n  // eslint-disable-line camelcase\n  Blake2_128Concat: [16, true],\n  // eslint-disable-line camelcase\n  Blake2_256: [32, false],\n  // eslint-disable-line camelcase\n  Identity: [0, true],\n  Twox128: [16, false],\n  Twox256: [32, false],\n  Twox64Concat: [8, true]\n};\n/** @internal */\n\nexport function unwrapStorageType(_, type, isOptional) {\n  var outputType = type.isPlain ? type.asPlain.toString() : type.isMap ? type.asMap.value.toString() : type.isDoubleMap ? type.asDoubleMap.value.toString() : type.asNMap.value.toString();\n  return isOptional ? \"Option<\".concat(outputType, \">\") : outputType;\n}\n/** @internal */\n\nfunction decodeStorageKey(value) {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  if (value instanceof StorageKey) {\n    return {\n      key: value,\n      method: value.method,\n      section: value.section\n    };\n  } else if (!value || isString(value) || isU8a(value)) {\n    // let Bytes handle these inputs\n    return {\n      key: value\n    };\n  } else if (isFunction(value)) {\n    return {\n      key: value(),\n      method: value.method,\n      section: value.section\n    };\n  } else if (Array.isArray(value)) {\n    var _value = _slicedToArray(value, 2),\n        fn = _value[0],\n        arg = _value[1];\n\n    assert(isFunction(fn), 'Expected function input for key construction');\n    return {\n      key: fn(arg),\n      method: fn.method,\n      section: fn.section\n    };\n  }\n\n  throw new Error(\"Unable to convert input \".concat(value, \" to StorageKey\"));\n}\n/** @internal */\n\n\nfunction decodeHashers(registry, value, hashers) {\n  // the storage entry is xxhashAsU8a(prefix, 128) + xxhashAsU8a(method, 128), 256 bits total\n  var offset = 32;\n  return hashers.reduce(function (result, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        hasher = _ref2[0],\n        type = _ref2[1];\n\n    var _HASHER_MAP$hasher$ty = _slicedToArray(HASHER_MAP[hasher.type], 2),\n        hashLen = _HASHER_MAP$hasher$ty[0],\n        canDecode = _HASHER_MAP$hasher$ty[1];\n\n    var decoded = canDecode ? registry.createType(type, value.subarray(offset + hashLen)) : registry.createType('Raw', value.subarray(offset, offset + hashLen));\n    offset += hashLen + (canDecode ? decoded.encodedLength : 0);\n    result.push(decoded);\n    return result;\n  }, []);\n}\n/** @internal */\n\n\nfunction decodeArgsFromMeta(registry, value, meta) {\n  if (!meta || !(meta.type.isMap || meta.type.isDoubleMap || meta.type.isNMap)) {\n    return [];\n  }\n\n  if (meta.type.isMap) {\n    var _mapInfo = meta.type.asMap;\n    return decodeHashers(registry, value, [[_mapInfo.hasher, _mapInfo.key.toString()]]);\n  } else if (meta.type.isDoubleMap) {\n    var _mapInfo2 = meta.type.asDoubleMap;\n    return decodeHashers(registry, value, [[_mapInfo2.hasher, _mapInfo2.key1.toString()], [_mapInfo2.key2Hasher, _mapInfo2.key2.toString()]]);\n  }\n\n  var mapInfo = meta.type.asNMap;\n  return decodeHashers(registry, value, mapInfo.hashers.map(function (h, i) {\n    return [h, mapInfo.keyVec[i].toString()];\n  }));\n}\n/** @internal */\n\n\nfunction getMeta(value) {\n  if (value instanceof StorageKey) {\n    return value.meta;\n  } else if (isFunction(value)) {\n    return value.meta;\n  } else if (Array.isArray(value)) {\n    var _value2 = _slicedToArray(value, 1),\n        fn = _value2[0];\n\n    return fn.meta;\n  }\n\n  return undefined;\n}\n/** @internal */\n\n\nfunction getType(registry, value) {\n  if (value instanceof StorageKey) {\n    return value.outputType;\n  } else if (isFunction(value)) {\n    return unwrapStorageType(registry, value.meta.type);\n  } else if (Array.isArray(value)) {\n    var _value3 = _slicedToArray(value, 1),\n        fn = _value3[0];\n\n    if (fn.meta) {\n      return unwrapStorageType(registry, fn.meta.type);\n    }\n  } // If we have no type set, default to Raw\n\n\n  return 'Raw';\n}\n/**\n * @name StorageKey\n * @description\n * A representation of a storage key (typically hashed) in the system. It can be\n * constructed by passing in a raw key or a StorageEntry with (optional) arguments.\n */\n\n\nexport var StorageKey = /*#__PURE__*/function (_Bytes) {\n  _inherits(StorageKey, _Bytes);\n\n  var _super = _createSuper(StorageKey);\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore This is assigned via this.decodeArgsFromMeta()\n  function StorageKey(registry, value) {\n    var _this;\n\n    var override = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, StorageKey);\n\n    var _decodeStorageKey = decodeStorageKey(value),\n        key = _decodeStorageKey.key,\n        method = _decodeStorageKey.method,\n        section = _decodeStorageKey.section;\n\n    _this = _super.call(this, registry, key);\n    _this._args = void 0;\n    _this._meta = void 0;\n    _this._outputType = void 0;\n    _this._method = void 0;\n    _this._section = void 0;\n    _this._outputType = getType(registry, value); // decode the args (as applicable based on the key and the hashers, after all init)\n\n    _this.setMeta(getMeta(value), override.section || section, override.method || method);\n\n    return _this;\n  }\n  /**\n   * @description Return the decoded arguments (applicable to map/doublemap with decodable values)\n   */\n\n\n  _createClass(StorageKey, [{\n    key: \"args\",\n    get: function get() {\n      return this._args;\n    }\n    /**\n     * @description The metadata or `undefined` when not available\n     */\n\n  }, {\n    key: \"meta\",\n    get: function get() {\n      return this._meta;\n    }\n    /**\n     * @description The key method or `undefined` when not specified\n     */\n\n  }, {\n    key: \"method\",\n    get: function get() {\n      return this._method;\n    }\n    /**\n     * @description The output type\n     */\n\n  }, {\n    key: \"outputType\",\n    get: function get() {\n      return this._outputType;\n    }\n    /**\n     * @description The key section or `undefined` when not specified\n     */\n\n  }, {\n    key: \"section\",\n    get: function get() {\n      return this._section;\n    }\n  }, {\n    key: \"is\",\n    value: function is(key) {\n      return key.section === this.section && key.method === this.method;\n    }\n    /**\n     * @description Sets the meta for this key\n     */\n\n  }, {\n    key: \"setMeta\",\n    value: function setMeta(meta, section, method) {\n      this._meta = meta;\n      this._method = method || this._method;\n      this._section = section || this._section;\n\n      if (meta) {\n        this._outputType = unwrapStorageType(this.registry, meta.type);\n      }\n\n      try {\n        this._args = decodeArgsFromMeta(this.registry, this.toU8a(true), this.meta);\n      } catch (error) {// ignore...\n      }\n\n      return this;\n    }\n    /**\n     * @description Returns the Human representation for this type\n     */\n\n  }, {\n    key: \"toHuman\",\n    value: function toHuman() {\n      return this._args.length ? this._args.map(function (arg) {\n        return arg.toHuman();\n      }) : _get(_getPrototypeOf(StorageKey.prototype), \"toHuman\", this).call(this);\n    }\n    /**\n     * @description Returns the raw type for this\n     */\n\n  }, {\n    key: \"toRawType\",\n    value: function toRawType() {\n      return 'StorageKey';\n    }\n  }]);\n\n  return StorageKey;\n}(Bytes);","map":{"version":3,"sources":["/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/@polkadot/types/primitive/StorageKey.js"],"names":["assert","isFunction","isString","isU8a","Bytes","HASHER_MAP","Blake2_128","Blake2_128Concat","Blake2_256","Identity","Twox128","Twox256","Twox64Concat","unwrapStorageType","_","type","isOptional","outputType","isPlain","asPlain","toString","isMap","asMap","value","isDoubleMap","asDoubleMap","asNMap","decodeStorageKey","StorageKey","key","method","section","Array","isArray","fn","arg","Error","decodeHashers","registry","hashers","offset","reduce","result","hasher","hashLen","canDecode","decoded","createType","subarray","encodedLength","push","decodeArgsFromMeta","meta","isNMap","mapInfo","key1","key2Hasher","key2","map","h","i","keyVec","getMeta","undefined","getType","override","_args","_meta","_outputType","_method","_section","setMeta","toU8a","error","length","toHuman"],"mappings":"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","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, isFunction, isString, isU8a } from '@polkadot/util';\nimport { Bytes } from \"./Bytes.js\";\nconst HASHER_MAP = {\n  // opaque\n  Blake2_128: [16, false],\n  // eslint-disable-line camelcase\n  Blake2_128Concat: [16, true],\n  // eslint-disable-line camelcase\n  Blake2_256: [32, false],\n  // eslint-disable-line camelcase\n  Identity: [0, true],\n  Twox128: [16, false],\n  Twox256: [32, false],\n  Twox64Concat: [8, true]\n};\n/** @internal */\n\nexport function unwrapStorageType(_, type, isOptional) {\n  const outputType = type.isPlain ? type.asPlain.toString() : type.isMap ? type.asMap.value.toString() : type.isDoubleMap ? type.asDoubleMap.value.toString() : type.asNMap.value.toString();\n  return isOptional ? `Option<${outputType}>` : outputType;\n}\n/** @internal */\n\nfunction decodeStorageKey(value) {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  if (value instanceof StorageKey) {\n    return {\n      key: value,\n      method: value.method,\n      section: value.section\n    };\n  } else if (!value || isString(value) || isU8a(value)) {\n    // let Bytes handle these inputs\n    return {\n      key: value\n    };\n  } else if (isFunction(value)) {\n    return {\n      key: value(),\n      method: value.method,\n      section: value.section\n    };\n  } else if (Array.isArray(value)) {\n    const [fn, arg] = value;\n    assert(isFunction(fn), 'Expected function input for key construction');\n    return {\n      key: fn(arg),\n      method: fn.method,\n      section: fn.section\n    };\n  }\n\n  throw new Error(`Unable to convert input ${value} to StorageKey`);\n}\n/** @internal */\n\n\nfunction decodeHashers(registry, value, hashers) {\n  // the storage entry is xxhashAsU8a(prefix, 128) + xxhashAsU8a(method, 128), 256 bits total\n  let offset = 32;\n  return hashers.reduce((result, [hasher, type]) => {\n    const [hashLen, canDecode] = HASHER_MAP[hasher.type];\n    const decoded = canDecode ? registry.createType(type, value.subarray(offset + hashLen)) : registry.createType('Raw', value.subarray(offset, offset + hashLen));\n    offset += hashLen + (canDecode ? decoded.encodedLength : 0);\n    result.push(decoded);\n    return result;\n  }, []);\n}\n/** @internal */\n\n\nfunction decodeArgsFromMeta(registry, value, meta) {\n  if (!meta || !(meta.type.isMap || meta.type.isDoubleMap || meta.type.isNMap)) {\n    return [];\n  }\n\n  if (meta.type.isMap) {\n    const mapInfo = meta.type.asMap;\n    return decodeHashers(registry, value, [[mapInfo.hasher, mapInfo.key.toString()]]);\n  } else if (meta.type.isDoubleMap) {\n    const mapInfo = meta.type.asDoubleMap;\n    return decodeHashers(registry, value, [[mapInfo.hasher, mapInfo.key1.toString()], [mapInfo.key2Hasher, mapInfo.key2.toString()]]);\n  }\n\n  const mapInfo = meta.type.asNMap;\n  return decodeHashers(registry, value, mapInfo.hashers.map((h, i) => [h, mapInfo.keyVec[i].toString()]));\n}\n/** @internal */\n\n\nfunction getMeta(value) {\n  if (value instanceof StorageKey) {\n    return value.meta;\n  } else if (isFunction(value)) {\n    return value.meta;\n  } else if (Array.isArray(value)) {\n    const [fn] = value;\n    return fn.meta;\n  }\n\n  return undefined;\n}\n/** @internal */\n\n\nfunction getType(registry, value) {\n  if (value instanceof StorageKey) {\n    return value.outputType;\n  } else if (isFunction(value)) {\n    return unwrapStorageType(registry, value.meta.type);\n  } else if (Array.isArray(value)) {\n    const [fn] = value;\n\n    if (fn.meta) {\n      return unwrapStorageType(registry, fn.meta.type);\n    }\n  } // If we have no type set, default to Raw\n\n\n  return 'Raw';\n}\n/**\n * @name StorageKey\n * @description\n * A representation of a storage key (typically hashed) in the system. It can be\n * constructed by passing in a raw key or a StorageEntry with (optional) arguments.\n */\n\n\nexport class StorageKey extends Bytes {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore This is assigned via this.decodeArgsFromMeta()\n  constructor(registry, value, override = {}) {\n    const {\n      key,\n      method,\n      section\n    } = decodeStorageKey(value);\n    super(registry, key);\n    this._args = void 0;\n    this._meta = void 0;\n    this._outputType = void 0;\n    this._method = void 0;\n    this._section = void 0;\n    this._outputType = getType(registry, value); // decode the args (as applicable based on the key and the hashers, after all init)\n\n    this.setMeta(getMeta(value), override.section || section, override.method || method);\n  }\n  /**\n   * @description Return the decoded arguments (applicable to map/doublemap with decodable values)\n   */\n\n\n  get args() {\n    return this._args;\n  }\n  /**\n   * @description The metadata or `undefined` when not available\n   */\n\n\n  get meta() {\n    return this._meta;\n  }\n  /**\n   * @description The key method or `undefined` when not specified\n   */\n\n\n  get method() {\n    return this._method;\n  }\n  /**\n   * @description The output type\n   */\n\n\n  get outputType() {\n    return this._outputType;\n  }\n  /**\n   * @description The key section or `undefined` when not specified\n   */\n\n\n  get section() {\n    return this._section;\n  }\n\n  is(key) {\n    return key.section === this.section && key.method === this.method;\n  }\n  /**\n   * @description Sets the meta for this key\n   */\n\n\n  setMeta(meta, section, method) {\n    this._meta = meta;\n    this._method = method || this._method;\n    this._section = section || this._section;\n\n    if (meta) {\n      this._outputType = unwrapStorageType(this.registry, meta.type);\n    }\n\n    try {\n      this._args = decodeArgsFromMeta(this.registry, this.toU8a(true), this.meta);\n    } catch (error) {// ignore...\n    }\n\n    return this;\n  }\n  /**\n   * @description Returns the Human representation for this type\n   */\n\n\n  toHuman() {\n    return this._args.length ? this._args.map(arg => arg.toHuman()) : super.toHuman();\n  }\n  /**\n   * @description Returns the raw type for this\n   */\n\n\n  toRawType() {\n    return 'StorageKey';\n  }\n\n}"]},"metadata":{},"sourceType":"module"}