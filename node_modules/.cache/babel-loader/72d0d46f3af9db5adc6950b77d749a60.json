{"ast":null,"code":"// Copyright 2017-2019 @polkadot/api authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, isUndefined } from '@polkadot/util';\n\nfunction sig(_, _ref, args) {\n  var method = _ref.method,\n      section = _ref.section;\n  return \"\".concat(section, \".\").concat(method, \"(\").concat(args.join(', '), \")\");\n}\n\nfunction doDoubleMap(registry, creator, args) {\n  var _creator$meta$type$as = creator.meta.type.asDoubleMap,\n      key1 = _creator$meta$type$as.key1,\n      key2 = _creator$meta$type$as.key2;\n  assert(args.length === 2, function () {\n    return \"\".concat(sig(registry, creator, [key1, key2]), \" is a double map, requiring 2 arguments, \").concat(args.length, \" found\");\n  }); // pass as tuple\n\n  return [creator, args];\n}\n\nfunction doMap(registry, creator, args) {\n  var key = creator.meta.type.asMap.key;\n  assert(args.length === 1, function () {\n    return \"\".concat(sig(registry, creator, [key]), \" is a map, requiring 1 argument, \").concat(args.length, \" found\");\n  }); // expand\n\n  return args.length ? [creator, args[0]] : [creator];\n}\n\nfunction doNMap(registry, creator, args) {\n  var keyVec = creator.meta.type.asNMap.keyVec;\n  assert(args.length === keyVec.length, function () {\n    return \"\".concat(sig(registry, creator, keyVec), \" is a multi map, requiring \").concat(keyVec.length, \" arguments, \").concat(args.length, \" found\");\n  }); // pass as tuple\n\n  return [creator, args];\n} // sets up the arguments in the form of [creator, args] ready to be used in a storage\n// call. Additionally, it verifies that the correct number of arguments have been passed\n\n\nexport function extractStorageArgs(registry, creator, _args) {\n  var args = _args.filter(function (arg) {\n    return !isUndefined(arg);\n  });\n\n  if (creator.meta.type.isDoubleMap) {\n    return doDoubleMap(registry, creator, args);\n  } else if (creator.meta.type.isMap) {\n    return doMap(registry, creator, args);\n  } else if (creator.meta.type.isNMap) {\n    return doNMap(registry, creator, args);\n  }\n\n  assert(args.length === 0, function () {\n    return \"\".concat(sig(registry, creator, []), \" does not take any arguments, \").concat(args.length, \" found\");\n  }); // no args\n\n  return [creator];\n}","map":{"version":3,"sources":["/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/@polkadot/api/util/validate.js"],"names":["assert","isUndefined","sig","_","args","method","section","join","doDoubleMap","registry","creator","meta","type","asDoubleMap","key1","key2","length","doMap","key","asMap","doNMap","keyVec","asNMap","extractStorageArgs","_args","filter","arg","isDoubleMap","isMap","isNMap"],"mappings":"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","sourcesContent":["// Copyright 2017-2019 @polkadot/api authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, isUndefined } from '@polkadot/util';\n\nfunction sig(_, {\n  method,\n  section\n}, args) {\n  return `${section}.${method}(${args.join(', ')})`;\n}\n\nfunction doDoubleMap(registry, creator, args) {\n  const {\n    key1,\n    key2\n  } = creator.meta.type.asDoubleMap;\n  assert(args.length === 2, () => `${sig(registry, creator, [key1, key2])} is a double map, requiring 2 arguments, ${args.length} found`); // pass as tuple\n\n  return [creator, args];\n}\n\nfunction doMap(registry, creator, args) {\n  const {\n    key\n  } = creator.meta.type.asMap;\n  assert(args.length === 1, () => `${sig(registry, creator, [key])} is a map, requiring 1 argument, ${args.length} found`); // expand\n\n  return args.length ? [creator, args[0]] : [creator];\n}\n\nfunction doNMap(registry, creator, args) {\n  const {\n    keyVec\n  } = creator.meta.type.asNMap;\n  assert(args.length === keyVec.length, () => `${sig(registry, creator, keyVec)} is a multi map, requiring ${keyVec.length} arguments, ${args.length} found`); // pass as tuple\n\n  return [creator, args];\n} // sets up the arguments in the form of [creator, args] ready to be used in a storage\n// call. Additionally, it verifies that the correct number of arguments have been passed\n\n\nexport function extractStorageArgs(registry, creator, _args) {\n  const args = _args.filter(arg => !isUndefined(arg));\n\n  if (creator.meta.type.isDoubleMap) {\n    return doDoubleMap(registry, creator, args);\n  } else if (creator.meta.type.isMap) {\n    return doMap(registry, creator, args);\n  } else if (creator.meta.type.isNMap) {\n    return doNMap(registry, creator, args);\n  }\n\n  assert(args.length === 0, () => `${sig(registry, creator, [])} does not take any arguments, ${args.length} found`); // no args\n\n  return [creator];\n}"]},"metadata":{},"sourceType":"module"}