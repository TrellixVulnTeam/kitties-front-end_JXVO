{"ast":null,"code":"import _construct from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/construct\";\nimport _toConsumableArray from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, isHex, isU8a, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { Option } from \"../codec/Option.js\";\nimport { createClass } from \"./createClass.js\"; // With isPedantic, actually check that the encoding matches that supplied. This\n// is much slower, but verifies that we have the correct types defined\n\nfunction checkInstance(created, matcher) {\n  var u8a = created.toU8a();\n  var rawType = created.toRawType();\n  var isOk = // full match, all ok\n  u8aEq(u8a, matcher) || // on a length-prefixed type, just check the actual length\n  ['Bytes', 'Text', 'Type'].includes(rawType) && matcher.length === created.length || // when the created is empty and matcher is also empty, let it slide...\n  created.isEmpty && matcher.every(function (v) {\n    return !v;\n  });\n  assert(isOk, function () {\n    return \"\".concat(rawType, \":: Decoded input doesn't match input, received \").concat(u8aToHex(matcher, 512), \" (\").concat(matcher.length, \" bytes), created \").concat(u8aToHex(u8a, 512), \" (\").concat(u8a.length, \" bytes)\");\n  });\n}\n\nfunction checkPedantic(created, _ref) {\n  var _ref2 = _slicedToArray(_ref, 1),\n      value = _ref2[0];\n\n  var isPedantic = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (isPedantic) {\n    if (isU8a(value)) {\n      checkInstance(created, value);\n    } else if (isHex(value)) {\n      checkInstance(created, u8aToU8a(value));\n    }\n  }\n} // Initializes a type with a value. This also checks for fallbacks and in the cases\n// where isPedantic is specified (storage decoding), also check the format/structure\n\n\nfunction initType(registry, Type) {\n  var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n  var _ref3 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n      blockHash = _ref3.blockHash,\n      isOptional = _ref3.isOptional,\n      isPedantic = _ref3.isPedantic;\n\n  var created = _construct(isOptional ? Option.with(Type) : Type, [registry].concat(_toConsumableArray(params)));\n\n  checkPedantic(created, params, isPedantic);\n\n  if (blockHash) {\n    created.createdAtHash = createType(registry, 'Hash', blockHash);\n  } // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n\n\n  return created;\n} // An unsafe version of the `createType` below. It's unsafe because the `type`\n// argument here can be any string, which, when it cannot parse, will yield a\n// runtime error.\n\n\nexport function createTypeUnsafe(registry, type) {\n  var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var Clazz = null;\n  var firstError = null;\n\n  try {\n    Clazz = createClass(registry, type);\n    return initType(registry, Clazz, params, options);\n  } catch (error) {\n    firstError = new Error(\"createType(\".concat(type, \"):: \").concat(error.message));\n  }\n\n  if (Clazz && Clazz.__fallbackType) {\n    try {\n      Clazz = createClass(registry, Clazz.__fallbackType);\n      return initType(registry, Clazz, params, options);\n    } catch (_unused) {// swallow, we will throw the first error again\n    }\n  }\n\n  throw firstError;\n}\n/**\n * Create an instance of a `type` with a given `params`.\n * @param type - A recognizable string representing the type to create an\n * instance from\n * @param params - The value to instantiate the type with\n */\n\nexport function createType(registry, type) {\n  for (var _len = arguments.length, params = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    params[_key - 2] = arguments[_key];\n  }\n\n  return createTypeUnsafe(registry, type, params);\n}","map":{"version":3,"sources":["/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/@polkadot/types/create/createType.js"],"names":["assert","isHex","isU8a","u8aEq","u8aToHex","u8aToU8a","Option","createClass","checkInstance","created","matcher","u8a","toU8a","rawType","toRawType","isOk","includes","length","isEmpty","every","v","checkPedantic","value","isPedantic","initType","registry","Type","params","blockHash","isOptional","with","createdAtHash","createType","createTypeUnsafe","type","options","Clazz","firstError","error","Error","message","__fallbackType"],"mappings":"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","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, isHex, isU8a, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { Option } from \"../codec/Option.js\";\nimport { createClass } from \"./createClass.js\"; // With isPedantic, actually check that the encoding matches that supplied. This\n// is much slower, but verifies that we have the correct types defined\n\nfunction checkInstance(created, matcher) {\n  const u8a = created.toU8a();\n  const rawType = created.toRawType();\n  const isOk = // full match, all ok\n  u8aEq(u8a, matcher) || // on a length-prefixed type, just check the actual length\n  ['Bytes', 'Text', 'Type'].includes(rawType) && matcher.length === created.length || // when the created is empty and matcher is also empty, let it slide...\n  created.isEmpty && matcher.every(v => !v);\n  assert(isOk, () => `${rawType}:: Decoded input doesn't match input, received ${u8aToHex(matcher, 512)} (${matcher.length} bytes), created ${u8aToHex(u8a, 512)} (${u8a.length} bytes)`);\n}\n\nfunction checkPedantic(created, [value], isPedantic = false) {\n  if (isPedantic) {\n    if (isU8a(value)) {\n      checkInstance(created, value);\n    } else if (isHex(value)) {\n      checkInstance(created, u8aToU8a(value));\n    }\n  }\n} // Initializes a type with a value. This also checks for fallbacks and in the cases\n// where isPedantic is specified (storage decoding), also check the format/structure\n\n\nfunction initType(registry, Type, params = [], {\n  blockHash,\n  isOptional,\n  isPedantic\n} = {}) {\n  const created = new (isOptional ? Option.with(Type) : Type)(registry, ...params);\n  checkPedantic(created, params, isPedantic);\n\n  if (blockHash) {\n    created.createdAtHash = createType(registry, 'Hash', blockHash);\n  } // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n\n\n  return created;\n} // An unsafe version of the `createType` below. It's unsafe because the `type`\n// argument here can be any string, which, when it cannot parse, will yield a\n// runtime error.\n\n\nexport function createTypeUnsafe(registry, type, params = [], options = {}) {\n  let Clazz = null;\n  let firstError = null;\n\n  try {\n    Clazz = createClass(registry, type);\n    return initType(registry, Clazz, params, options);\n  } catch (error) {\n    firstError = new Error(`createType(${type}):: ${error.message}`);\n  }\n\n  if (Clazz && Clazz.__fallbackType) {\n    try {\n      Clazz = createClass(registry, Clazz.__fallbackType);\n      return initType(registry, Clazz, params, options);\n    } catch {// swallow, we will throw the first error again\n    }\n  }\n\n  throw firstError;\n}\n/**\n * Create an instance of a `type` with a given `params`.\n * @param type - A recognizable string representing the type to create an\n * instance from\n * @param params - The value to instantiate the type with\n */\n\nexport function createType(registry, type, ...params) {\n  return createTypeUnsafe(registry, type, params);\n}"]},"metadata":{},"sourceType":"module"}