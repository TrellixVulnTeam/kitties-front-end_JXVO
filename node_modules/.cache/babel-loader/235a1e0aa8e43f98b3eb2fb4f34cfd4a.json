{"ast":null,"code":"// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { logger } from '@polkadot/util';\nimport { extractTypes } from \"./extractTypes.js\";\nimport { flattenUniq } from \"./flattenUniq.js\";\nvar l = logger('metadata');\n/** @internal */\n\nexport function validateTypes(registry, throwError, types) {\n  var missing = flattenUniq(extractTypes(types)).filter(function (type) {\n    return !registry.hasType(type);\n  }).sort();\n\n  if (missing.length !== 0) {\n    var message = \"Unknown types found, no types for \".concat(missing.join(', '));\n\n    if (throwError) {\n      throw new Error(message);\n    } else {\n      l.warn(message);\n    }\n  }\n\n  return types;\n}","map":{"version":3,"sources":["/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/@polkadot/types/metadata/util/validateTypes.js"],"names":["logger","extractTypes","flattenUniq","l","validateTypes","registry","throwError","types","missing","filter","type","hasType","sort","length","message","join","Error","warn"],"mappings":"AAAA;AACA;AACA,SAASA,MAAT,QAAuB,gBAAvB;AACA,SAASC,YAAT,QAA6B,mBAA7B;AACA,SAASC,WAAT,QAA4B,kBAA5B;AACA,IAAMC,CAAC,GAAGH,MAAM,CAAC,UAAD,CAAhB;AACA;;AAEA,OAAO,SAASI,aAAT,CAAuBC,QAAvB,EAAiCC,UAAjC,EAA6CC,KAA7C,EAAoD;AACzD,MAAMC,OAAO,GAAGN,WAAW,CAACD,YAAY,CAACM,KAAD,CAAb,CAAX,CAAiCE,MAAjC,CAAwC,UAAAC,IAAI;AAAA,WAAI,CAACL,QAAQ,CAACM,OAAT,CAAiBD,IAAjB,CAAL;AAAA,GAA5C,EAAyEE,IAAzE,EAAhB;;AAEA,MAAIJ,OAAO,CAACK,MAAR,KAAmB,CAAvB,EAA0B;AACxB,QAAMC,OAAO,+CAAwCN,OAAO,CAACO,IAAR,CAAa,IAAb,CAAxC,CAAb;;AAEA,QAAIT,UAAJ,EAAgB;AACd,YAAM,IAAIU,KAAJ,CAAUF,OAAV,CAAN;AACD,KAFD,MAEO;AACLX,MAAAA,CAAC,CAACc,IAAF,CAAOH,OAAP;AACD;AACF;;AAED,SAAOP,KAAP;AACD","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { logger } from '@polkadot/util';\nimport { extractTypes } from \"./extractTypes.js\";\nimport { flattenUniq } from \"./flattenUniq.js\";\nconst l = logger('metadata');\n/** @internal */\n\nexport function validateTypes(registry, throwError, types) {\n  const missing = flattenUniq(extractTypes(types)).filter(type => !registry.hasType(type)).sort();\n\n  if (missing.length !== 0) {\n    const message = `Unknown types found, no types for ${missing.join(', ')}`;\n\n    if (throwError) {\n      throw new Error(message);\n    } else {\n      l.warn(message);\n    }\n  }\n\n  return types;\n}"]},"metadata":{},"sourceType":"module"}