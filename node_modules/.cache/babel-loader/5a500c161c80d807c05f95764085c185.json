{"ast":null,"code":"import _slicedToArray from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { assert, compactAddLength, compactFromU8a, isHex, isU8a, u8aConcat, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { Base } from \"../codec/Base.js\";\nimport { BIT_SIGNED, BIT_UNSIGNED, DEFAULT_VERSION, UNMASK_VERSION } from \"./constants.js\";\nvar VERSIONS = ['ExtrinsicUnknown', // v0 is unknown\n'ExtrinsicUnknown', 'ExtrinsicUnknown', 'ExtrinsicUnknown', 'ExtrinsicV4'];\nexport { EXTRINSIC_VERSION as LATEST_EXTRINSIC_VERSION } from \"./v4/Extrinsic.js\";\n\nvar ExtrinsicBase = /*#__PURE__*/function (_Base) {\n  _inherits(ExtrinsicBase, _Base);\n\n  var _super = _createSuper(ExtrinsicBase);\n\n  function ExtrinsicBase() {\n    _classCallCheck(this, ExtrinsicBase);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(ExtrinsicBase, [{\n    key: \"args\",\n    get:\n    /**\n     * @description The arguments passed to for the call, exposes args so it is compatible with [[Call]]\n     */\n    function get() {\n      return this.method.args;\n    }\n    /**\n     * @description The argument definitions, compatible with [[Call]]\n     */\n\n  }, {\n    key: \"argsDef\",\n    get: function get() {\n      return this.method.argsDef;\n    }\n    /**\n     * @description The actual `[sectionIndex, methodIndex]` as used in the Call\n     */\n\n  }, {\n    key: \"callIndex\",\n    get: function get() {\n      return this.method.callIndex;\n    }\n    /**\n     * @description The actual data for the Call\n     */\n\n  }, {\n    key: \"data\",\n    get: function get() {\n      return this.method.data;\n    }\n    /**\n     * @description The era for this extrinsic\n     */\n\n  }, {\n    key: \"era\",\n    get: function get() {\n      return this._raw.signature.era;\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n\n  }, {\n    key: \"encodedLength\",\n    get: function get() {\n      return this.toU8a().length;\n    }\n    /**\n     * @description `true` id the extrinsic is signed\n     */\n\n  }, {\n    key: \"isSigned\",\n    get: function get() {\n      return this._raw.signature.isSigned;\n    }\n    /**\n     * @description The length of the actual data, excluding prefix\n     */\n\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this.toU8a(true).length;\n    }\n    /**\n     * @description The [[FunctionMetadataLatest]] that describes the extrinsic\n     */\n\n  }, {\n    key: \"meta\",\n    get: function get() {\n      return this.method.meta;\n    }\n    /**\n     * @description The [[Call]] this extrinsic wraps\n     */\n\n  }, {\n    key: \"method\",\n    get: function get() {\n      return this._raw.method;\n    }\n    /**\n     * @description The nonce for this extrinsic\n     */\n\n  }, {\n    key: \"nonce\",\n    get: function get() {\n      return this._raw.signature.nonce;\n    }\n    /**\n     * @description The actual [[EcdsaSignature]], [[Ed25519Signature]] or [[Sr25519Signature]]\n     */\n\n  }, {\n    key: \"signature\",\n    get: function get() {\n      return this._raw.signature.signature;\n    }\n    /**\n     * @description The [[Address]] that signed\n     */\n\n  }, {\n    key: \"signer\",\n    get: function get() {\n      return this._raw.signature.signer;\n    }\n    /**\n     * @description Forwards compat\n     */\n\n  }, {\n    key: \"tip\",\n    get: function get() {\n      return this._raw.signature.tip;\n    }\n    /**\n     * @description Returns the raw transaction version (not flagged with signing information)\n    */\n\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this._raw.version;\n    }\n    /**\n     * @description Returns the encoded version flag\n    */\n\n  }, {\n    key: \"version\",\n    get: function get() {\n      return this.type | (this.isSigned ? BIT_SIGNED : BIT_UNSIGNED);\n    }\n    /**\n     * @description Checks if the source matches this in type\n     */\n\n  }, {\n    key: \"is\",\n    value: function is(other) {\n      return this.method.is(other);\n    }\n  }]);\n\n  return ExtrinsicBase;\n}(Base);\n/**\n * @name GenericExtrinsic\n * @description\n * Representation of an Extrinsic in the system. It contains the actual call,\n * (optional) signature and encodes with an actual length prefix\n *\n * {@link https://github.com/paritytech/wiki/blob/master/Extrinsic.md#the-extrinsic-format-for-node}.\n *\n * Can be:\n * - signed, to create a transaction\n * - left as is, to create an inherent\n */\n\n\nexport var GenericExtrinsic = /*#__PURE__*/function (_ExtrinsicBase) {\n  _inherits(GenericExtrinsic, _ExtrinsicBase);\n\n  var _super2 = _createSuper(GenericExtrinsic);\n\n  function GenericExtrinsic(registry, value) {\n    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        version = _ref.version;\n\n    _classCallCheck(this, GenericExtrinsic);\n\n    return _super2.call(this, registry, GenericExtrinsic._decodeExtrinsic(registry, value, version));\n  }\n  /** @internal */\n\n\n  _createClass(GenericExtrinsic, [{\n    key: \"addSignature\",\n    value:\n    /**\n     * @description Injects an already-generated signature into the extrinsic\n     */\n    function addSignature(signer, signature, payload) {\n      this._raw.addSignature(signer, signature, payload);\n\n      return this;\n    }\n    /**\n     * @description Sign the extrinsic with a specific keypair\n     */\n\n  }, {\n    key: \"sign\",\n    value: function sign(account, options) {\n      this._raw.sign(account, options);\n\n      return this;\n    }\n    /**\n     * @describe Adds a fake signature to the extrinsic\n     */\n\n  }, {\n    key: \"signFake\",\n    value: function signFake(signer, options) {\n      this._raw.signFake(signer, options);\n\n      return this;\n    }\n    /**\n     * @description Returns a hex string representation of the value\n     */\n\n  }, {\n    key: \"toHex\",\n    value: function toHex(isBare) {\n      return u8aToHex(this.toU8a(isBare));\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n\n  }, {\n    key: \"toHuman\",\n    value: function toHuman(isExpanded) {\n      return _objectSpread({\n        isSigned: this.isSigned,\n        method: this.method.toHuman(isExpanded)\n      }, this.isSigned ? {\n        era: this.era.toHuman(isExpanded),\n        nonce: this.nonce.toHuman(isExpanded),\n        signature: this.signature.toHex(),\n        signer: this.signer.toHuman(isExpanded),\n        tip: this.tip.toHuman(isExpanded)\n      } : {});\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.toHex();\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n\n  }, {\n    key: \"toRawType\",\n    value: function toRawType() {\n      return 'Extrinsic';\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value is not length-prefixed\n     */\n\n  }, {\n    key: \"toU8a\",\n    value: function toU8a(isBare) {\n      // we do not apply bare to the internal values, rather this only determines out length addition,\n      // where we strip all lengths this creates an extrinsic that cannot be decoded\n      var encoded = u8aConcat(new Uint8Array([this.version]), this._raw.toU8a());\n      return isBare ? encoded : compactAddLength(encoded);\n    }\n  }], [{\n    key: \"_newFromValue\",\n    value: function _newFromValue(registry, value, version) {\n      if (value instanceof GenericExtrinsic) {\n        return value._raw;\n      }\n\n      var isSigned = (version & BIT_SIGNED) === BIT_SIGNED;\n      var type = VERSIONS[version & UNMASK_VERSION] || VERSIONS[0]; // we cast here since the VERSION definition is incredibly broad - we don't have a\n      // slice for \"only add extrinsic types\", and more string definitions become unwieldy\n\n      return registry.createType(type, value, {\n        isSigned: isSigned,\n        version: version\n      });\n    }\n    /** @internal */\n\n  }, {\n    key: \"_decodeExtrinsic\",\n    value: function _decodeExtrinsic(registry, value) {\n      var version = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_VERSION;\n\n      if (isU8a(value) || Array.isArray(value) || isHex(value)) {\n        return GenericExtrinsic._decodeU8a(registry, u8aToU8a(value), version);\n      } else if (value instanceof registry.createClass('Call')) {\n        return GenericExtrinsic._newFromValue(registry, {\n          method: value\n        }, version);\n      }\n\n      return GenericExtrinsic._newFromValue(registry, value, version);\n    }\n    /** @internal */\n\n  }, {\n    key: \"_decodeU8a\",\n    value: function _decodeU8a(registry, value, version) {\n      if (!value.length) {\n        return GenericExtrinsic._newFromValue(registry, new Uint8Array(), version);\n      }\n\n      var _compactFromU8a = compactFromU8a(value),\n          _compactFromU8a2 = _slicedToArray(_compactFromU8a, 2),\n          offset = _compactFromU8a2[0],\n          length = _compactFromU8a2[1];\n\n      var total = offset + length.toNumber();\n      assert(total <= value.length, function () {\n        return \"Extrinsic: length less than remainder, expected at least \".concat(total, \", found \").concat(value.length);\n      });\n      var data = value.subarray(offset, total);\n      return GenericExtrinsic._newFromValue(registry, data.subarray(1), data[0]);\n    }\n  }]);\n\n  return GenericExtrinsic;\n}(ExtrinsicBase);","map":{"version":3,"sources":["/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/@polkadot/types/extrinsic/Extrinsic.js"],"names":["_defineProperty","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","assert","compactAddLength","compactFromU8a","isHex","isU8a","u8aConcat","u8aToHex","u8aToU8a","Base","BIT_SIGNED","BIT_UNSIGNED","DEFAULT_VERSION","UNMASK_VERSION","VERSIONS","EXTRINSIC_VERSION","LATEST_EXTRINSIC_VERSION","ExtrinsicBase","method","args","argsDef","callIndex","data","_raw","signature","era","toU8a","isSigned","meta","nonce","signer","tip","version","type","other","is","GenericExtrinsic","registry","value","_decodeExtrinsic","payload","addSignature","account","options","sign","signFake","isBare","isExpanded","toHuman","toHex","encoded","Uint8Array","createType","Array","isArray","_decodeU8a","createClass","_newFromValue","offset","total","toNumber","subarray"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, compactAddLength, compactFromU8a, isHex, isU8a, u8aConcat, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { Base } from \"../codec/Base.js\";\nimport { BIT_SIGNED, BIT_UNSIGNED, DEFAULT_VERSION, UNMASK_VERSION } from \"./constants.js\";\nconst VERSIONS = ['ExtrinsicUnknown', // v0 is unknown\n'ExtrinsicUnknown', 'ExtrinsicUnknown', 'ExtrinsicUnknown', 'ExtrinsicV4'];\nexport { EXTRINSIC_VERSION as LATEST_EXTRINSIC_VERSION } from \"./v4/Extrinsic.js\";\n\nclass ExtrinsicBase extends Base {\n  /**\n   * @description The arguments passed to for the call, exposes args so it is compatible with [[Call]]\n   */\n  get args() {\n    return this.method.args;\n  }\n  /**\n   * @description The argument definitions, compatible with [[Call]]\n   */\n\n\n  get argsDef() {\n    return this.method.argsDef;\n  }\n  /**\n   * @description The actual `[sectionIndex, methodIndex]` as used in the Call\n   */\n\n\n  get callIndex() {\n    return this.method.callIndex;\n  }\n  /**\n   * @description The actual data for the Call\n   */\n\n\n  get data() {\n    return this.method.data;\n  }\n  /**\n   * @description The era for this extrinsic\n   */\n\n\n  get era() {\n    return this._raw.signature.era;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return this.toU8a().length;\n  }\n  /**\n   * @description `true` id the extrinsic is signed\n   */\n\n\n  get isSigned() {\n    return this._raw.signature.isSigned;\n  }\n  /**\n   * @description The length of the actual data, excluding prefix\n   */\n\n\n  get length() {\n    return this.toU8a(true).length;\n  }\n  /**\n   * @description The [[FunctionMetadataLatest]] that describes the extrinsic\n   */\n\n\n  get meta() {\n    return this.method.meta;\n  }\n  /**\n   * @description The [[Call]] this extrinsic wraps\n   */\n\n\n  get method() {\n    return this._raw.method;\n  }\n  /**\n   * @description The nonce for this extrinsic\n   */\n\n\n  get nonce() {\n    return this._raw.signature.nonce;\n  }\n  /**\n   * @description The actual [[EcdsaSignature]], [[Ed25519Signature]] or [[Sr25519Signature]]\n   */\n\n\n  get signature() {\n    return this._raw.signature.signature;\n  }\n  /**\n   * @description The [[Address]] that signed\n   */\n\n\n  get signer() {\n    return this._raw.signature.signer;\n  }\n  /**\n   * @description Forwards compat\n   */\n\n\n  get tip() {\n    return this._raw.signature.tip;\n  }\n  /**\n   * @description Returns the raw transaction version (not flagged with signing information)\n  */\n\n\n  get type() {\n    return this._raw.version;\n  }\n  /**\n   * @description Returns the encoded version flag\n  */\n\n\n  get version() {\n    return this.type | (this.isSigned ? BIT_SIGNED : BIT_UNSIGNED);\n  }\n  /**\n   * @description Checks if the source matches this in type\n   */\n\n\n  is(other) {\n    return this.method.is(other);\n  }\n\n}\n/**\n * @name GenericExtrinsic\n * @description\n * Representation of an Extrinsic in the system. It contains the actual call,\n * (optional) signature and encodes with an actual length prefix\n *\n * {@link https://github.com/paritytech/wiki/blob/master/Extrinsic.md#the-extrinsic-format-for-node}.\n *\n * Can be:\n * - signed, to create a transaction\n * - left as is, to create an inherent\n */\n\n\nexport class GenericExtrinsic extends ExtrinsicBase {\n  constructor(registry, value, {\n    version\n  } = {}) {\n    super(registry, GenericExtrinsic._decodeExtrinsic(registry, value, version));\n  }\n  /** @internal */\n\n\n  static _newFromValue(registry, value, version) {\n    if (value instanceof GenericExtrinsic) {\n      return value._raw;\n    }\n\n    const isSigned = (version & BIT_SIGNED) === BIT_SIGNED;\n    const type = VERSIONS[version & UNMASK_VERSION] || VERSIONS[0]; // we cast here since the VERSION definition is incredibly broad - we don't have a\n    // slice for \"only add extrinsic types\", and more string definitions become unwieldy\n\n    return registry.createType(type, value, {\n      isSigned,\n      version\n    });\n  }\n  /** @internal */\n\n\n  static _decodeExtrinsic(registry, value, version = DEFAULT_VERSION) {\n    if (isU8a(value) || Array.isArray(value) || isHex(value)) {\n      return GenericExtrinsic._decodeU8a(registry, u8aToU8a(value), version);\n    } else if (value instanceof registry.createClass('Call')) {\n      return GenericExtrinsic._newFromValue(registry, {\n        method: value\n      }, version);\n    }\n\n    return GenericExtrinsic._newFromValue(registry, value, version);\n  }\n  /** @internal */\n\n\n  static _decodeU8a(registry, value, version) {\n    if (!value.length) {\n      return GenericExtrinsic._newFromValue(registry, new Uint8Array(), version);\n    }\n\n    const [offset, length] = compactFromU8a(value);\n    const total = offset + length.toNumber();\n    assert(total <= value.length, () => `Extrinsic: length less than remainder, expected at least ${total}, found ${value.length}`);\n    const data = value.subarray(offset, total);\n    return GenericExtrinsic._newFromValue(registry, data.subarray(1), data[0]);\n  }\n  /**\n   * @description Injects an already-generated signature into the extrinsic\n   */\n\n\n  addSignature(signer, signature, payload) {\n    this._raw.addSignature(signer, signature, payload);\n\n    return this;\n  }\n  /**\n   * @description Sign the extrinsic with a specific keypair\n   */\n\n\n  sign(account, options) {\n    this._raw.sign(account, options);\n\n    return this;\n  }\n  /**\n   * @describe Adds a fake signature to the extrinsic\n   */\n\n\n  signFake(signer, options) {\n    this._raw.signFake(signer, options);\n\n    return this;\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n\n\n  toHex(isBare) {\n    return u8aToHex(this.toU8a(isBare));\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman(isExpanded) {\n    return _objectSpread({\n      isSigned: this.isSigned,\n      method: this.method.toHuman(isExpanded)\n    }, this.isSigned ? {\n      era: this.era.toHuman(isExpanded),\n      nonce: this.nonce.toHuman(isExpanded),\n      signature: this.signature.toHex(),\n      signer: this.signer.toHuman(isExpanded),\n      tip: this.tip.toHuman(isExpanded)\n    } : {});\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n\n\n  toJSON() {\n    return this.toHex();\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return 'Extrinsic';\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value is not length-prefixed\n   */\n\n\n  toU8a(isBare) {\n    // we do not apply bare to the internal values, rather this only determines out length addition,\n    // where we strip all lengths this creates an extrinsic that cannot be decoded\n    const encoded = u8aConcat(new Uint8Array([this.version]), this._raw.toU8a());\n    return isBare ? encoded : compactAddLength(encoded);\n  }\n\n}"]},"metadata":{},"sourceType":"module"}