{"ast":null,"code":"import _slicedToArray from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _createClass from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _inherits from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, bnToBn, formatNumber, hexToU8a, isHex, isObject, isU8a, u8aToBn, u8aToU8a } from '@polkadot/util';\nimport { Enum } from \"../codec/Enum.js\";\nimport { Raw } from \"../codec/Raw.js\";\nimport { Tuple } from \"../codec/Tuple.js\";\nimport { u64 as U64 } from \"../primitive/U64.js\";\nimport { IMMORTAL_ERA } from \"./constants.js\";\n\nfunction getTrailingZeros(period) {\n  var binary = period.toString(2);\n  var index = 0;\n\n  while (binary[binary.length - 1 - index] === '0') {\n    index++;\n  }\n\n  return index;\n}\n/**\n * @name ImmortalEra\n * @description\n * The ImmortalEra for an extrinsic\n */\n\n\nexport var ImmortalEra = /*#__PURE__*/function (_Raw) {\n  _inherits(ImmortalEra, _Raw);\n\n  var _super = _createSuper(ImmortalEra);\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  function ImmortalEra(registry, value) {\n    _classCallCheck(this, ImmortalEra);\n\n    // For immortals, we always provide the known value (i.e. treated as a\n    // constant no matter how it is constructed - it is a fixed structure)\n    return _super.call(this, registry, IMMORTAL_ERA);\n  }\n\n  return ImmortalEra;\n}(Raw);\n/**\n * @name MortalEra\n * @description\n * The MortalEra for an extrinsic, indicating period and phase\n */\n\nexport var MortalEra = /*#__PURE__*/function (_Tuple) {\n  _inherits(MortalEra, _Tuple);\n\n  var _super2 = _createSuper(MortalEra);\n\n  function MortalEra(registry, value) {\n    _classCallCheck(this, MortalEra);\n\n    return _super2.call(this, registry, {\n      period: U64,\n      phase: U64\n    }, MortalEra._decodeMortalEra(registry, value));\n  }\n  /** @internal */\n\n\n  _createClass(MortalEra, [{\n    key: \"encodedLength\",\n    get:\n    /**\n     * @description Encoded length for mortals occupy 2 bytes, different from the actual Tuple since it is encoded. This is a shortcut fro `toU8a().length`\n     */\n    function get() {\n      return 2;\n    }\n    /**\n     * @description The period of this Mortal wraps as a [[U64]]\n     */\n\n  }, {\n    key: \"period\",\n    get: function get() {\n      return this[0];\n    }\n    /**\n     * @description The phase of this Mortal wraps as a [[U64]]\n     */\n\n  }, {\n    key: \"phase\",\n    get: function get() {\n      return this[1];\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n\n  }, {\n    key: \"toHuman\",\n    value: function toHuman() {\n      return {\n        period: formatNumber(this.period),\n        phase: formatNumber(this.phase)\n      };\n    }\n    /**\n     * @description Returns a JSON representation of the actual value\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.toHex();\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the parity-codec specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     * Period and phase are encoded:\n     *   - The period of validity from the block hash found in the signing material.\n     *   - The phase in the period that this transaction's lifetime begins (and, importantly,\n     *     implies which block hash is included in the signature material). If the `period` is\n     *     greater than 1 << 12, then it will be a factor of the times greater than 1<<12 that\n     *     `period` is.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"toU8a\",\n    value: function toU8a(isBare) {\n      var period = this.period.toNumber();\n      var phase = this.phase.toNumber();\n      var quantizeFactor = Math.max(period >> 12, 1);\n      var trailingZeros = getTrailingZeros(period);\n      var encoded = Math.min(15, Math.max(1, trailingZeros - 1)) + (phase / quantizeFactor << 4);\n      var first = encoded >> 8;\n      var second = encoded & 0xff;\n      return new Uint8Array([second, first]);\n    }\n    /**\n     * @description Get the block number of the start of the era whose properties this object describes that `current` belongs to.\n     */\n\n  }, {\n    key: \"birth\",\n    value: function birth(current) {\n      // FIXME No toNumber() here\n      return Math.floor((Math.max(bnToBn(current).toNumber(), this.phase.toNumber()) - this.phase.toNumber()) / this.period.toNumber()) * this.period.toNumber() + this.phase.toNumber();\n    }\n    /**\n     * @description Get the block number of the first block at which the era has ended.\n     */\n\n  }, {\n    key: \"death\",\n    value: function death(current) {\n      // FIXME No toNumber() here\n      return this.birth(current) + this.period.toNumber();\n    }\n  }], [{\n    key: \"_decodeMortalEra\",\n    value: function _decodeMortalEra(registry, value) {\n      if (!value) {\n        return [new U64(registry), new U64(registry)];\n      } else if (isU8a(value) || isHex(value) || Array.isArray(value)) {\n        return MortalEra._decodeMortalU8a(registry, u8aToU8a(value));\n      } else if (isObject(value)) {\n        return MortalEra._decodeMortalObject(registry, value);\n      }\n\n      throw new Error('Invalid data passed to Mortal era');\n    }\n    /** @internal */\n\n  }, {\n    key: \"_decodeMortalObject\",\n    value: function _decodeMortalObject(registry, value) {\n      var current = value.current,\n          period = value.period;\n      var calPeriod = Math.pow(2, Math.ceil(Math.log2(period)));\n      calPeriod = Math.min(Math.max(calPeriod, 4), 1 << 16);\n      var phase = current % calPeriod;\n      var quantizeFactor = Math.max(calPeriod >> 12, 1);\n      var quantizedPhase = phase / quantizeFactor * quantizeFactor;\n      return [new U64(registry, calPeriod), new U64(registry, quantizedPhase)];\n    }\n    /** @internal */\n\n  }, {\n    key: \"_decodeMortalU8a\",\n    value: function _decodeMortalU8a(registry, value) {\n      if (value.length === 0) {\n        return [new U64(registry), new U64(registry)];\n      }\n\n      var first = u8aToBn(value.subarray(0, 1)).toNumber();\n      var second = u8aToBn(value.subarray(1, 2)).toNumber();\n      var encoded = first + (second << 8);\n      var period = 2 << encoded % (1 << 4);\n      var quantizeFactor = Math.max(period >> 12, 1);\n      var phase = (encoded >> 4) * quantizeFactor;\n      assert(period >= 4 && phase < period, 'Invalid data passed to Mortal era');\n      return [new U64(registry, period), new U64(registry, phase)];\n    }\n  }]);\n\n  return MortalEra;\n}(Tuple);\n/**\n * @name GenericExtrinsicEra\n * @description\n * The era for an extrinsic, indicating either a mortal or immortal extrinsic\n */\n\nexport var GenericExtrinsicEra = /*#__PURE__*/function (_Enum) {\n  _inherits(GenericExtrinsicEra, _Enum);\n\n  var _super3 = _createSuper(GenericExtrinsicEra);\n\n  function GenericExtrinsicEra(registry, value) {\n    _classCallCheck(this, GenericExtrinsicEra);\n\n    return _super3.call(this, registry, {\n      ImmortalEra: ImmortalEra,\n      MortalEra: MortalEra\n    }, GenericExtrinsicEra._decodeExtrinsicEra(value));\n  }\n  /** @internal */\n  // eslint-disable-next-line @typescript-eslint/ban-types\n\n\n  _createClass(GenericExtrinsicEra, [{\n    key: \"encodedLength\",\n    get:\n    /**\n     * @description Override the encoded length method\n     */\n    function get() {\n      return this.isImmortalEra ? this.asImmortalEra.encodedLength : this.asMortalEra.encodedLength;\n    }\n    /**\n     * @description Returns the item as a [[ImmortalEra]]\n     */\n\n  }, {\n    key: \"asImmortalEra\",\n    get: function get() {\n      var _this = this;\n\n      assert(this.isImmortalEra, function () {\n        return \"Cannot convert '\".concat(_this.type, \"' via asImmortalEra\");\n      });\n      return this.value;\n    }\n    /**\n     * @description Returns the item as a [[MortalEra]]\n     */\n\n  }, {\n    key: \"asMortalEra\",\n    get: function get() {\n      var _this2 = this;\n\n      assert(this.isMortalEra, function () {\n        return \"Cannot convert '\".concat(_this2.type, \"' via asMortalEra\");\n      });\n      return this.value;\n    }\n    /**\n     * @description `true` if Immortal\n     */\n\n  }, {\n    key: \"isImmortalEra\",\n    get: function get() {\n      return this.index === 0;\n    }\n    /**\n     * @description `true` if Mortal\n     */\n\n  }, {\n    key: \"isMortalEra\",\n    get: function get() {\n      return this.index > 0;\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the parity-codec specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n\n  }, {\n    key: \"toU8a\",\n    value: function toU8a(isBare) {\n      return this.isMortalEra ? this.asMortalEra.toU8a(isBare) : this.asImmortalEra.toU8a(isBare);\n    }\n  }], [{\n    key: \"_decodeExtrinsicEra\",\n    value: function _decodeExtrinsicEra() {\n      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Uint8Array();\n\n      if (value instanceof GenericExtrinsicEra) {\n        return GenericExtrinsicEra._decodeExtrinsicEra(value.toU8a());\n      } else if (isHex(value)) {\n        return GenericExtrinsicEra._decodeExtrinsicEra(hexToU8a(value));\n      } else if (!value || isU8a(value)) {\n        return !(value !== null && value !== void 0 && value.length) || value[0] === 0 ? new Uint8Array([0]) : new Uint8Array([1, value[0], value[1]]);\n      } else if (isObject(value)) {\n        var entries = Object.entries(value).map(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              k = _ref2[0],\n              v = _ref2[1];\n\n          return [k.toLowerCase(), v];\n        });\n        var mortal = entries.find(function (_ref3) {\n          var _ref4 = _slicedToArray(_ref3, 1),\n              k = _ref4[0];\n\n          return k.toLowerCase() === 'mortalera';\n        });\n        var immortal = entries.find(function (_ref5) {\n          var _ref6 = _slicedToArray(_ref5, 1),\n              k = _ref6[0];\n\n          return k.toLowerCase() === 'immortalera';\n        }); // this is to de-serialize from JSON\n\n        return mortal ? {\n          MortalEra: mortal[1]\n        } : immortal ? {\n          ImmortalEra: immortal[1]\n        } : {\n          MortalEra: value\n        };\n      }\n\n      throw new Error('Invalid data passed to Era');\n    }\n  }]);\n\n  return GenericExtrinsicEra;\n}(Enum);","map":{"version":3,"sources":["/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/@polkadot/types/extrinsic/ExtrinsicEra.js"],"names":["assert","bnToBn","formatNumber","hexToU8a","isHex","isObject","isU8a","u8aToBn","u8aToU8a","Enum","Raw","Tuple","u64","U64","IMMORTAL_ERA","getTrailingZeros","period","binary","toString","index","length","ImmortalEra","registry","value","MortalEra","phase","_decodeMortalEra","toHex","isBare","toNumber","quantizeFactor","Math","max","trailingZeros","encoded","min","first","second","Uint8Array","current","floor","birth","Array","isArray","_decodeMortalU8a","_decodeMortalObject","Error","calPeriod","pow","ceil","log2","quantizedPhase","subarray","GenericExtrinsicEra","_decodeExtrinsicEra","isImmortalEra","asImmortalEra","encodedLength","asMortalEra","type","isMortalEra","toU8a","entries","Object","map","k","v","toLowerCase","mortal","find","immortal"],"mappings":";;;;;AAAA;AACA;AACA,SAASA,MAAT,EAAiBC,MAAjB,EAAyBC,YAAzB,EAAuCC,QAAvC,EAAiDC,KAAjD,EAAwDC,QAAxD,EAAkEC,KAAlE,EAAyEC,OAAzE,EAAkFC,QAAlF,QAAkG,gBAAlG;AACA,SAASC,IAAT,QAAqB,kBAArB;AACA,SAASC,GAAT,QAAoB,iBAApB;AACA,SAASC,KAAT,QAAsB,mBAAtB;AACA,SAASC,GAAG,IAAIC,GAAhB,QAA2B,qBAA3B;AACA,SAASC,YAAT,QAA6B,gBAA7B;;AAEA,SAASC,gBAAT,CAA0BC,MAA1B,EAAkC;AAChC,MAAMC,MAAM,GAAGD,MAAM,CAACE,QAAP,CAAgB,CAAhB,CAAf;AACA,MAAIC,KAAK,GAAG,CAAZ;;AAEA,SAAOF,MAAM,CAACA,MAAM,CAACG,MAAP,GAAgB,CAAhB,GAAoBD,KAArB,CAAN,KAAsC,GAA7C,EAAkD;AAChDA,IAAAA,KAAK;AACN;;AAED,SAAOA,KAAP;AACD;AACD;AACA;AACA;AACA;AACA;;;AAGA,WAAaE,WAAb;AAAA;;AAAA;;AACE;AACA,uBAAYC,QAAZ,EAAsBC,KAAtB,EAA6B;AAAA;;AAC3B;AACA;AAF2B,6BAGrBD,QAHqB,EAGXR,YAHW;AAI5B;;AANH;AAAA,EAAiCJ,GAAjC;AASA;AACA;AACA;AACA;AACA;;AAEA,WAAac,SAAb;AAAA;;AAAA;;AACE,qBAAYF,QAAZ,EAAsBC,KAAtB,EAA6B;AAAA;;AAAA,8BACrBD,QADqB,EACX;AACdN,MAAAA,MAAM,EAAEH,GADM;AAEdY,MAAAA,KAAK,EAAEZ;AAFO,KADW,EAIxBW,SAAS,CAACE,gBAAV,CAA2BJ,QAA3B,EAAqCC,KAArC,CAJwB;AAK5B;AACD;;;AAPF;AAAA;AAAA;AAqDE;AACF;AACA;AAGE,mBAAoB;AAClB,aAAO,CAAP;AACD;AACD;AACF;AACA;;AA/DA;AAAA;AAAA,SAkEE,eAAa;AACX,aAAO,KAAK,CAAL,CAAP;AACD;AACD;AACF;AACA;;AAvEA;AAAA;AAAA,SA0EE,eAAY;AACV,aAAO,KAAK,CAAL,CAAP;AACD;AACD;AACF;AACA;;AA/EA;AAAA;AAAA,WAkFE,mBAAU;AACR,aAAO;AACLP,QAAAA,MAAM,EAAEd,YAAY,CAAC,KAAKc,MAAN,CADf;AAELS,QAAAA,KAAK,EAAEvB,YAAY,CAAC,KAAKuB,KAAN;AAFd,OAAP;AAID;AACD;AACF;AACA;;AA1FA;AAAA;AAAA,WA6FE,kBAAS;AACP,aAAO,KAAKE,KAAL,EAAP;AACD;AACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE;;AA1GF;AAAA;AAAA,WA6GE,eAAMC,MAAN,EAAc;AACZ,UAAMZ,MAAM,GAAG,KAAKA,MAAL,CAAYa,QAAZ,EAAf;AACA,UAAMJ,KAAK,GAAG,KAAKA,KAAL,CAAWI,QAAX,EAAd;AACA,UAAMC,cAAc,GAAGC,IAAI,CAACC,GAAL,CAAShB,MAAM,IAAI,EAAnB,EAAuB,CAAvB,CAAvB;AACA,UAAMiB,aAAa,GAAGlB,gBAAgB,CAACC,MAAD,CAAtC;AACA,UAAMkB,OAAO,GAAGH,IAAI,CAACI,GAAL,CAAS,EAAT,EAAaJ,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYC,aAAa,GAAG,CAA5B,CAAb,KAAgDR,KAAK,GAAGK,cAAR,IAA0B,CAA1E,CAAhB;AACA,UAAMM,KAAK,GAAGF,OAAO,IAAI,CAAzB;AACA,UAAMG,MAAM,GAAGH,OAAO,GAAG,IAAzB;AACA,aAAO,IAAII,UAAJ,CAAe,CAACD,MAAD,EAASD,KAAT,CAAf,CAAP;AACD;AACD;AACF;AACA;;AAzHA;AAAA;AAAA,WA4HE,eAAMG,OAAN,EAAe;AACb;AACA,aAAOR,IAAI,CAACS,KAAL,CAAW,CAACT,IAAI,CAACC,GAAL,CAAS/B,MAAM,CAACsC,OAAD,CAAN,CAAgBV,QAAhB,EAAT,EAAqC,KAAKJ,KAAL,CAAWI,QAAX,EAArC,IAA8D,KAAKJ,KAAL,CAAWI,QAAX,EAA/D,IAAwF,KAAKb,MAAL,CAAYa,QAAZ,EAAnG,IAA6H,KAAKb,MAAL,CAAYa,QAAZ,EAA7H,GAAsJ,KAAKJ,KAAL,CAAWI,QAAX,EAA7J;AACD;AACD;AACF;AACA;;AAlIA;AAAA;AAAA,WAqIE,eAAMU,OAAN,EAAe;AACb;AACA,aAAO,KAAKE,KAAL,CAAWF,OAAX,IAAsB,KAAKvB,MAAL,CAAYa,QAAZ,EAA7B;AACD;AAxIH;AAAA;AAAA,WAUE,0BAAwBP,QAAxB,EAAkCC,KAAlC,EAAyC;AACvC,UAAI,CAACA,KAAL,EAAY;AACV,eAAO,CAAC,IAAIV,GAAJ,CAAQS,QAAR,CAAD,EAAoB,IAAIT,GAAJ,CAAQS,QAAR,CAApB,CAAP;AACD,OAFD,MAEO,IAAIhB,KAAK,CAACiB,KAAD,CAAL,IAAgBnB,KAAK,CAACmB,KAAD,CAArB,IAAgCmB,KAAK,CAACC,OAAN,CAAcpB,KAAd,CAApC,EAA0D;AAC/D,eAAOC,SAAS,CAACoB,gBAAV,CAA2BtB,QAA3B,EAAqCd,QAAQ,CAACe,KAAD,CAA7C,CAAP;AACD,OAFM,MAEA,IAAIlB,QAAQ,CAACkB,KAAD,CAAZ,EAAqB;AAC1B,eAAOC,SAAS,CAACqB,mBAAV,CAA8BvB,QAA9B,EAAwCC,KAAxC,CAAP;AACD;;AAED,YAAM,IAAIuB,KAAJ,CAAU,mCAAV,CAAN;AACD;AACD;;AArBF;AAAA;AAAA,WAwBE,6BAA2BxB,QAA3B,EAAqCC,KAArC,EAA4C;AAC1C,UACEgB,OADF,GAGIhB,KAHJ,CACEgB,OADF;AAAA,UAEEvB,MAFF,GAGIO,KAHJ,CAEEP,MAFF;AAIA,UAAI+B,SAAS,GAAGhB,IAAI,CAACiB,GAAL,CAAS,CAAT,EAAYjB,IAAI,CAACkB,IAAL,CAAUlB,IAAI,CAACmB,IAAL,CAAUlC,MAAV,CAAV,CAAZ,CAAhB;AACA+B,MAAAA,SAAS,GAAGhB,IAAI,CAACI,GAAL,CAASJ,IAAI,CAACC,GAAL,CAASe,SAAT,EAAoB,CAApB,CAAT,EAAiC,KAAK,EAAtC,CAAZ;AACA,UAAMtB,KAAK,GAAGc,OAAO,GAAGQ,SAAxB;AACA,UAAMjB,cAAc,GAAGC,IAAI,CAACC,GAAL,CAASe,SAAS,IAAI,EAAtB,EAA0B,CAA1B,CAAvB;AACA,UAAMI,cAAc,GAAG1B,KAAK,GAAGK,cAAR,GAAyBA,cAAhD;AACA,aAAO,CAAC,IAAIjB,GAAJ,CAAQS,QAAR,EAAkByB,SAAlB,CAAD,EAA+B,IAAIlC,GAAJ,CAAQS,QAAR,EAAkB6B,cAAlB,CAA/B,CAAP;AACD;AACD;;AApCF;AAAA;AAAA,WAuCE,0BAAwB7B,QAAxB,EAAkCC,KAAlC,EAAyC;AACvC,UAAIA,KAAK,CAACH,MAAN,KAAiB,CAArB,EAAwB;AACtB,eAAO,CAAC,IAAIP,GAAJ,CAAQS,QAAR,CAAD,EAAoB,IAAIT,GAAJ,CAAQS,QAAR,CAApB,CAAP;AACD;;AAED,UAAMc,KAAK,GAAG7B,OAAO,CAACgB,KAAK,CAAC6B,QAAN,CAAe,CAAf,EAAkB,CAAlB,CAAD,CAAP,CAA8BvB,QAA9B,EAAd;AACA,UAAMQ,MAAM,GAAG9B,OAAO,CAACgB,KAAK,CAAC6B,QAAN,CAAe,CAAf,EAAkB,CAAlB,CAAD,CAAP,CAA8BvB,QAA9B,EAAf;AACA,UAAMK,OAAO,GAAGE,KAAK,IAAIC,MAAM,IAAI,CAAd,CAArB;AACA,UAAMrB,MAAM,GAAG,KAAKkB,OAAO,IAAI,KAAK,CAAT,CAA3B;AACA,UAAMJ,cAAc,GAAGC,IAAI,CAACC,GAAL,CAAShB,MAAM,IAAI,EAAnB,EAAuB,CAAvB,CAAvB;AACA,UAAMS,KAAK,GAAG,CAACS,OAAO,IAAI,CAAZ,IAAiBJ,cAA/B;AACA9B,MAAAA,MAAM,CAACgB,MAAM,IAAI,CAAV,IAAeS,KAAK,GAAGT,MAAxB,EAAgC,mCAAhC,CAAN;AACA,aAAO,CAAC,IAAIH,GAAJ,CAAQS,QAAR,EAAkBN,MAAlB,CAAD,EAA4B,IAAIH,GAAJ,CAAQS,QAAR,EAAkBG,KAAlB,CAA5B,CAAP;AACD;AApDH;;AAAA;AAAA,EAA+Bd,KAA/B;AA2IA;AACA;AACA;AACA;AACA;;AAEA,WAAa0C,mBAAb;AAAA;;AAAA;;AACE,+BAAY/B,QAAZ,EAAsBC,KAAtB,EAA6B;AAAA;;AAAA,8BACrBD,QADqB,EACX;AACdD,MAAAA,WAAW,EAAXA,WADc;AAEdG,MAAAA,SAAS,EAATA;AAFc,KADW,EAIxB6B,mBAAmB,CAACC,mBAApB,CAAwC/B,KAAxC,CAJwB;AAK5B;AACD;AACA;;;AARF;AAAA;AAAA;AAkCE;AACF;AACA;AAGE,mBAAoB;AAClB,aAAO,KAAKgC,aAAL,GAAqB,KAAKC,aAAL,CAAmBC,aAAxC,GAAwD,KAAKC,WAAL,CAAiBD,aAAhF;AACD;AACD;AACF;AACA;;AA5CA;AAAA;AAAA,SA+CE,eAAoB;AAAA;;AAClBzD,MAAAA,MAAM,CAAC,KAAKuD,aAAN,EAAqB;AAAA,yCAAyB,KAAI,CAACI,IAA9B;AAAA,OAArB,CAAN;AACA,aAAO,KAAKpC,KAAZ;AACD;AACD;AACF;AACA;;AArDA;AAAA;AAAA,SAwDE,eAAkB;AAAA;;AAChBvB,MAAAA,MAAM,CAAC,KAAK4D,WAAN,EAAmB;AAAA,yCAAyB,MAAI,CAACD,IAA9B;AAAA,OAAnB,CAAN;AACA,aAAO,KAAKpC,KAAZ;AACD;AACD;AACF;AACA;;AA9DA;AAAA;AAAA,SAiEE,eAAoB;AAClB,aAAO,KAAKJ,KAAL,KAAe,CAAtB;AACD;AACD;AACF;AACA;;AAtEA;AAAA;AAAA,SAyEE,eAAkB;AAChB,aAAO,KAAKA,KAAL,GAAa,CAApB;AACD;AACD;AACF;AACA;AACA;;AA/EA;AAAA;AAAA,WAkFE,eAAMS,MAAN,EAAc;AACZ,aAAO,KAAKgC,WAAL,GAAmB,KAAKF,WAAL,CAAiBG,KAAjB,CAAuBjC,MAAvB,CAAnB,GAAoD,KAAK4B,aAAL,CAAmBK,KAAnB,CAAyBjC,MAAzB,CAA3D;AACD;AApFH;AAAA;AAAA,WAWE,+BAAqD;AAAA,UAA1BL,KAA0B,uEAAlB,IAAIe,UAAJ,EAAkB;;AACnD,UAAIf,KAAK,YAAY8B,mBAArB,EAA0C;AACxC,eAAOA,mBAAmB,CAACC,mBAApB,CAAwC/B,KAAK,CAACsC,KAAN,EAAxC,CAAP;AACD,OAFD,MAEO,IAAIzD,KAAK,CAACmB,KAAD,CAAT,EAAkB;AACvB,eAAO8B,mBAAmB,CAACC,mBAApB,CAAwCnD,QAAQ,CAACoB,KAAD,CAAhD,CAAP;AACD,OAFM,MAEA,IAAI,CAACA,KAAD,IAAUjB,KAAK,CAACiB,KAAD,CAAnB,EAA4B;AACjC,eAAO,EAAEA,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAK,KAAK,CAAjC,IAAsCA,KAAK,CAACH,MAA9C,KAAyDG,KAAK,CAAC,CAAD,CAAL,KAAa,CAAtE,GAA0E,IAAIe,UAAJ,CAAe,CAAC,CAAD,CAAf,CAA1E,GAAgG,IAAIA,UAAJ,CAAe,CAAC,CAAD,EAAIf,KAAK,CAAC,CAAD,CAAT,EAAcA,KAAK,CAAC,CAAD,CAAnB,CAAf,CAAvG;AACD,OAFM,MAEA,IAAIlB,QAAQ,CAACkB,KAAD,CAAZ,EAAqB;AAC1B,YAAMuC,OAAO,GAAGC,MAAM,CAACD,OAAP,CAAevC,KAAf,EAAsByC,GAAtB,CAA0B;AAAA;AAAA,cAAEC,CAAF;AAAA,cAAKC,CAAL;;AAAA,iBAAY,CAACD,CAAC,CAACE,WAAF,EAAD,EAAkBD,CAAlB,CAAZ;AAAA,SAA1B,CAAhB;AACA,YAAME,MAAM,GAAGN,OAAO,CAACO,IAAR,CAAa;AAAA;AAAA,cAAEJ,CAAF;;AAAA,iBAASA,CAAC,CAACE,WAAF,OAAoB,WAA7B;AAAA,SAAb,CAAf;AACA,YAAMG,QAAQ,GAAGR,OAAO,CAACO,IAAR,CAAa;AAAA;AAAA,cAAEJ,CAAF;;AAAA,iBAASA,CAAC,CAACE,WAAF,OAAoB,aAA7B;AAAA,SAAb,CAAjB,CAH0B,CAGiD;;AAE3E,eAAOC,MAAM,GAAG;AACd5C,UAAAA,SAAS,EAAE4C,MAAM,CAAC,CAAD;AADH,SAAH,GAETE,QAAQ,GAAG;AACbjD,UAAAA,WAAW,EAAEiD,QAAQ,CAAC,CAAD;AADR,SAAH,GAER;AACF9C,UAAAA,SAAS,EAAED;AADT,SAJJ;AAOD;;AAED,YAAM,IAAIuB,KAAJ,CAAU,4BAAV,CAAN;AACD;AAjCH;;AAAA;AAAA,EAAyCrC,IAAzC","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, bnToBn, formatNumber, hexToU8a, isHex, isObject, isU8a, u8aToBn, u8aToU8a } from '@polkadot/util';\nimport { Enum } from \"../codec/Enum.js\";\nimport { Raw } from \"../codec/Raw.js\";\nimport { Tuple } from \"../codec/Tuple.js\";\nimport { u64 as U64 } from \"../primitive/U64.js\";\nimport { IMMORTAL_ERA } from \"./constants.js\";\n\nfunction getTrailingZeros(period) {\n  const binary = period.toString(2);\n  let index = 0;\n\n  while (binary[binary.length - 1 - index] === '0') {\n    index++;\n  }\n\n  return index;\n}\n/**\n * @name ImmortalEra\n * @description\n * The ImmortalEra for an extrinsic\n */\n\n\nexport class ImmortalEra extends Raw {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  constructor(registry, value) {\n    // For immortals, we always provide the known value (i.e. treated as a\n    // constant no matter how it is constructed - it is a fixed structure)\n    super(registry, IMMORTAL_ERA);\n  }\n\n}\n/**\n * @name MortalEra\n * @description\n * The MortalEra for an extrinsic, indicating period and phase\n */\n\nexport class MortalEra extends Tuple {\n  constructor(registry, value) {\n    super(registry, {\n      period: U64,\n      phase: U64\n    }, MortalEra._decodeMortalEra(registry, value));\n  }\n  /** @internal */\n\n\n  static _decodeMortalEra(registry, value) {\n    if (!value) {\n      return [new U64(registry), new U64(registry)];\n    } else if (isU8a(value) || isHex(value) || Array.isArray(value)) {\n      return MortalEra._decodeMortalU8a(registry, u8aToU8a(value));\n    } else if (isObject(value)) {\n      return MortalEra._decodeMortalObject(registry, value);\n    }\n\n    throw new Error('Invalid data passed to Mortal era');\n  }\n  /** @internal */\n\n\n  static _decodeMortalObject(registry, value) {\n    const {\n      current,\n      period\n    } = value;\n    let calPeriod = Math.pow(2, Math.ceil(Math.log2(period)));\n    calPeriod = Math.min(Math.max(calPeriod, 4), 1 << 16);\n    const phase = current % calPeriod;\n    const quantizeFactor = Math.max(calPeriod >> 12, 1);\n    const quantizedPhase = phase / quantizeFactor * quantizeFactor;\n    return [new U64(registry, calPeriod), new U64(registry, quantizedPhase)];\n  }\n  /** @internal */\n\n\n  static _decodeMortalU8a(registry, value) {\n    if (value.length === 0) {\n      return [new U64(registry), new U64(registry)];\n    }\n\n    const first = u8aToBn(value.subarray(0, 1)).toNumber();\n    const second = u8aToBn(value.subarray(1, 2)).toNumber();\n    const encoded = first + (second << 8);\n    const period = 2 << encoded % (1 << 4);\n    const quantizeFactor = Math.max(period >> 12, 1);\n    const phase = (encoded >> 4) * quantizeFactor;\n    assert(period >= 4 && phase < period, 'Invalid data passed to Mortal era');\n    return [new U64(registry, period), new U64(registry, phase)];\n  }\n  /**\n   * @description Encoded length for mortals occupy 2 bytes, different from the actual Tuple since it is encoded. This is a shortcut fro `toU8a().length`\n   */\n\n\n  get encodedLength() {\n    return 2;\n  }\n  /**\n   * @description The period of this Mortal wraps as a [[U64]]\n   */\n\n\n  get period() {\n    return this[0];\n  }\n  /**\n   * @description The phase of this Mortal wraps as a [[U64]]\n   */\n\n\n  get phase() {\n    return this[1];\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman() {\n    return {\n      period: formatNumber(this.period),\n      phase: formatNumber(this.phase)\n    };\n  }\n  /**\n   * @description Returns a JSON representation of the actual value\n   */\n\n\n  toJSON() {\n    return this.toHex();\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the parity-codec specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   * Period and phase are encoded:\n   *   - The period of validity from the block hash found in the signing material.\n   *   - The phase in the period that this transaction's lifetime begins (and, importantly,\n   *     implies which block hash is included in the signature material). If the `period` is\n   *     greater than 1 << 12, then it will be a factor of the times greater than 1<<12 that\n   *     `period` is.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  toU8a(isBare) {\n    const period = this.period.toNumber();\n    const phase = this.phase.toNumber();\n    const quantizeFactor = Math.max(period >> 12, 1);\n    const trailingZeros = getTrailingZeros(period);\n    const encoded = Math.min(15, Math.max(1, trailingZeros - 1)) + (phase / quantizeFactor << 4);\n    const first = encoded >> 8;\n    const second = encoded & 0xff;\n    return new Uint8Array([second, first]);\n  }\n  /**\n   * @description Get the block number of the start of the era whose properties this object describes that `current` belongs to.\n   */\n\n\n  birth(current) {\n    // FIXME No toNumber() here\n    return Math.floor((Math.max(bnToBn(current).toNumber(), this.phase.toNumber()) - this.phase.toNumber()) / this.period.toNumber()) * this.period.toNumber() + this.phase.toNumber();\n  }\n  /**\n   * @description Get the block number of the first block at which the era has ended.\n   */\n\n\n  death(current) {\n    // FIXME No toNumber() here\n    return this.birth(current) + this.period.toNumber();\n  }\n\n}\n/**\n * @name GenericExtrinsicEra\n * @description\n * The era for an extrinsic, indicating either a mortal or immortal extrinsic\n */\n\nexport class GenericExtrinsicEra extends Enum {\n  constructor(registry, value) {\n    super(registry, {\n      ImmortalEra,\n      MortalEra\n    }, GenericExtrinsicEra._decodeExtrinsicEra(value));\n  }\n  /** @internal */\n  // eslint-disable-next-line @typescript-eslint/ban-types\n\n\n  static _decodeExtrinsicEra(value = new Uint8Array()) {\n    if (value instanceof GenericExtrinsicEra) {\n      return GenericExtrinsicEra._decodeExtrinsicEra(value.toU8a());\n    } else if (isHex(value)) {\n      return GenericExtrinsicEra._decodeExtrinsicEra(hexToU8a(value));\n    } else if (!value || isU8a(value)) {\n      return !(value !== null && value !== void 0 && value.length) || value[0] === 0 ? new Uint8Array([0]) : new Uint8Array([1, value[0], value[1]]);\n    } else if (isObject(value)) {\n      const entries = Object.entries(value).map(([k, v]) => [k.toLowerCase(), v]);\n      const mortal = entries.find(([k]) => k.toLowerCase() === 'mortalera');\n      const immortal = entries.find(([k]) => k.toLowerCase() === 'immortalera'); // this is to de-serialize from JSON\n\n      return mortal ? {\n        MortalEra: mortal[1]\n      } : immortal ? {\n        ImmortalEra: immortal[1]\n      } : {\n        MortalEra: value\n      };\n    }\n\n    throw new Error('Invalid data passed to Era');\n  }\n  /**\n   * @description Override the encoded length method\n   */\n\n\n  get encodedLength() {\n    return this.isImmortalEra ? this.asImmortalEra.encodedLength : this.asMortalEra.encodedLength;\n  }\n  /**\n   * @description Returns the item as a [[ImmortalEra]]\n   */\n\n\n  get asImmortalEra() {\n    assert(this.isImmortalEra, () => `Cannot convert '${this.type}' via asImmortalEra`);\n    return this.value;\n  }\n  /**\n   * @description Returns the item as a [[MortalEra]]\n   */\n\n\n  get asMortalEra() {\n    assert(this.isMortalEra, () => `Cannot convert '${this.type}' via asMortalEra`);\n    return this.value;\n  }\n  /**\n   * @description `true` if Immortal\n   */\n\n\n  get isImmortalEra() {\n    return this.index === 0;\n  }\n  /**\n   * @description `true` if Mortal\n   */\n\n\n  get isMortalEra() {\n    return this.index > 0;\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the parity-codec specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    return this.isMortalEra ? this.asMortalEra.toU8a(isBare) : this.asImmortalEra.toU8a(isBare);\n  }\n\n}"]},"metadata":{},"sourceType":"module"}