{"ast":null,"code":"// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert } from '@polkadot/util';\n\nfunction isNotNested() {\n  for (var _len = arguments.length, counters = new Array(_len), _key = 0; _key < _len; _key++) {\n    counters[_key] = arguments[_key];\n  }\n\n  return !counters.some(function (counter) {\n    return counter !== 0;\n  });\n} // safely split a string on ', ' while taking care of any nested occurences\n\n\nexport function typeSplit(type) {\n  var cDepth = 0,\n      fDepth = 0,\n      sDepth = 0,\n      tDepth = 0,\n      start = 0;\n  var result = [];\n\n  var extract = function extract(index) {\n    if (isNotNested(cDepth, fDepth, sDepth, tDepth)) {\n      result.push(type.substr(start, index - start).trim());\n      start = index + 1;\n    }\n  };\n\n  for (var index = 0; index < type.length; index++) {\n    switch (type[index]) {\n      // if we are not nested, add the type\n      case ',':\n        extract(index);\n        break;\n      // adjust compact/vec (and friends) depth\n\n      case '<':\n        cDepth++;\n        break;\n\n      case '>':\n        cDepth--;\n        break;\n      // adjust fixed vec depths\n\n      case '[':\n        fDepth++;\n        break;\n\n      case ']':\n        fDepth--;\n        break;\n      // adjust struct depth\n\n      case '{':\n        sDepth++;\n        break;\n\n      case '}':\n        sDepth--;\n        break;\n      // adjust tuple depth\n\n      case '(':\n        tDepth++;\n        break;\n\n      case ')':\n        tDepth--;\n        break;\n    }\n  }\n\n  assert(isNotNested(cDepth, fDepth, sDepth, tDepth), function () {\n    return \"Invalid definition (missing terminators) found in \".concat(type);\n  }); // the final leg of the journey\n\n  result.push(type.substr(start, type.length - start).trim());\n  return result;\n}","map":{"version":3,"sources":["/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/@polkadot/types/create/typeSplit.js"],"names":["assert","isNotNested","counters","some","counter","typeSplit","type","cDepth","fDepth","sDepth","tDepth","start","result","extract","index","push","substr","trim","length"],"mappings":"AAAA;AACA;AACA,SAASA,MAAT,QAAuB,gBAAvB;;AAEA,SAASC,WAAT,GAAkC;AAAA,oCAAVC,QAAU;AAAVA,IAAAA,QAAU;AAAA;;AAChC,SAAO,CAACA,QAAQ,CAACC,IAAT,CAAc,UAAAC,OAAO;AAAA,WAAIA,OAAO,KAAK,CAAhB;AAAA,GAArB,CAAR;AACD,C,CAAC;;;AAGF,OAAO,SAASC,SAAT,CAAmBC,IAAnB,EAAyB;AAC9B,MAAKC,MAAL,GAA+C,CAA/C;AAAA,MAAaC,MAAb,GAAkD,CAAlD;AAAA,MAAqBC,MAArB,GAAqD,CAArD;AAAA,MAA6BC,MAA7B,GAAwD,CAAxD;AAAA,MAAqCC,KAArC,GAA2D,CAA3D;AACA,MAAMC,MAAM,GAAG,EAAf;;AAEA,MAAMC,OAAO,GAAG,SAAVA,OAAU,CAAAC,KAAK,EAAI;AACvB,QAAIb,WAAW,CAACM,MAAD,EAASC,MAAT,EAAiBC,MAAjB,EAAyBC,MAAzB,CAAf,EAAiD;AAC/CE,MAAAA,MAAM,CAACG,IAAP,CAAYT,IAAI,CAACU,MAAL,CAAYL,KAAZ,EAAmBG,KAAK,GAAGH,KAA3B,EAAkCM,IAAlC,EAAZ;AACAN,MAAAA,KAAK,GAAGG,KAAK,GAAG,CAAhB;AACD;AACF,GALD;;AAOA,OAAK,IAAIA,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGR,IAAI,CAACY,MAAjC,EAAyCJ,KAAK,EAA9C,EAAkD;AAChD,YAAQR,IAAI,CAACQ,KAAD,CAAZ;AACE;AACA,WAAK,GAAL;AACED,QAAAA,OAAO,CAACC,KAAD,CAAP;AACA;AACF;;AAEA,WAAK,GAAL;AACEP,QAAAA,MAAM;AACN;;AAEF,WAAK,GAAL;AACEA,QAAAA,MAAM;AACN;AACF;;AAEA,WAAK,GAAL;AACEC,QAAAA,MAAM;AACN;;AAEF,WAAK,GAAL;AACEA,QAAAA,MAAM;AACN;AACF;;AAEA,WAAK,GAAL;AACEC,QAAAA,MAAM;AACN;;AAEF,WAAK,GAAL;AACEA,QAAAA,MAAM;AACN;AACF;;AAEA,WAAK,GAAL;AACEC,QAAAA,MAAM;AACN;;AAEF,WAAK,GAAL;AACEA,QAAAA,MAAM;AACN;AAxCJ;AA0CD;;AAEDV,EAAAA,MAAM,CAACC,WAAW,CAACM,MAAD,EAASC,MAAT,EAAiBC,MAAjB,EAAyBC,MAAzB,CAAZ,EAA8C;AAAA,uEAA2DJ,IAA3D;AAAA,GAA9C,CAAN,CAxD8B,CAwD0F;;AAExHM,EAAAA,MAAM,CAACG,IAAP,CAAYT,IAAI,CAACU,MAAL,CAAYL,KAAZ,EAAmBL,IAAI,CAACY,MAAL,GAAcP,KAAjC,EAAwCM,IAAxC,EAAZ;AACA,SAAOL,MAAP;AACD","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert } from '@polkadot/util';\n\nfunction isNotNested(...counters) {\n  return !counters.some(counter => counter !== 0);\n} // safely split a string on ', ' while taking care of any nested occurences\n\n\nexport function typeSplit(type) {\n  let [cDepth, fDepth, sDepth, tDepth, start] = [0, 0, 0, 0, 0];\n  const result = [];\n\n  const extract = index => {\n    if (isNotNested(cDepth, fDepth, sDepth, tDepth)) {\n      result.push(type.substr(start, index - start).trim());\n      start = index + 1;\n    }\n  };\n\n  for (let index = 0; index < type.length; index++) {\n    switch (type[index]) {\n      // if we are not nested, add the type\n      case ',':\n        extract(index);\n        break;\n      // adjust compact/vec (and friends) depth\n\n      case '<':\n        cDepth++;\n        break;\n\n      case '>':\n        cDepth--;\n        break;\n      // adjust fixed vec depths\n\n      case '[':\n        fDepth++;\n        break;\n\n      case ']':\n        fDepth--;\n        break;\n      // adjust struct depth\n\n      case '{':\n        sDepth++;\n        break;\n\n      case '}':\n        sDepth--;\n        break;\n      // adjust tuple depth\n\n      case '(':\n        tDepth++;\n        break;\n\n      case ')':\n        tDepth--;\n        break;\n    }\n  }\n\n  assert(isNotNested(cDepth, fDepth, sDepth, tDepth), () => `Invalid definition (missing terminators) found in ${type}`); // the final leg of the journey\n\n  result.push(type.substr(start, type.length - start).trim());\n  return result;\n}"]},"metadata":{},"sourceType":"module"}