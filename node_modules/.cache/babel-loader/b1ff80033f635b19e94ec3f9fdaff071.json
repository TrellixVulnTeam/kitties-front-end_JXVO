{"ast":null,"code":"import _slicedToArray from \"/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n// Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { combineLatest, map, of, switchMap } from 'rxjs';\nimport { memo } from \"../util/index.js\";\n\nfunction parseDetails(stashId, controllerIdOpt, nominatorsOpt, rewardDestination, validatorPrefs, exposure, stakingLedgerOpt) {\n  return {\n    accountId: stashId,\n    controllerId: controllerIdOpt && controllerIdOpt.unwrapOr(null),\n    exposure: exposure,\n    nominators: nominatorsOpt.isSome ? nominatorsOpt.unwrap().targets : [],\n    rewardDestination: rewardDestination,\n    stakingLedger: stakingLedgerOpt.unwrapOrDefault(),\n    stashId: stashId,\n    validatorPrefs: validatorPrefs\n  };\n}\n\nfunction getLedgers(api, optIds, _ref) {\n  var _ref$withLedger = _ref.withLedger,\n      withLedger = _ref$withLedger === void 0 ? false : _ref$withLedger;\n  var ids = optIds.filter(function (opt) {\n    return withLedger && !!opt && opt.isSome;\n  }).map(function (opt) {\n    return opt.unwrap();\n  });\n  var emptyLed = api.registry.createType('Option<StakingLedger>');\n  return (ids.length ? api.query.staking.ledger.multi(ids) : of([])).pipe(map(function (optLedgers) {\n    var offset = -1;\n    return optIds.map(function (opt) {\n      return opt && opt.isSome ? optLedgers[++offset] || emptyLed : emptyLed;\n    });\n  }));\n}\n\nfunction getStashInfo(api, stashIds, activeEra, _ref2) {\n  var withController = _ref2.withController,\n      withDestination = _ref2.withDestination,\n      withExposure = _ref2.withExposure,\n      withLedger = _ref2.withLedger,\n      withNominations = _ref2.withNominations,\n      withPrefs = _ref2.withPrefs;\n  var emptyNoms = api.registry.createType('Option<Nominations>');\n  var emptyRewa = api.registry.createType('RewardDestination');\n  var emptyExpo = api.registry.createType('Exposure');\n  var emptyPrefs = api.registry.createType('ValidatorPrefs');\n  return combineLatest([withController || withLedger ? api.query.staking.bonded.multi(stashIds) : of(stashIds.map(function () {\n    return null;\n  })), withNominations ? api.query.staking.nominators.multi(stashIds) : of(stashIds.map(function () {\n    return emptyNoms;\n  })), withDestination ? api.query.staking.payee.multi(stashIds) : of(stashIds.map(function () {\n    return emptyRewa;\n  })), withPrefs ? api.query.staking.validators.multi(stashIds) : of(stashIds.map(function () {\n    return emptyPrefs;\n  })), withExposure ? api.query.staking.erasStakers.multi(stashIds.map(function (stashId) {\n    return [activeEra, stashId];\n  })) : of(stashIds.map(function () {\n    return emptyExpo;\n  }))]);\n}\n\nfunction getBatch(api, activeEra, stashIds, flags) {\n  return getStashInfo(api, stashIds, activeEra, flags).pipe(switchMap(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 5),\n        controllerIdOpt = _ref4[0],\n        nominatorsOpt = _ref4[1],\n        rewardDestination = _ref4[2],\n        validatorPrefs = _ref4[3],\n        exposure = _ref4[4];\n\n    return getLedgers(api, controllerIdOpt, flags).pipe(map(function (stakingLedgerOpts) {\n      return stashIds.map(function (stashId, index) {\n        return parseDetails(stashId, controllerIdOpt[index], nominatorsOpt[index], rewardDestination[index], validatorPrefs[index], exposure[index], stakingLedgerOpts[index]);\n      });\n    }));\n  }));\n} //\n\n/**\n * @description From a stash, retrieve the controllerId and all relevant details\n */\n\n\nexport function query(instanceId, api) {\n  return memo(instanceId, function (accountId, flags) {\n    return api.derive.staking.queryMulti([accountId], flags).pipe(map(function (_ref5) {\n      var _ref6 = _slicedToArray(_ref5, 1),\n          first = _ref6[0];\n\n      return first;\n    }));\n  });\n}\nexport function queryMulti(instanceId, api) {\n  return memo(instanceId, function (accountIds, flags) {\n    return accountIds.length ? api.derive.session.indexes().pipe(switchMap(function (_ref7) {\n      var activeEra = _ref7.activeEra;\n      var stashIds = accountIds.map(function (accountId) {\n        return api.registry.createType('AccountId', accountId);\n      });\n      return getBatch(api, activeEra, stashIds, flags);\n    })) : of([]);\n  });\n}","map":{"version":3,"sources":["/home/spren/workspace/slides/advanced/term-03/03_polkadot-js-api/kitties/frontend/node_modules/@polkadot/api-derive/staking/query.js"],"names":["combineLatest","map","of","switchMap","memo","parseDetails","stashId","controllerIdOpt","nominatorsOpt","rewardDestination","validatorPrefs","exposure","stakingLedgerOpt","accountId","controllerId","unwrapOr","nominators","isSome","unwrap","targets","stakingLedger","unwrapOrDefault","getLedgers","api","optIds","withLedger","ids","filter","opt","emptyLed","registry","createType","length","query","staking","ledger","multi","pipe","optLedgers","offset","getStashInfo","stashIds","activeEra","withController","withDestination","withExposure","withNominations","withPrefs","emptyNoms","emptyRewa","emptyExpo","emptyPrefs","bonded","payee","validators","erasStakers","getBatch","flags","stakingLedgerOpts","index","instanceId","derive","queryMulti","first","accountIds","session","indexes"],"mappings":"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","sourcesContent":["// Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { combineLatest, map, of, switchMap } from 'rxjs';\nimport { memo } from \"../util/index.js\";\n\nfunction parseDetails(stashId, controllerIdOpt, nominatorsOpt, rewardDestination, validatorPrefs, exposure, stakingLedgerOpt) {\n  return {\n    accountId: stashId,\n    controllerId: controllerIdOpt && controllerIdOpt.unwrapOr(null),\n    exposure,\n    nominators: nominatorsOpt.isSome ? nominatorsOpt.unwrap().targets : [],\n    rewardDestination,\n    stakingLedger: stakingLedgerOpt.unwrapOrDefault(),\n    stashId,\n    validatorPrefs\n  };\n}\n\nfunction getLedgers(api, optIds, {\n  withLedger = false\n}) {\n  const ids = optIds.filter(opt => withLedger && !!opt && opt.isSome).map(opt => opt.unwrap());\n  const emptyLed = api.registry.createType('Option<StakingLedger>');\n  return (ids.length ? api.query.staking.ledger.multi(ids) : of([])).pipe(map(optLedgers => {\n    let offset = -1;\n    return optIds.map(opt => opt && opt.isSome ? optLedgers[++offset] || emptyLed : emptyLed);\n  }));\n}\n\nfunction getStashInfo(api, stashIds, activeEra, {\n  withController,\n  withDestination,\n  withExposure,\n  withLedger,\n  withNominations,\n  withPrefs\n}) {\n  const emptyNoms = api.registry.createType('Option<Nominations>');\n  const emptyRewa = api.registry.createType('RewardDestination');\n  const emptyExpo = api.registry.createType('Exposure');\n  const emptyPrefs = api.registry.createType('ValidatorPrefs');\n  return combineLatest([withController || withLedger ? api.query.staking.bonded.multi(stashIds) : of(stashIds.map(() => null)), withNominations ? api.query.staking.nominators.multi(stashIds) : of(stashIds.map(() => emptyNoms)), withDestination ? api.query.staking.payee.multi(stashIds) : of(stashIds.map(() => emptyRewa)), withPrefs ? api.query.staking.validators.multi(stashIds) : of(stashIds.map(() => emptyPrefs)), withExposure ? api.query.staking.erasStakers.multi(stashIds.map(stashId => [activeEra, stashId])) : of(stashIds.map(() => emptyExpo))]);\n}\n\nfunction getBatch(api, activeEra, stashIds, flags) {\n  return getStashInfo(api, stashIds, activeEra, flags).pipe(switchMap(([controllerIdOpt, nominatorsOpt, rewardDestination, validatorPrefs, exposure]) => getLedgers(api, controllerIdOpt, flags).pipe(map(stakingLedgerOpts => stashIds.map((stashId, index) => parseDetails(stashId, controllerIdOpt[index], nominatorsOpt[index], rewardDestination[index], validatorPrefs[index], exposure[index], stakingLedgerOpts[index]))))));\n} //\n\n/**\n * @description From a stash, retrieve the controllerId and all relevant details\n */\n\n\nexport function query(instanceId, api) {\n  return memo(instanceId, (accountId, flags) => api.derive.staking.queryMulti([accountId], flags).pipe(map(([first]) => first)));\n}\nexport function queryMulti(instanceId, api) {\n  return memo(instanceId, (accountIds, flags) => accountIds.length ? api.derive.session.indexes().pipe(switchMap(({\n    activeEra\n  }) => {\n    const stashIds = accountIds.map(accountId => api.registry.createType('AccountId', accountId));\n    return getBatch(api, activeEra, stashIds, flags);\n  })) : of([]));\n}"]},"metadata":{},"sourceType":"module"}